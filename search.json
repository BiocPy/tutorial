[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BiocPy: Enabling Bioconductor workflows in Python",
    "section": "",
    "text": "Welcome\nBioconductor is an open-source software project that provides tools for the analysis and comprehension of genomic data. One of the main advantages of Bioconductor is the availability of standard data representations and large number of analysis tools for genomic experiments. These tools allow researchers to efficiently store, manipulate, and analyze their data across multiple tools and workflows.\nInspired by Bioconductor, BiocPy aims to facilitate bioinformatics workflows in Python. To achieve this goal, we developed several core data structures that align closely to the Bioconductor implementations. These structures include BiocFrame, providing a Bioconductor-like data frame class, and the GenomicRanges which aids in representing genomic regions and facilitating analysis. They serve as essential and foundational data structures, acting as the building blocks for extensive and complex representations. For instance, container classes like SummarizedExperiment, SingleCellExperiment and MultiAssayExperiment represent single or multi-omic experimental data and metadata.\nAdditionally, BiocPy introduces infrastructure packages supporting delayed operations (DelayedArray) and incorporates various generics and utilities in BiocUtils. While there have been previous efforts to port bioconductor representations into Python e.g. AnnData, plyranges, these efforts are fragmented and have limited interoperability. To our knowledge, BiocPy is the first Python framework to provide seamless, well-integrated data structures and representations for genomic data analysis.\nFor convenient access to experimental data stored in RDS files, the rds2py package provides bindings to the rds2cpp library. This enables the direct reading of RDS files in Python, eliminating the requirement for additional data conversion tools or intermediate formats. The package’s functionality streamlines the transition between Python and R, facilitating seamless analysis.\nAll packages within the BiocPy ecosystem are published to Python’s Package Index (PyPI).",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#selected-packages",
    "href": "index.html#selected-packages",
    "title": "BiocPy: Enabling Bioconductor workflows in Python",
    "section": "Selected packages",
    "text": "Selected packages\nFor complete list of all packages, please visit the GitHub:BiocPy repository.\n\nCore representations:\n\nBiocFrame (GitHub, Docs): Bioconductor-like dataframes in Python.\nIRanges (GitHub, Docs): Python implementation of the IRanges package to support interval arithmetic.\nGenomicRanges (GitHub, Docs, BioC): Container class to represent genomic locations and support genomic analysis.\nSummarizedExperiment (GitHub, Docs): Container class to represent genomic experiments, following Bioconductor’s SummarizedExperiment.\nSingleCellExperiment (GitHub, Docs): Container class to represent single-cell experiments; follows Bioconductor’s SingleCellExperiment.\nMultiAssayExperiment (GitHub, Docs): Container class to represent multiple experiments and assays performed over a set of samples. follows Bioconductor’s MAE R/Bioc Package.\n\n\n\nAnalysis packages\n\nscranpy(GitHub, Docs): Python bindings to the single-cell analysis methods from libscran and related C++ libraries.\nsingler(GitHub, Docs): Python bindings to the singleR algorithm to annotate cell types from known references.\n\n\n\nInteroperability with R\n\nrds2py (GitHub, Docs): Read RDS files directly in Python. Supports Bioconductor’s SummarizedExperiment and SingleCellExperiment in addition to matrices, data frames and vectors.\n\n\n\nUtility packages\n\nBiocUtils (GitHub, Docs): Common utilities for use across packages, mostly to mimic convenient aspects of base R.\nmopsy (GitHub, Docs): Helper functions to perform row or column operations over numpy and scipy matrices. Provides an interface similar to base R matrix methods/MatrixStats methods.\npyBiocFileCache (GitHub, Docs): File system based cache for resources & metadata.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#further-reading",
    "href": "index.html#further-reading",
    "title": "BiocPy: Enabling Bioconductor workflows in Python",
    "section": "Further reading",
    "text": "Further reading\nMany online resources offer detailed information on these data structures, namely:\n\nhttps://compgenomr.github.io/book/\nhttps://www.nature.com/articles/nmeth.3252\nhttps://www.nature.com/articles/s41592-019-0654-x\nhttps://github.com/waldronlab/EPIC-BiocIntro\n\n\nNotes\nThis is a reproducible Quarto book with reusable snippets. To learn more about Quarto books visit https://quarto.org/docs/books. Check out Reproduce me for more information.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "chapters/representations/index.html",
    "href": "chapters/representations/index.html",
    "title": "The basics",
    "section": "",
    "text": "Install packages\nThe biocpy package serves as a convenient wrapper that installs all the core packages within the ecosystem.\nAlternatively, you can install specific packages as required. For example:",
    "crumbs": [
      "The basics"
    ]
  },
  {
    "objectID": "chapters/representations/index.html#install-packages",
    "href": "chapters/representations/index.html#install-packages",
    "title": "The basics",
    "section": "",
    "text": "pip install biocpy\n\npip install summarizedexperiment # &lt;package-name&gt;",
    "crumbs": [
      "The basics"
    ]
  },
  {
    "objectID": "chapters/representations/index.html#update-packages",
    "href": "chapters/representations/index.html#update-packages",
    "title": "The basics",
    "section": "Update packages",
    "text": "Update packages\nTo update packages, use the following command:\npip install -U biocpy # or &lt;package-name&gt;",
    "crumbs": [
      "The basics"
    ]
  },
  {
    "objectID": "chapters/representations/atomics.html",
    "href": "chapters/representations/atomics.html",
    "title": "Atomics",
    "section": "",
    "text": "Installation\nTo begin using the package, you can install it from PyPI",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Atomics</span>"
    ]
  },
  {
    "objectID": "chapters/representations/atomics.html#installation",
    "href": "chapters/representations/atomics.html#installation",
    "title": "Atomics",
    "section": "",
    "text": "pip install biocutils",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Atomics</span>"
    ]
  },
  {
    "objectID": "chapters/representations/atomics.html#atomic-lists",
    "href": "chapters/representations/atomics.html#atomic-lists",
    "title": "Atomics",
    "section": "Atomic lists",
    "text": "Atomic lists\nThe package provides several atomic lists that are coerced into appropriate types. These include BooleanList, FloatList, NamedList, IntegerList, and StringList.\nLet’s explore BooleanList, which resembles a regular Python list but coercing anything added to it into a boolean. Additionally, None values are accepted and treated as missing booleans.\nThis list may also be named (see NamedList), which provides dictionary-like functionality.\n\nfrom biocutils import BooleanList, NamedList\n\nx = BooleanList([ True, False, False, True ])\nprint(x)\n\n[True, False, False, True]\n\n\nSimilarly, one can create atomic lists for other types, such as FloatList:\n\nfrom biocutils import FloatList\n\nx = FloatList([ 1.1, 2, 3, 4 ])\nprint(x)\n\n[1.1, 2.0, 3.0, 4.0]\n\n\nAccessing these vectors is similar to any other list:\n\nprint(\"2nd element:\", x[2])\n\nprint(\"reassign value\")\nx[1] = 50\nprint(\"x: \", x)\n\n2nd element: 3.0\nreassign value\nx:  [1.1, 50.0, 3.0, 4.0]\n\n\nTo convert objects back to Python lists:\n\nlist(x)\n\n[1.1, 50.0, 3.0, 4.0]",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Atomics</span>"
    ]
  },
  {
    "objectID": "chapters/representations/atomics.html#factor-class",
    "href": "chapters/representations/atomics.html#factor-class",
    "title": "Atomics",
    "section": "Factor class",
    "text": "Factor class\nThe Factor class is analogous to R’s factor. It comprises a vector of integer codes, each corresponding to an index within a list of unique strings (levels). The purpose is to encode a list of strings as integers for streamlined numerical analysis.\nThe most straightforward way to create a Factor is from an existing list of strings:\n\nfrom biocutils import Factor\n\nf = Factor.from_sequence([\"A\", \"B\", \"A\", \"B\", \"E\"])\nprint(f)\n\nFactor of length 5 with 3 levels\nvalues: A, B, A, B, E\nlevels: A, B, E\nordered: False\n\n\nAlternatively, if you already have a list of codes and associated levels:\n\nf = Factor([0, 1, 2, 0, 2, 4], levels=[\"A\", \"B\", \"C\", \"D\", \"E\"])\nprint(f)\n\nFactor of length 6 with 5 levels\nvalues: A, B, C, A, C, E\nlevels: A, B, C, D, E\nordered: False\n\n\nTo convert a Factor back to a Python list:\n\nlist(f)\n\n['A', 'B', 'C', 'A', 'C', 'E']",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Atomics</span>"
    ]
  },
  {
    "objectID": "chapters/representations/atomics.html#subset-generic",
    "href": "chapters/representations/atomics.html#subset-generic",
    "title": "Atomics",
    "section": "subset generic",
    "text": "subset generic\nThe Biocutils package introduces a subset generic function designed to handle n-dimensional objects, where n &gt; 1 (i.e., objects with a shape property of length greater than 1). When applied, the function first verifies the dimensionality of the input objects. If they are n-dimensional, it invokes subset_rows() to perform the subsetting along the first dimension. On the other hand, if the objects are deemed vector-like, the function utilizes subset_sequence() for the subsetting operation.\n\nfrom biocutils import subset\n\nx = [1, 2, 3, 4, 5]\nsubset(x, [0, 2, 4])\n\n[1, 3, 5]",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Atomics</span>"
    ]
  },
  {
    "objectID": "chapters/representations/atomics.html#combine-generic",
    "href": "chapters/representations/atomics.html#combine-generic",
    "title": "Atomics",
    "section": "combine generic",
    "text": "combine generic\nThe combine generic function in Biocutils is designed to accommodate objects of varying dimensions. It begins by examining the dimensionality of the input objects: if they are n-dimensional for n &gt; 1 (i.e., possessing a shape property of length greater than 1), the function utilizes combine_rows() to merge them along the first dimension. Conversely, if the objects exhibit a vector-like structure, the function employs combine_sequences() for the combination process.\n\nimport numpy as np\nfrom biocutils import combine\n\nx = [1, 2, 3]\ny = [0.1, 0.2]\nxd = np.array(x)\n\ncombine(xd, y)\n\narray([1. , 2. , 3. , 0.1, 0.2])",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Atomics</span>"
    ]
  },
  {
    "objectID": "chapters/representations/atomics.html#other-utilities",
    "href": "chapters/representations/atomics.html#other-utilities",
    "title": "Atomics",
    "section": "Other utilities",
    "text": "Other utilities\n\nmatch\n\nimport biocutils\nbiocutils.match([\"A\", \"C\", \"E\"], [\"A\", \"B\", \"C\", \"D\", \"E\"])\n\narray([0, 2, 4], dtype=int8)\n\n\n\n\nintersect\n\nimport biocutils\nbiocutils.intersect([\"A\", \"B\", \"C\", \"D\"], [\"D\", \"A\", \"E\"])\n\n['A', 'D']\n\n\n\n\nunion\n\nimport biocutils\nbiocutils.union([\"A\", \"B\", \"C\", \"D\"], [\"D\", \"A\", \"E\"])\n\n['A', 'B', 'C', 'D', 'E']\n\n\n\n\nis_list_of_type\nChecks if all elements of a list or tuple are of the same type.\n\nimport biocutils\nimport numpy as np\n\nx = [np.random.rand(3), np.random.rand(3, 2)]\nbiocutils.is_list_of_type(x, np.ndarray)\n\nTrue\n\n\nRefer to the documentation for comprehensive details on these functionalities.",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Atomics</span>"
    ]
  },
  {
    "objectID": "chapters/representations/biocframe.html",
    "href": "chapters/representations/biocframe.html",
    "title": "BiocFrame - Bioconductor-like data frames",
    "section": "",
    "text": "Installation\nTo get started, install the package from PyPI",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>`BiocFrame` - Bioconductor-like data frames</span>"
    ]
  },
  {
    "objectID": "chapters/representations/biocframe.html#installation",
    "href": "chapters/representations/biocframe.html#installation",
    "title": "BiocFrame - Bioconductor-like data frames",
    "section": "",
    "text": "pip install biocframe",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>`BiocFrame` - Bioconductor-like data frames</span>"
    ]
  },
  {
    "objectID": "chapters/representations/biocframe.html#advantages-of-biocframe",
    "href": "chapters/representations/biocframe.html#advantages-of-biocframe",
    "title": "BiocFrame - Bioconductor-like data frames",
    "section": "Advantages of BiocFrame",
    "text": "Advantages of BiocFrame\nOne of the core principles guiding the implementation of the BiocFrame class is “what you put is what you get.” Unlike Pandas DataFrame, BiocFrame makes no assumptions about the types of the columns provided as input. Some key differences to highlight the advantages of using BiocFrame are especially in terms of modifications to column types and handling nested dataframes.\n\nInadvertent modification of types\nAs an example, Pandas DataFrame modifies the types of the input data. These assumptions may cause issues when interoperating between R and Python.\n\nimport pandas as pd\nimport numpy as np\nfrom array import array\n\ndf = pd.DataFrame({\n    \"numpy_vec\": np.zeros(10),\n    \"list_vec\": [1]* 10,\n    \"native_array_vec\": array('d', [3.14] * 10) # less used but native python arrays\n})\n\nprint(\"type of numpy_vector column:\", type(df[\"numpy_vec\"]), df[\"numpy_vec\"].dtype)\nprint(\"type of list_vector column:\", type(df[\"list_vec\"]), df[\"list_vec\"].dtype)\nprint(\"type of native_array_vector column:\", type(df[\"native_array_vec\"]), df[\"native_array_vec\"].dtype)\n\nprint(df)\n\ntype of numpy_vector column: &lt;class 'pandas.core.series.Series'&gt; float64\ntype of list_vector column: &lt;class 'pandas.core.series.Series'&gt; int64\ntype of native_array_vector column: &lt;class 'pandas.core.series.Series'&gt; float64\n   numpy_vec  list_vec  native_array_vec\n0        0.0         1              3.14\n1        0.0         1              3.14\n2        0.0         1              3.14\n3        0.0         1              3.14\n4        0.0         1              3.14\n5        0.0         1              3.14\n6        0.0         1              3.14\n7        0.0         1              3.14\n8        0.0         1              3.14\n9        0.0         1              3.14\n\n\nWith BiocFrame, no assumptions are made, and the input data is not cast into (un)expected types:\n\nfrom biocframe import BiocFrame\nimport numpy as np\nfrom array import array\n\nbframe_types = BiocFrame({\n    \"numpy_vec\": np.zeros(10),\n    \"list_vec\": [1]* 10,\n    \"native_array_vec\": array('d', [3.14] * 10)\n})\n\nprint(\"type of numpy_vector column:\", type(bframe_types[\"numpy_vec\"]))\nprint(\"type of list_vector column:\", type(bframe_types[\"list_vec\"]))\nprint(\"type of native_array_vector column:\", type(bframe_types[\"native_array_vec\"]))\n\nprint(bframe_types)\n\ntype of numpy_vector column: &lt;class 'numpy.ndarray'&gt;\ntype of list_vector column: &lt;class 'list'&gt;\ntype of native_array_vector column: &lt;class 'array.array'&gt;\nBiocFrame with 10 rows and 3 columns\n             numpy_vec list_vec native_array_vec\n    &lt;ndarray[float64]&gt;   &lt;list&gt;          &lt;array&gt;\n[0]                0.0        1             3.14\n[1]                0.0        1             3.14\n[2]                0.0        1             3.14\n[3]                0.0        1             3.14\n[4]                0.0        1             3.14\n[5]                0.0        1             3.14\n[6]                0.0        1             3.14\n[7]                0.0        1             3.14\n[8]                0.0        1             3.14\n[9]                0.0        1             3.14\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis behavior remains consistent when extracting, slicing, combining, or performing any supported operation on BiocFrame objects.\n\n\n\n\nHandling complex nested frames\nPandas DataFrame does not support nested structures; therefore, running the snippet below will result in an error:\n\ndf = pd.DataFrame({\n    \"ensembl\": [\"ENS00001\", \"ENS00002\", \"ENS00002\"],\n    \"symbol\": [\"MAP1A\", \"BIN1\", \"ESR1\"],\n    \"ranges\": pd.DataFrame({\n        \"chr\": [\"chr1\", \"chr2\", \"chr3\"],\n        \"start\": [1000, 1100, 5000],\n        \"end\": [1100, 4000, 5500]\n    }),\n})\nprint(df)\n\nHowever, it is handled seamlessly with BiocFrame:\n\nbframe_nested = BiocFrame({\n    \"ensembl\": [\"ENS00001\", \"ENS00002\", \"ENS00002\"],\n    \"symbol\": [\"MAP1A\", \"BIN1\", \"ESR1\"],\n    \"ranges\": BiocFrame({\n        \"chr\": [\"chr1\", \"chr2\", \"chr3\"],\n        \"start\": [1000, 1100, 5000],\n        \"end\": [1100, 4000, 5500]\n    }),\n})\n\nprint(bframe_nested)\n\nBiocFrame with 3 rows and 3 columns\n     ensembl symbol         ranges\n      &lt;list&gt; &lt;list&gt;    &lt;BiocFrame&gt;\n[0] ENS00001  MAP1A chr1:1000:1100\n[1] ENS00002   BIN1 chr2:1100:4000\n[2] ENS00002   ESR1 chr3:5000:5500\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis behavior remains consistent when extracting, slicing, combining, or performing any other supported operations on BiocFrame objects.",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>`BiocFrame` - Bioconductor-like data frames</span>"
    ]
  },
  {
    "objectID": "chapters/representations/biocframe.html#construction",
    "href": "chapters/representations/biocframe.html#construction",
    "title": "BiocFrame - Bioconductor-like data frames",
    "section": "Construction",
    "text": "Construction\nCreating a BiocFrame object is straightforward; just provide the data as a dictionary.\n\nfrom biocframe import BiocFrame\n\nobj = {\n    \"ensembl\": [\"ENS00001\", \"ENS00002\", \"ENS00003\"],\n    \"symbol\": [\"MAP1A\", \"BIN1\", \"ESR1\"],\n}\nbframe = BiocFrame(obj)\nprint(bframe)\n\nBiocFrame with 3 rows and 2 columns\n     ensembl symbol\n      &lt;list&gt; &lt;list&gt;\n[0] ENS00001  MAP1A\n[1] ENS00002   BIN1\n[2] ENS00003   ESR1\n\n\n\n\n\n\n\n\nTip\n\n\n\nYou can specify complex objects as columns, as long as they have some “length” equal to the number of rows. For example, we can embed a BiocFrame within another BiocFrame.\n\n\n\nobj = {\n    \"ensembl\": [\"ENS00001\", \"ENS00002\", \"ENS00002\"],\n    \"symbol\": [\"MAP1A\", \"BIN1\", \"ESR1\"],\n    \"ranges\": BiocFrame({\n        \"chr\": [\"chr1\", \"chr2\", \"chr3\"],\n        \"start\": [1000, 1100, 5000],\n        \"end\": [1100, 4000, 5500]\n    }),\n}\n\nbframe2 = BiocFrame(obj, row_names=[\"row1\", \"row2\", \"row3\"])\nprint(bframe2)\n\nBiocFrame with 3 rows and 3 columns\n      ensembl symbol         ranges\n       &lt;list&gt; &lt;list&gt;    &lt;BiocFrame&gt;\nrow1 ENS00001  MAP1A chr1:1000:1100\nrow2 ENS00002   BIN1 chr2:1100:4000\nrow3 ENS00002   ESR1 chr3:5000:5500\n\n\nThe row_names parameter is analogous to index in the pandas world and should not contain missing strings. Additionally, you may provide:\n\ncolumn_data: A BiocFrameobject containing metadata about the columns. This must have the same number of rows as the numbers of columns.\nmetadata: Additional metadata about the object, usually a dictionary.\ncolumn_names: If different from the keys in the data. If not provided, this is automatically extracted from the keys in the data.\n\n\nInterop with pandas\nBiocFrame is intended for accurate representation of Bioconductor objects for interoperability with R, many users may prefer working with pandas DataFrame objects for their actual analyses. This conversion is easily achieved:\n\nfrom biocframe import BiocFrame\nbframe3 = BiocFrame(\n    {\n        \"foo\": [\"A\", \"B\", \"C\", \"D\", \"E\"],\n        \"bar\": [True, False, True, False, True]\n    }\n)\n\ndf = bframe3.to_pandas()\nprint(type(df))\nprint(df)\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\n  foo    bar\n0   A   True\n1   B  False\n2   C   True\n3   D  False\n4   E   True\n\n\nConverting back to a BiocFrame is similarly straightforward:\n\nout = BiocFrame.from_pandas(df)\nprint(out)\n\nBiocFrame with 5 rows and 2 columns\n     foo    bar\n  &lt;list&gt; &lt;list&gt;\n0      A   True\n1      B  False\n2      C   True\n3      D  False\n4      E   True",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>`BiocFrame` - Bioconductor-like data frames</span>"
    ]
  },
  {
    "objectID": "chapters/representations/biocframe.html#extracting-data",
    "href": "chapters/representations/biocframe.html#extracting-data",
    "title": "BiocFrame - Bioconductor-like data frames",
    "section": "Extracting data",
    "text": "Extracting data\nBiocPy classes follow a functional paradigm for accessing or setting properties, with further details discussed in functional paradigm section.\nProperties can be directly accessed from the object:\n\nprint(\"shape:\", bframe.shape)\nprint(\"column names (functional style):\", bframe.get_column_names())\nprint(\"column names (as property):\", bframe.column_names) # same as above\n\nshape: (3, 2)\ncolumn names (functional style): ['ensembl', 'symbol']\ncolumn names (as property): ['ensembl', 'symbol']\n\n\nWe can fetch individual columns:\n\nprint(\"functional style:\", bframe.get_column(\"ensembl\"))\nprint(\"w/ accessor\", bframe[\"ensembl\"])\n\nfunctional style: ['ENS00001', 'ENS00002', 'ENS00003']\nw/ accessor ['ENS00001', 'ENS00002', 'ENS00003']\n\n\nAnd we can get individual rows as a dictionary:\n\nbframe.get_row(2)\n\n{'ensembl': 'ENS00003', 'symbol': 'ESR1'}\n\n\n\n\n\n\n\n\nTo retrieve a subset of the data in the BiocFrame, we use the subset ([]) operator. This operator accepts different subsetting arguments, such as a boolean vector, a slice object, a sequence of indices, or row/column names.\n\n\n\n\nsliced_with_bools = bframe[1:2, [True, False, False]]\nprint(\"Subset using booleans: \\n\", sliced_with_bools)\n\nsliced_with_names = bframe[[0,2], [\"symbol\", \"ensembl\"]]\nprint(\"\\nSubset using column names: \\n\", sliced_with_names)\n\n# Short-hand to get a single column:\nprint(\"\\nShort-hand to get a single column: \\n\", bframe[\"ensembl\"])\n\nSubset using booleans: \n BiocFrame with 1 row and 1 column\n     ensembl\n      &lt;list&gt;\n[0] ENS00002\n\nSubset using column names: \n BiocFrame with 2 rows and 2 columns\n    symbol  ensembl\n    &lt;list&gt;   &lt;list&gt;\n[0]  MAP1A ENS00001\n[1]   ESR1 ENS00003\n\nShort-hand to get a single column: \n ['ENS00001', 'ENS00002', 'ENS00003']",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>`BiocFrame` - Bioconductor-like data frames</span>"
    ]
  },
  {
    "objectID": "chapters/representations/biocframe.html#setting-data",
    "href": "chapters/representations/biocframe.html#setting-data",
    "title": "BiocFrame - Bioconductor-like data frames",
    "section": "Setting data",
    "text": "Setting data\n\nPreferred approach\nFor setting properties, we encourage a functional style of programming to avoid mutating the object directly. This helps prevent inadvertent modifications of BiocFrame instances within larger data structures.\n\nmodified = bframe.set_column_names([\"column1\", \"column2\"])\nprint(modified)\n\nBiocFrame with 3 rows and 2 columns\n     column1 column2\n      &lt;list&gt;  &lt;list&gt;\n[0] ENS00001   MAP1A\n[1] ENS00002    BIN1\n[2] ENS00003    ESR1\n\n\nNow let’s check the column names of the original object,\n\n# Original is unchanged:\nprint(bframe.get_column_names())\n\n['ensembl', 'symbol']\n\n\nTo add new columns, or replace existing ones:\n\nmodified = bframe.set_column(\"symbol\", [\"A\", \"B\", \"C\"])\nprint(modified)\n\nmodified = bframe.set_column(\"new_col_name\", range(2, 5))\nprint(modified)\n\nBiocFrame with 3 rows and 2 columns\n     ensembl symbol\n      &lt;list&gt; &lt;list&gt;\n[0] ENS00001      A\n[1] ENS00002      B\n[2] ENS00003      C\nBiocFrame with 3 rows and 3 columns\n     ensembl symbol new_col_name\n      &lt;list&gt; &lt;list&gt;      &lt;range&gt;\n[0] ENS00001  MAP1A            2\n[1] ENS00002   BIN1            3\n[2] ENS00003   ESR1            4\n\n\nChange the row or column names:\n\nmodified = bframe.\\\n    set_column_names([\"FOO\", \"BAR\"]).\\\n    set_row_names(['alpha', 'bravo', 'charlie'])\nprint(modified)\n\nBiocFrame with 3 rows and 2 columns\n             FOO    BAR\n          &lt;list&gt; &lt;list&gt;\n  alpha ENS00001  MAP1A\n  bravo ENS00002   BIN1\ncharlie ENS00003   ESR1\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe functional style allows you to chain multiple operations.\n\n\nWe also support Bioconductor’s metadata concepts, either along the columns or for the entire object:\n\nmodified = bframe.\\\n    set_metadata({ \"author\": \"Jayaram Kancherla\" }).\\\n    set_column_data(BiocFrame({\"column_source\": [\"Ensembl\", \"HGNC\" ]}))\nprint(modified)\n\nBiocFrame with 3 rows and 2 columns\n     ensembl symbol\n      &lt;list&gt; &lt;list&gt;\n[0] ENS00001  MAP1A\n[1] ENS00002   BIN1\n[2] ENS00003   ESR1\n------\ncolumn_data(1): column_source\nmetadata(1): author\n\n\n\n\nThe not-preferred-way\nProperties can also be set by direct assignment for in-place modification. We prefer not to do it this way as it can silently mutate BiocFrame instances inside other data structures. Nonetheless:\n\ntestframe = BiocFrame({ \"A\": [1,2,3], \"B\": [4,5,6] })\ntestframe.column_names = [\"column1\", \"column2\" ]\nprint(testframe)\n\nBiocFrame with 3 rows and 2 columns\n    column1 column2\n     &lt;list&gt;  &lt;list&gt;\n[0]       1       4\n[1]       2       5\n[2]       3       6\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/biocframe/BiocFrame.py:468: UserWarning: Setting property 'column_names' is an in-place operation, use 'set_column_names' instead\n  warn(\n\n\n\n\n\n\n\n\nCaution\n\n\n\nWarnings are raised when properties are directly mutated. These assignments are the same as calling the corresponding set_*() methods with in_place = True. It is best to do this only if the BiocFrame object is not being used anywhere else; otherwise, it is safer to just create a (shallow) copy via the default in_place = False.\n\n\nSimilarly, we could set or replace columns directly:\n\ntestframe[\"column2\"] = [\"A\", \"B\", \"C\"]\ntestframe[1:3, [\"column1\",\"column2\"]] = BiocFrame({\"x\":[4, 5], \"y\":[\"E\", \"F\"]})\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/biocframe/BiocFrame.py:833: UserWarning: This method performs an in-place operation, use 'set_column' instead\n  warn(\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/biocframe/BiocFrame.py:827: UserWarning: This method performs an in-place operation, use 'set_slice' instead\n  warn(",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>`BiocFrame` - Bioconductor-like data frames</span>"
    ]
  },
  {
    "objectID": "chapters/representations/biocframe.html#iterate-over-rows",
    "href": "chapters/representations/biocframe.html#iterate-over-rows",
    "title": "BiocFrame - Bioconductor-like data frames",
    "section": "Iterate over rows",
    "text": "Iterate over rows\nYou can iterate over the rows of a BiocFrame object. name is None if the object does not contain any row_names. To iterate over the first two rows:\n\nfor name, row in bframe[:2,]:\n    print(name, row)\n\nNone {'ensembl': 'ENS00001', 'symbol': 'MAP1A'}\nNone {'ensembl': 'ENS00002', 'symbol': 'BIN1'}",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>`BiocFrame` - Bioconductor-like data frames</span>"
    ]
  },
  {
    "objectID": "chapters/representations/biocframe.html#combining-objects",
    "href": "chapters/representations/biocframe.html#combining-objects",
    "title": "BiocFrame - Bioconductor-like data frames",
    "section": "Combining objects",
    "text": "Combining objects\nBiocFrame implements methods for the various combine generics from BiocUtils. For example, to combine by row:\n\nimport biocutils\n\nbframe1 = BiocFrame({\n    \"odd\": [1, 3, 5, 7, 9],\n    \"even\": [0, 2, 4, 6, 8],\n})\n\nbframe2 = BiocFrame({\n    \"odd\": [11, 33, 55, 77, 99],\n    \"even\": [0, 22, 44, 66, 88],\n})\n\ncombined = biocutils.combine_rows(bframe1, bframe2)\nprint(combined)\n\nBiocFrame with 10 rows and 2 columns\n       odd   even\n    &lt;list&gt; &lt;list&gt;\n[0]      1      0\n[1]      3      2\n[2]      5      4\n[3]      7      6\n[4]      9      8\n[5]     11      0\n[6]     33     22\n[7]     55     44\n[8]     77     66\n[9]     99     88\n\n\nSimilarly, to combine by column:\n\nbframe3 = BiocFrame({\n    \"foo\": [\"A\", \"B\", \"C\", \"D\", \"E\"],\n    \"bar\": [True, False, True, False, True]\n})\n\ncombined = biocutils.combine_columns(bframe1, bframe3)\nprint(combined)\n\nBiocFrame with 5 rows and 4 columns\n       odd   even    foo    bar\n    &lt;list&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt;\n[0]      1      0      A   True\n[1]      3      2      B  False\n[2]      5      4      C   True\n[3]      7      6      D  False\n[4]      9      8      E   True\n\n\n\nRelaxed combine operation\nBy default, the combine methods assume that the number and identity of columns (for combine_rows()) or rows (for combine_columns()) are the same across objects. In situations where this is not the case, such as having different columns across objects, we can use relaxed_combine_rows() instead:\n\nfrom biocframe import relaxed_combine_rows\n\nmodified2 = bframe2.set_column(\"foo\", [\"A\", \"B\", \"C\", \"D\", \"E\"])\n\ncombined = biocutils.relaxed_combine_rows(bframe1, modified2)\nprint(combined)\n\nBiocFrame with 10 rows and 3 columns\n       odd   even    foo\n    &lt;list&gt; &lt;list&gt; &lt;list&gt;\n[0]      1      0   None\n[1]      3      2   None\n[2]      5      4   None\n[3]      7      6   None\n[4]      9      8   None\n[5]     11      0      A\n[6]     33     22      B\n[7]     55     44      C\n[8]     77     66      D\n[9]     99     88      E\n\n\n\n\nSql-like join operation\nSimilarly, if the rows are different, we can use BiocFrame’s merge function. This function uses the row_names as the index to perform this operation; you can specify an alternative set of keys through the by parameter.\n\nfrom biocframe import merge\n\nmodified1 = bframe1.set_row_names([\"A\", \"B\", \"C\", \"D\", \"E\"])\nmodified3 = bframe3.set_row_names([\"C\", \"D\", \"E\", \"F\", \"G\"])\n\ncombined = merge([modified1, modified3], by=None, join=\"outer\")\nprint(combined)\n\nBiocFrame with 7 rows and 4 columns\n     odd   even    foo    bar\n  &lt;list&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt;\nA      1      0   None   None\nB      3      2   None   None\nC      5      4      A   True\nD      7      6      B  False\nE      9      8      C   True\nF   None   None      D  False\nG   None   None      E   True",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>`BiocFrame` - Bioconductor-like data frames</span>"
    ]
  },
  {
    "objectID": "chapters/representations/biocframe.html#empty-frames",
    "href": "chapters/representations/biocframe.html#empty-frames",
    "title": "BiocFrame - Bioconductor-like data frames",
    "section": "Empty Frames",
    "text": "Empty Frames\nWe can create empty BiocFrame objects that only specify the number of rows. This is beneficial in scenarios where BiocFrame objects are incorporated into larger data structures but do not contain any data themselves.\n\nempty = BiocFrame(number_of_rows=100)\nprint(empty)\n\nBiocFrame with 100 rows and 0 columns\n\n\n\nMost operations detailed in this document can be performed on an empty BiocFrame object.\n\nprint(\"Column names:\", empty.column_names)\n\nsubset_empty = empty[1:10,:]\nprint(\"\\nSubsetting an empty BiocFrame: \\n\", subset_empty)\n\nColumn names: []\n\nSubsetting an empty BiocFrame: \n BiocFrame with 9 rows and 0 columns",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>`BiocFrame` - Bioconductor-like data frames</span>"
    ]
  },
  {
    "objectID": "chapters/representations/biocframe.html#further-reading",
    "href": "chapters/representations/biocframe.html#further-reading",
    "title": "BiocFrame - Bioconductor-like data frames",
    "section": "Further reading",
    "text": "Further reading\n\nExplore more details the reference documentation.\nAdditionally, take a look at Bioconductor’s S4Vectors package, which implements the DFrame class upon which BiocFrame was built.",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>`BiocFrame` - Bioconductor-like data frames</span>"
    ]
  },
  {
    "objectID": "chapters/representations/genomicranges.html",
    "href": "chapters/representations/genomicranges.html",
    "title": "GenomicRanges: Genomic analysis",
    "section": "",
    "text": "Installation\nTo get started, install the package from PyPI",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>`GenomicRanges`: Genomic analysis</span>"
    ]
  },
  {
    "objectID": "chapters/representations/genomicranges.html#installation",
    "href": "chapters/representations/genomicranges.html#installation",
    "title": "GenomicRanges: Genomic analysis",
    "section": "",
    "text": "pip install genomicranges",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>`GenomicRanges`: Genomic analysis</span>"
    ]
  },
  {
    "objectID": "chapters/representations/genomicranges.html#construct-a-genomicranges-object",
    "href": "chapters/representations/genomicranges.html#construct-a-genomicranges-object",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Construct a GenomicRanges object",
    "text": "Construct a GenomicRanges object\nWe support multiple ways to initialize a GenomicRanges object.\n\nPreferred way\nTo construct a GenomicRanges object, we need to provide sequence information and genomic coordinates. This is achieved through the combination of the seqnames and ranges parameters. Additionally, you have the option to specify the strand, represented as a list of “+” (or 1) for the forward strand, “-” (or -1) for the reverse strand, or “*” (or 0) if the strand is unknown. You can also provide a NumPy vector that utilizes either the string or numeric representation to specify the strand. Optionally, you can use the mcols parameter to provide additional metadata about each genomic region.\n\nfrom genomicranges import GenomicRanges\nfrom iranges import IRanges\nfrom biocframe import BiocFrame\nfrom random import random\n\ngr = GenomicRanges(\n    seqnames=[\n        \"chr1\",\n        \"chr2\",\n        \"chr3\",\n        \"chr2\",\n        \"chr3\",\n    ],\n    ranges=IRanges([x for x in range(101, 106)], [11, 21, 25, 30, 5]),\n    strand=[\"*\", \"-\", \"*\", \"+\", \"-\"],\n    mcols=BiocFrame(\n        {\n            \"score\": range(0, 5),\n            \"GC\": [random() for _ in range(5)],\n        }\n    ),\n)\n\nprint(gr)\n\nGenomicRanges with 5 ranges and 5 metadata columns\n    seqnames    ranges          strand     score                   GC\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;range&gt;               &lt;list&gt;\n[0]     chr1 101 - 112               * |       0   0.9259171762579111\n[1]     chr2 102 - 123               - |       1   0.6507631512159886\n[2]     chr3 103 - 128               * |       2   0.6281485863084049\n[3]     chr2 104 - 134               + |       3 0.012963375302070146\n[4]     chr3 105 - 110               - |       4  0.12424578768320371\n------\nseqinfo(3 sequences): chr1 chr2 chr3\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/genomicranges/SeqInfo.py:348: UserWarning: 'seqnames' is deprecated, use 'get_seqnames' instead\n  warn(\"'seqnames' is deprecated, use 'get_seqnames' instead\", UserWarning)\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe input for mcols is expected to be a BiocFrame object and will be converted to a BiocFrame in case a pandas DataFrame is supplied.\n\n\n\n\nFrom UCSC or GTF file\nYou can also import genomes from UCSC or load a genome annotation from a GTF file. This requires installation of additional packages pandas and joblib to parse and extract various attributes from the gtf file.\n\n\n\n\n\n\nNote\n\n\n\nA future version of this package might implement or take advantage of existing genomic parser packages in Python to support various file formats.\n\n\n\nimport genomicranges\n\n# gr = genomicranges.read_gtf(&lt;PATH TO GTF&gt;)\n\n# OR\n\nhuman_gr = genomicranges.read_ucsc(genome=\"hg19\")\nprint(human_gr)\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/genomicranges/SeqInfo.py:348: UserWarning: 'seqnames' is deprecated, use 'get_seqnames' instead\n  warn(\"'seqnames' is deprecated, use 'get_seqnames' instead\", UserWarning)\n\n\nGenomicRanges with 1760959 ranges and 1760959 metadata columns\n        seqnames                ranges          strand    source    feature  score  frame                                    group      gene_id\n           &lt;str&gt;             &lt;IRanges&gt; &lt;ndarray[int8]&gt;    &lt;list&gt;     &lt;list&gt; &lt;list&gt; &lt;list&gt;                                   &lt;list&gt;       &lt;list&gt;\n      0     chr1         11869 - 14362               + | refGene transcript      .      . gene_id \"LOC102725121\"; transcript_id... LOC102725121\n      1     chr1         11869 - 12227               + | refGene       exon      .      . gene_id \"LOC102725121\"; transcript_id... LOC102725121\n      2     chr1         12613 - 12721               + | refGene       exon      .      . gene_id \"LOC102725121\"; transcript_id... LOC102725121\n             ...                   ...             ... |     ...        ...    ...    ...                                      ...          ...\n1760956     chr6 159050762 - 159050851               + | refGene       exon      .      . gene_id \"TMEM181\"; transcript_id \"NR_...      TMEM181\n1760957     chr6 159052355 - 159052518               + | refGene       exon      .      . gene_id \"TMEM181\"; transcript_id \"NR_...      TMEM181\n1760958     chr6 159052842 - 159056461               + | refGene       exon      .      . gene_id \"TMEM181\"; transcript_id \"NR_...      TMEM181\n        transcript_id    gene_name exon_number      exon_id\n               &lt;list&gt;       &lt;list&gt;      &lt;list&gt;       &lt;list&gt;\n      0     NR_148357 LOC102725121         nan          nan\n      1     NR_148357 LOC102725121           1  NR_148357.1\n      2     NR_148357 LOC102725121           2  NR_148357.2\n                  ...          ...         ...          ...\n1760956     NR_164859      TMEM181          15 NR_164859.15\n1760957     NR_164859      TMEM181          16 NR_164859.16\n1760958     NR_164859      TMEM181          17 NR_164859.17\n------\nseqinfo(54 sequences): chr1 chr10 chr11 ... chrUn_gl000241 chrX chrY\n\n\n\n\nPandas DataFrame\nIf your genomic coordinates are represented as a pandas DataFrame, convert this into GenomicRanges if it contains the necessary columns.\n\n\n\n\n\n\nImportant\n\n\n\nThe DataFrame must contain columns seqnames, starts and ends to represent genomic coordinates. The rest of the columns are considered metadata and will be available in the mcols slot of the GenomicRanges object.\n\n\n\nfrom genomicranges import GenomicRanges\nimport pandas as pd\n\ndf = pd.DataFrame(\n    {\n        \"seqnames\": [\"chr1\", \"chr2\", \"chr1\", \"chr3\", \"chr2\"],\n        \"starts\": [101, 102, 103, 104, 109],\n        \"ends\": [112, 103, 128, 134, 111],\n        \"strand\": [\"*\", \"-\", \"*\", \"+\", \"-\"],\n        \"score\": range(0, 5),\n        \"GC\": [random() for _ in range(5)],\n    }\n)\n\ngr_from_df = GenomicRanges.from_pandas(df)\nprint(gr_from_df)\n\nGenomicRanges with 5 ranges and 5 metadata columns\n  seqnames    ranges          strand    score                  GC\n     &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;list&gt;              &lt;list&gt;\n0     chr1 101 - 112               * |      0   0.830324118114418\n1     chr2 102 - 103               - |      1  0.3591552961645831\n2     chr1 103 - 128               * |      2  0.6346277624343081\n3     chr3 104 - 134               + |      3  0.9285525447256141\n4     chr2 109 - 111               - |      4 0.08564419630840436\n------\nseqinfo(3 sequences): chr1 chr2 chr3\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/genomicranges/SeqInfo.py:348: UserWarning: 'seqnames' is deprecated, use 'get_seqnames' instead\n  warn(\"'seqnames' is deprecated, use 'get_seqnames' instead\", UserWarning)",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>`GenomicRanges`: Genomic analysis</span>"
    ]
  },
  {
    "objectID": "chapters/representations/genomicranges.html#sequence-information",
    "href": "chapters/representations/genomicranges.html#sequence-information",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Sequence information",
    "text": "Sequence information\nThe package also provides a SeqInfo class to update or modify sequence information stored in the object. Learn more about this in the GenomeInfoDb package.\n\nfrom genomicranges import SeqInfo\n\nseq = SeqInfo(\n    seqnames = [\"chr1\", \"chr2\", \"chr3\"],\n    seqlengths = [110, 112, 118],\n    is_circular = [True, True, False],\n    genome = \"hg19\",\n)\ngr_with_seq = gr.set_seqinfo(seq)\nprint(gr_with_seq)\n\nGenomicRanges with 5 ranges and 5 metadata columns\n    seqnames    ranges          strand     score                   GC\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;range&gt;               &lt;list&gt;\n[0]     chr1 101 - 112               * |       0   0.9259171762579111\n[1]     chr2 102 - 123               - |       1   0.6507631512159886\n[2]     chr3 103 - 128               * |       2   0.6281485863084049\n[3]     chr2 104 - 134               + |       3 0.012963375302070146\n[4]     chr3 105 - 110               - |       4  0.12424578768320371\n------\nseqinfo(3 sequences): chr1 chr2 chr3",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>`GenomicRanges`: Genomic analysis</span>"
    ]
  },
  {
    "objectID": "chapters/representations/genomicranges.html#getterssetters",
    "href": "chapters/representations/genomicranges.html#getterssetters",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Getters/Setters",
    "text": "Getters/Setters\nGetters are available to access various attributes using either the property notation or functional style.\n\n# access sequence names\nprint(\"seqnames (as property): \", gr.seqnames)\nprint(\"seqnames (functional style): \", gr.get_seqnames())\n\n# access all start positions\nprint(\"start positions: \", gr.start)\n\n# access annotation information if available\ngr.seqinfo\n\n# compute and return the widths of each region\nprint(\"width of each region: \", gr.get_width()) \n# or gr.width\n\n# access mcols\nprint(gr.mcols)\n\nseqnames (as property):  ['chr1', 'chr2', 'chr3', 'chr2', 'chr3']\nseqnames (functional style):  ['chr1', 'chr2', 'chr3', 'chr2', 'chr3']\nstart positions:  [101 102 103 104 105]\nwidth of each region:  [11 21 25 30  5]\nBiocFrame with 5 rows and 2 columns\n      score                   GC\n    &lt;range&gt;               &lt;list&gt;\n[0]       0   0.9259171762579111\n[1]       1   0.6507631512159886\n[2]       2   0.6281485863084049\n[3]       3 0.012963375302070146\n[4]       4  0.12424578768320371\n\n\n\nSetters\n\n\n\n\n\n\nImportant\n\n\n\nAll property-based setters are in_place operations, with further details discussed in functional paradigm section.\n\n\n\nmodified_mcols = gr.mcols.set_column(\"score\", range(1,6))\nmodified_gr = gr.set_mcols(modified_mcols)\nprint(modified_gr)\n\nGenomicRanges with 5 ranges and 5 metadata columns\n    seqnames    ranges          strand     score                   GC\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;range&gt;               &lt;list&gt;\n[0]     chr1 101 - 112               * |       1   0.9259171762579111\n[1]     chr2 102 - 123               - |       2   0.6507631512159886\n[2]     chr3 103 - 128               * |       3   0.6281485863084049\n[3]     chr2 104 - 134               + |       4 0.012963375302070146\n[4]     chr3 105 - 110               - |       5  0.12424578768320371\n------\nseqinfo(3 sequences): chr1 chr2 chr3\n\n\nor use an in-place operation:\n\ngr.mcols.set_column(\"score\", range(1,6), in_place=True)\nprint(gr.mcols)\n\nBiocFrame with 5 rows and 2 columns\n      score                   GC\n    &lt;range&gt;               &lt;list&gt;\n[0]       1   0.9259171762579111\n[1]       2   0.6507631512159886\n[2]       3   0.6281485863084049\n[3]       4 0.012963375302070146\n[4]       5  0.12424578768320371\n\n\n\n\nAccess ranges\nget_ranges() is a generic method to access only the genomic coordinates:\n\n# or gr.get_ranges()\nprint(gr.ranges)\n\nIRanges object with 5 ranges and 0 metadata columns\n               start              end            width\n    &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt;\n[0]              101              112               11\n[1]              102              123               21\n[2]              103              128               25\n[3]              104              134               30\n[4]              105              110                5",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>`GenomicRanges`: Genomic analysis</span>"
    ]
  },
  {
    "objectID": "chapters/representations/genomicranges.html#subset-operations",
    "href": "chapters/representations/genomicranges.html#subset-operations",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Subset operations",
    "text": "Subset operations\nYou can subset a GenomicRange object using the subset ([]) operator. This operation accepts different slice input types, such as a boolean vector, a slice object, a list of indices, or names (if available) to subset.\n\n# get the first 3 regions\ngr[:3]\n\n# get 1, 3 and 2nd rows\n# note: the order is retained in the result\nprint(gr[[1,3,2]])\n\nGenomicRanges with 3 ranges and 3 metadata columns\n    seqnames    ranges          strand    score                   GC\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;list&gt;               &lt;list&gt;\n[0]     chr2 102 - 123               - |      2   0.6507631512159886\n[1]     chr2 104 - 134               + |      4 0.012963375302070146\n[2]     chr3 103 - 128               * |      3   0.6281485863084049\n------\nseqinfo(3 sequences): chr1 chr2 chr3",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>`GenomicRanges`: Genomic analysis</span>"
    ]
  },
  {
    "objectID": "chapters/representations/genomicranges.html#iterate-over-ranges",
    "href": "chapters/representations/genomicranges.html#iterate-over-ranges",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Iterate over ranges",
    "text": "Iterate over ranges\nYou can iterate over the regions of a GenomicRanges object. name is None if the object does not contain any names. To iterate over the first two ranges:\n\nfor name, row in gr[:2]:\n    print(name, row)\n\nNone GenomicRanges with 1 range and 1 metadata column\n    seqnames    ranges          strand    score                 GC\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;list&gt;             &lt;list&gt;\n[0]     chr1 101 - 112               * |      1 0.9259171762579111\n------\nseqinfo(3 sequences): chr1 chr2 chr3\nNone GenomicRanges with 1 range and 1 metadata column\n    seqnames    ranges          strand    score                 GC\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;list&gt;             &lt;list&gt;\n[0]     chr2 102 - 123               - |      2 0.6507631512159886\n------\nseqinfo(3 sequences): chr1 chr2 chr3",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>`GenomicRanges`: Genomic analysis</span>"
    ]
  },
  {
    "objectID": "chapters/representations/genomicranges.html#intra-range-transformations",
    "href": "chapters/representations/genomicranges.html#intra-range-transformations",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Intra-range transformations",
    "text": "Intra-range transformations\nFor detailed description of these methods, refer to either the Bioconductor’s or BiocPy’s documentation.\n\nflank: Flank the intervals based on start or end or both.\nshift: Shifts all the ranges specified by the shift argument.\nresize: Resizes the ranges to the specified width where either the start, end, or center is used as an anchor.\nnarrow: Narrows the ranges.\npromoters: Promoters generates promoter ranges for each range relative to the TSS. The promoter range is expanded around the TSS according to the upstream and downstream parameters.\nrestrict: Restricts the ranges to the interval(s) specified by the start and end arguments.\ntrim: Trims out-of-bound ranges located on non-circular sequences whose length is not NA.\n\n\ngr = GenomicRanges(\n    seqnames=[\n        \"chr1\",\n        \"chr2\",\n        \"chr3\",\n        \"chr2\",\n        \"chr3\",\n    ],\n    ranges=IRanges([x for x in range(101, 106)], [11, 21, 25, 30, 5]),\n    strand=[\"*\", \"-\", \"*\", \"+\", \"-\"],\n    mcols=BiocFrame(\n        {\n            \"score\": range(0, 5),\n            \"GC\": [random() for _ in range(5)],\n        }\n    ),\n)\n\n# flank\nflanked_gr = gr.flank(width=10, start=False, both=True)\n\n# shift\nshifted_gr = gr.shift(shift=10)\n\n# resize\nresized_gr = gr.resize(width=10, fix=\"end\", ignore_strand=True)\n\n# narrow\nnarrow_gr = gr.narrow(end=1, width=1)\n\n# promoters\nprom_gr = gr.promoters()\n\n# restrict\nrestrict_gr = gr.restrict(start=114, end=140, keep_all_ranges=True)\n\n# trim\ntrimmed_gr = gr.trim()\n\nprint(\"GenomicRanges after the trim operation:\")\nprint(trimmed_gr)\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/genomicranges/SeqInfo.py:405: UserWarning: 'seqlengths' is deprecated, use 'get_seqlengths' instead\n  warn(\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/genomicranges/SeqInfo.py:467: UserWarning: 'is_circular' is deprecated, use 'get_is_circular' instead\n  warn(\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/iranges/IRanges.py:290: UserWarning: Setting property 'width'is an in-place operation, use 'set_width' instead\n  warn(\n\n\nGenomicRanges after the trim operation:\nGenomicRanges with 5 ranges and 5 metadata columns\n    seqnames    ranges          strand     score                  GC\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;range&gt;              &lt;list&gt;\n[0]     chr1 101 - 112               * |       0  0.8599263814842364\n[1]     chr2 102 - 123               - |       1 0.13901097359221004\n[2]     chr3 103 - 128               * |       2  0.1481897439999802\n[3]     chr2 104 - 134               + |       3 0.08967930367658794\n[4]     chr3 105 - 110               - |       4   0.774668259166751\n------\nseqinfo(3 sequences): chr1 chr2 chr3",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>`GenomicRanges`: Genomic analysis</span>"
    ]
  },
  {
    "objectID": "chapters/representations/genomicranges.html#inter-range-methods",
    "href": "chapters/representations/genomicranges.html#inter-range-methods",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Inter-range methods",
    "text": "Inter-range methods\n\nrange: Returns a new GenomicRanges object containing range bounds for each distinct (seqname, strand) pair.\nreduce: returns a new GenomicRanges object containing reduced bounds for each distinct (seqname, strand) pair.\ngaps: Finds gaps in the GenomicRanges object for each distinct (seqname, strand) pair.\ndisjoin: Finds disjoint intervals across all locations for each distinct (seqname, strand) pair.\n\n\ngr = GenomicRanges(\n    seqnames=[\n        \"chr1\",\n        \"chr2\",\n        \"chr3\",\n        \"chr2\",\n        \"chr3\",\n    ],\n    ranges=IRanges([x for x in range(101, 106)], [11, 21, 25, 30, 5]),\n    strand=[\"*\", \"-\", \"*\", \"+\", \"-\"],\n    mcols=BiocFrame(\n        {\n            \"score\": range(0, 5),\n            \"GC\": [random() for _ in range(5)],\n        }\n    ),\n)\n\n# range\nrange_gr = gr.range()\n\n# reduce\nreduced_gr = gr.reduce(min_gap_width=3, with_reverse_map=True)\n\n# gaps\ngapped_gr = gr.gaps(start=103)  # OR\ngapped_gr = gr.gaps(end={\"chr1\": 120, \"chr2\": 120, \"chr3\": 120})\n\n# disjoin\ndisjoin_gr = gr.disjoin()\n\nprint(\"GenomicRanges with the disjoint ranges:\")\nprint(disjoin_gr)\n\nGenomicRanges with the disjoint ranges:\nGenomicRanges with 5 ranges and 5 metadata columns\n    seqnames    ranges          strand\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;\n[0]     chr1 101 - 112               *\n[1]     chr2 104 - 134               +\n[2]     chr2 102 - 123               -\n[3]     chr3 105 - 110               -\n[4]     chr3 103 - 128               *\n------\nseqinfo(3 sequences): chr1 chr2 chr3",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>`GenomicRanges`: Genomic analysis</span>"
    ]
  },
  {
    "objectID": "chapters/representations/genomicranges.html#set-operations",
    "href": "chapters/representations/genomicranges.html#set-operations",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Set operations",
    "text": "Set operations\n\nunion: Compute the union of intervals across objects.\nintersect: Compute the intersection or finds overlapping intervals.\nsetdiff: Compute set difference.\n\n\n\nShow the code\ng_src = GenomicRanges(\n    seqnames = [\"chr1\", \"chr2\", \"chr1\", \"chr3\", \"chr2\"],\n    ranges = IRanges(start =[101, 102, 103, 104, 109], width=[112, 103, 128, 134, 111]),\n    strand = [\"*\", \"-\", \"*\", \"+\", \"-\"]\n)\n\ng_tgt = GenomicRanges(\n    seqnames = [\"chr1\",\"chr2\",\"chr2\",\"chr2\",\"chr1\",\"chr1\",\"chr3\",\"chr3\",\"chr3\",\"chr3\"],\n    ranges = IRanges(start =range(101, 111), width=range(121, 131)),\n    strand = [\"*\", \"-\", \"-\", \"*\", \"*\", \"+\", \"+\", \"+\", \"-\", \"-\"]\n)\n\n\n\n# intersection\nint_gr = g_src.intersect(g_tgt)\n\n# set diff\ndiff_gr = g_src.setdiff(g_tgt)\n\n# union\nunion_gr = g_src.union(g_tgt)\n\nprint(\"GenomicRanges after the union operation:\")\nprint(union_gr)\n\nGenomicRanges after the union operation:\nGenomicRanges with 6 ranges and 6 metadata columns\n    seqnames    ranges          strand\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;\n[0]     chr1 106 - 232               +\n[1]     chr1 101 - 231               *\n[2]     chr2 102 - 226               -\n[3]     chr2 104 - 228               *\n[4]     chr3 104 - 238               +\n[5]     chr3 109 - 240               -\n------\nseqinfo(3 sequences): chr1 chr2 chr3",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>`GenomicRanges`: Genomic analysis</span>"
    ]
  },
  {
    "objectID": "chapters/representations/genomicranges.html#compute-over-bins",
    "href": "chapters/representations/genomicranges.html#compute-over-bins",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Compute over bins",
    "text": "Compute over bins\n\nSummary stats for column\nUse Pandas to compute summary statistics for a column:\n\npd.Series(gr.mcols.get_column(\"score\")).describe()\n\ncount    5.000000\nmean     2.000000\nstd      1.581139\nmin      0.000000\n25%      1.000000\n50%      2.000000\n75%      3.000000\nmax      4.000000\ndtype: float64\n\n\nWith a bit more magic, render a histogram using matplotlib:\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n_ = plt.hist(gr.mcols.get_column(\"score\"), bins=\"auto\")\nplt.title(\"'score' histogram with 'auto' bins\")\nplt.show()\n\n\n\n\n\n\n\n\nNot the prettiest plot but it works.\n\n\nBinned average\nCompute binned average for a set of query bins:\n\nfrom iranges import IRanges\nbins_gr = GenomicRanges(seqnames=[\"chr1\"], ranges=IRanges([101], [109]))\n\nsubject = GenomicRanges(\n    seqnames= [\"chr1\",\"chr2\",\"chr2\",\"chr2\",\"chr1\",\"chr1\",\"chr3\",\"chr3\",\"chr3\",\"chr3\"],\n    ranges=IRanges(range(101, 111), range(121, 131)),\n    strand= [\"*\", \"-\", \"-\", \"*\", \"*\", \"+\", \"+\", \"+\", \"-\", \"-\"],\n    mcols=BiocFrame({\n        \"score\": range(0, 10),\n    })\n)\n\n# Compute binned average\nbinned_avg_gr = subject.binned_average(bins=bins_gr, scorename=\"score\", outname=\"binned_score\")\nprint(binned_avg_gr)\n\nGenomicRanges with 1 range and 1 metadata column\n    seqnames    ranges          strand   binned_score\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;         &lt;list&gt;\n[0]     chr1 101 - 210               * |            2\n------\nseqinfo(1 sequences): chr1\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/genomicranges/SeqInfo.py:348: UserWarning: 'seqnames' is deprecated, use 'get_seqnames' instead\n  warn(\"'seqnames' is deprecated, use 'get_seqnames' instead\", UserWarning)\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/genomicranges/SeqInfo.py:348: UserWarning: 'seqnames' is deprecated, use 'get_seqnames' instead\n  warn(\"'seqnames' is deprecated, use 'get_seqnames' instead\", UserWarning)\n\n\n\n\n\n\n\n\nTip\n\n\n\nNow you might wonder how can I generate these bins?",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>`GenomicRanges`: Genomic analysis</span>"
    ]
  },
  {
    "objectID": "chapters/representations/genomicranges.html#generate-tiles-or-bins",
    "href": "chapters/representations/genomicranges.html#generate-tiles-or-bins",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Generate tiles or bins",
    "text": "Generate tiles or bins\n\ntile: Splits each genomic region by n (number of regions) or by width (maximum width of each tile).\nsliding_windows: Generates sliding windows within each range, by width and step.\n\n\ngr = GenomicRanges(\n    seqnames=[\n        \"chr1\",\n        \"chr2\",\n        \"chr3\",\n        \"chr2\",\n        \"chr3\",\n    ],\n    ranges=IRanges([x for x in range(101, 106)], [11, 21, 25, 30, 5]),\n    strand=[\"*\", \"-\", \"*\", \"+\", \"-\"],\n    mcols=BiocFrame(\n        {\n            \"score\": range(0, 5),\n            \"GC\": [random() for _ in range(5)],\n        }\n    ),\n)\n\n# tiles\ntiles = gr.tile(n=2)\n\n# slidingwindows\ntiles = gr.sliding_windows(width=10)\nprint(tiles)\n\nGenomicRanges with 52 ranges and 52 metadata columns\n     seqnames    ranges          strand\n        &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;\n [0]     chr1 101 - 110               *\n [1]     chr1 102 - 111               *\n [2]     chr2 102 - 111               -\n          ...       ...             ...\n[49]     chr2 123 - 132               +\n[50]     chr2 124 - 133               +\n[51]     chr3 105 - 109               -\n------\nseqinfo(3 sequences): chr1 chr2 chr3\n\n\n\nGenerate tiles from genome\ntile_genome returns a set of genomic regions that form a partitioning of the specified genome.\n\nseqlengths = {\"chr1\": 100, \"chr2\": 75, \"chr3\": 200}\n\ntiles = GenomicRanges.tile_genome(seqlengths=seqlengths, n=10)\nprint(tiles)\n\nGenomicRanges with 30 ranges and 30 metadata columns\n     seqnames    ranges          strand\n        &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;\n [0]     chr1    1 - 10               *\n [1]     chr1   11 - 20               *\n [2]     chr1   21 - 30               *\n          ...       ...             ...\n[27]     chr3 141 - 160               *\n[28]     chr3 161 - 180               *\n[29]     chr3 181 - 200               *\n------\nseqinfo(3 sequences): chr1 chr2 chr3",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>`GenomicRanges`: Genomic analysis</span>"
    ]
  },
  {
    "objectID": "chapters/representations/genomicranges.html#coverage",
    "href": "chapters/representations/genomicranges.html#coverage",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Coverage",
    "text": "Coverage\nComputes number of ranges that overlap for each position.\n\nimport rich \n\nres_vector = gr.coverage()\nrich.print(res_vector)\n\n{\n    'chr1': array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 1.,\n       1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]),\n    'chr2': array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1.,\n       1., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2.,\n       2., 2., 2., 2., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]),\n    'chr3': array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       1., 1., 2., 2., 2., 2., 2., 2., 1., 1., 1., 1., 1., 1., 1., 1., 1.,\n       1., 1., 1., 1., 1., 1., 1., 1., 1.])\n}\n\n\n\nLets see what the coverage looks like, now with seaborn:\n\nimport seaborn as sns\nvector = res_vector[\"chr1\"]\nsns.lineplot(data=pd.DataFrame({\n    \"position\": [i for i in range(len(vector))], \n    \"coverage\":vector\n}), x =\"position\", y=\"coverage\")\n\n\n\n\n\n\n\n\nI guess that looks ok. :) but someone can help make this visualization better. (something that ports plotRanges from R)",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>`GenomicRanges`: Genomic analysis</span>"
    ]
  },
  {
    "objectID": "chapters/representations/genomicranges.html#overlap-based-methods",
    "href": "chapters/representations/genomicranges.html#overlap-based-methods",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Overlap based methods",
    "text": "Overlap based methods\n\nfind_overlaps: Find overlaps between two GenomicRanges objects.\ncount_overlaps: Count overlaps between two GenomicRanges objects.\nsubset_by_overlaps: Subset a GenomicRanges object if it overlaps with the ranges in the query.\n\n\nsubject = GenomicRanges(\n    seqnames= [\"chr1\",\"chr2\",\"chr2\",\"chr2\",\"chr1\",\"chr1\",\"chr3\",\"chr3\",\"chr3\",\"chr3\"],\n    ranges=IRanges(range(101, 111), range(121, 131)),\n    strand= [\"*\", \"-\", \"-\", \"*\", \"*\", \"+\", \"+\", \"+\", \"-\", \"-\"],\n    mcols=BiocFrame({\n        \"score\": range(0, 10),\n    })\n)\n\ndf_query = pd.DataFrame(\n    {\"seqnames\": [\"chr2\",], \"starts\": [4], \"ends\": [6], \"strand\": [\"+\"]}\n)\n\nquery = GenomicRanges.from_pandas(df_query)\n\n# find Overlaps\nres = subject.find_overlaps(query, query_type=\"within\")\n\n# count Overlaps\nres = subject.count_overlaps(query)\n\n# subset by Overlaps\nres = subject.subset_by_overlaps(query)\n\nprint(res)\n\nGenomicRanges with 0 ranges and 0 metadata columns\nseqinfo(3 sequences): chr1 chr2 chr3\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/genomicranges/SeqInfo.py:348: UserWarning: 'seqnames' is deprecated, use 'get_seqnames' instead\n  warn(\"'seqnames' is deprecated, use 'get_seqnames' instead\", UserWarning)\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/genomicranges/SeqInfo.py:348: UserWarning: 'seqnames' is deprecated, use 'get_seqnames' instead\n  warn(\"'seqnames' is deprecated, use 'get_seqnames' instead\", UserWarning)",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>`GenomicRanges`: Genomic analysis</span>"
    ]
  },
  {
    "objectID": "chapters/representations/genomicranges.html#search-operations",
    "href": "chapters/representations/genomicranges.html#search-operations",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Search operations",
    "text": "Search operations\n\nnearest: Performs nearest neighbor search along any direction (both upstream and downstream).\nfollow: Performs nearest neighbor search only along downstream.\nprecede: Performs nearest neighbor search only along upstream.\n\n\nfind_regions = GenomicRanges(\n    seqnames= [\"chr1\", \"chr2\", \"chr3\"],\n    ranges=IRanges([200, 105, 1190],[203, 106, 1200]),\n)\n\nquery_hits = gr.nearest(find_regions)\n\nquery_hits = gr.precede(find_regions)\n\nquery_hits = gr.follow(find_regions)\n\nprint(query_hits)\n\n[[0], [], [2]]\n\n\n\n\n\n\n\n\nNote\n\n\n\nSimilar to IRanges operations, these methods typically return a list of indices from subject for each interval in query.",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>`GenomicRanges`: Genomic analysis</span>"
    ]
  },
  {
    "objectID": "chapters/representations/genomicranges.html#comparison-rank-and-order-operations",
    "href": "chapters/representations/genomicranges.html#comparison-rank-and-order-operations",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Comparison, rank and order operations",
    "text": "Comparison, rank and order operations\n\nmatch: Element-wise comparison to find exact match intervals.\norder: Get the order of indices for sorting.\nsort: Sort the GenomicRanges object.\nrank: For each interval identifies its position is a sorted order.\n\n\n# match\nquery_hits = gr.match(gr[2:5])\nprint(\"matches: \", query_hits)\n\n# order\norder = gr.order()\nprint(\"order:\", order)\n\n# sort\nsorted_gr = gr.sort()\nprint(\"sorted:\", sorted_gr)\n\n# rank\nrank = gr.rank()\nprint(\"rank:\", rank)\n\nmatches:  [[2], [3], [4]]\norder: [0 1 3 4 2]\nsorted: GenomicRanges with 5 ranges and 5 metadata columns\n    seqnames    ranges          strand    score                 GC\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;list&gt;             &lt;list&gt;\n[0]     chr1 101 - 112               * |      0 0.9432559443033663\n[1]     chr2 102 - 123               - |      1 0.3221004517097079\n[2]     chr2 104 - 134               + |      3 0.9839929189446192\n[3]     chr3 105 - 110               - |      4 0.9348559242145169\n[4]     chr3 103 - 128               * |      2 0.7607799733918689\n------\nseqinfo(3 sequences): chr1 chr2 chr3\nrank: [0, 1, 4, 2, 3]",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>`GenomicRanges`: Genomic analysis</span>"
    ]
  },
  {
    "objectID": "chapters/representations/genomicranges.html#combine-genomicranges-objects-by-rows",
    "href": "chapters/representations/genomicranges.html#combine-genomicranges-objects-by-rows",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Combine GenomicRanges objects by rows",
    "text": "Combine GenomicRanges objects by rows\nUse the combine generic from biocutils to concatenate multiple GenomicRanges objects.\n\nfrom biocutils.combine import combine\na = GenomicRanges(\n    seqnames=[\"chr1\", \"chr2\", \"chr1\", \"chr3\"],\n    ranges=IRanges([1, 3, 2, 4], [10, 30, 50, 60]),\n    strand=[\"-\", \"+\", \"*\", \"+\"],\n    mcols=BiocFrame({\"score\": [1, 2, 3, 4]}),\n)\n\nb = GenomicRanges(\n    seqnames=[\"chr2\", \"chr4\", \"chr5\"],\n    ranges=IRanges([3, 6, 4], [30, 50, 60]),\n    strand=[\"-\", \"+\", \"*\"],\n    mcols=BiocFrame({\"score\": [2, 3, 4]}),\n)\n\ncombined = combine(a,b)\nprint(combined)\n\nGenomicRanges with 7 ranges and 7 metadata columns\n    seqnames    ranges          strand    score\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;list&gt;\n[0]     chr1    1 - 11               - |      1\n[1]     chr2    3 - 33               + |      2\n[2]     chr1    2 - 52               * |      3\n[3]     chr3    4 - 64               + |      4\n[4]     chr1    3 - 33               - |      2\n[5]     chr2    6 - 56               + |      3\n[6]     chr3    4 - 64               * |      4\n------\nseqinfo(5 sequences): chr1 chr2 chr3 chr4 chr5",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>`GenomicRanges`: Genomic analysis</span>"
    ]
  },
  {
    "objectID": "chapters/representations/genomicranges.html#misc-operations",
    "href": "chapters/representations/genomicranges.html#misc-operations",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Misc operations",
    "text": "Misc operations\n\ninvert_strand: flip the strand for each interval\nsample: randomly choose k intervals\n\n\n# invert strand\ninv_gr = gr.invert_strand()\n\n# sample\nsamp_gr = gr.sample(k=4)",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>`GenomicRanges`: Genomic analysis</span>"
    ]
  },
  {
    "objectID": "chapters/representations/genomicranges.html#genomicrangeslist-class",
    "href": "chapters/representations/genomicranges.html#genomicrangeslist-class",
    "title": "GenomicRanges: Genomic analysis",
    "section": "GenomicRangesList class",
    "text": "GenomicRangesList class\nJust as it sounds, a GenomicRangesList is a named-list like object.\nIf you are wondering why you need this class, a GenomicRanges object enables the specification of multiple genomic elements, usually where genes start and end. Genes, in turn, consist of various subregions, such as exons. The GenomicRangesList allows us to represent this nested structure.\nAs of now, this class has limited functionality, serving as a read-only class with basic accessors.\n\nfrom genomicranges import GenomicRangesList\na = GenomicRanges(\n    seqnames=[\"chr1\", \"chr2\", \"chr1\", \"chr3\"],\n    ranges=IRanges([1, 3, 2, 4], [10, 30, 50, 60]),\n    strand=[\"-\", \"+\", \"*\", \"+\"],\n    mcols=BiocFrame({\"score\": [1, 2, 3, 4]}),\n)\n\nb = GenomicRanges(\n    seqnames=[\"chr2\", \"chr4\", \"chr5\"],\n    ranges=IRanges([3, 6, 4], [30, 50, 60]),\n    strand=[\"-\", \"+\", \"*\"],\n    mcols=BiocFrame({\"score\": [2, 3, 4]}),\n)\n\ngrl = GenomicRangesList(ranges=[a,b], names=[\"gene1\", \"gene2\"])\nprint(grl)\n\nGenomicRangesList with 2 ranges and 2 metadata columns\n \nName: gene1 \nGenomicRanges with 4 ranges and 4 metadata columns\n    seqnames    ranges          strand    score\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;list&gt;\n[0]     chr1    1 - 11               - |      1\n[1]     chr2    3 - 33               + |      2\n[2]     chr1    2 - 52               * |      3\n[3]     chr3    4 - 64               + |      4\n------\nseqinfo(3 sequences): chr1 chr2 chr3\n \nName: gene2 \nGenomicRanges with 3 ranges and 3 metadata columns\n    seqnames    ranges          strand    score\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;list&gt;\n[0]     chr2    3 - 33               - |      2\n[1]     chr4    6 - 56               + |      3\n[2]     chr5    4 - 64               * |      4\n------\nseqinfo(3 sequences): chr2 chr4 chr5\n \n\n\n\n\nProperties\n\ngrl.start\ngrl.width\n\n{'gene1': array([10, 30, 50, 60], dtype=int32),\n 'gene2': array([30, 50, 60], dtype=int32)}\n\n\n\n\nCombine GenomicRangeslist object\nSimilar to the combine function from GenomicRanges,\n\ngrla = GenomicRangesList(ranges=[a], names=[\"a\"])\ngrlb = GenomicRangesList(ranges=[b, a], names=[\"b\", \"c\"])\n\n# or use the combine generic\nfrom biocutils.combine import combine\ncgrl = combine(grla, grlb)\n\nThe functionality in GenomicRangesLlist is limited to read-only and a few methods. Updates are expected to be made as more features become available.",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>`GenomicRanges`: Genomic analysis</span>"
    ]
  },
  {
    "objectID": "chapters/representations/genomicranges.html#empty-ranges",
    "href": "chapters/representations/genomicranges.html#empty-ranges",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Empty ranges",
    "text": "Empty ranges\nBoth of these classes can also contain no range information, and they tend to be useful when incorporates into larger data structures but do not contain any data themselves.\nTo create an empty GenomicRanges object:\n\nempty_gr = GenomicRanges.empty()\n\nprint(empty_gr)\n\nGenomicRanges with 0 ranges and 0 metadata columns\n\n\n\nSimilarly, an empty GenomicRangesList can be created:\n\nempty_grl = GenomicRangesList.empty(n=100)\n\nprint(empty_grl)\n\nGenomicRangesList with 100 ranges and 100 metadata columns\n--- empty genomic ranges list ---",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>`GenomicRanges`: Genomic analysis</span>"
    ]
  },
  {
    "objectID": "chapters/representations/genomicranges.html#futher-reading",
    "href": "chapters/representations/genomicranges.html#futher-reading",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Futher reading",
    "text": "Futher reading\n\nCheck out the reference documentation for more details.\nVisit Bioconductor’s GenomicRanges package.",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>`GenomicRanges`: Genomic analysis</span>"
    ]
  },
  {
    "objectID": "chapters/representations/delayedarrays.html",
    "href": "chapters/representations/delayedarrays.html",
    "title": "Delayed Arrays",
    "section": "",
    "text": "Installation\nThis package is published to PyPI and can be installed via the usual methods:",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Delayed Arrays</span>"
    ]
  },
  {
    "objectID": "chapters/representations/delayedarrays.html#installation",
    "href": "chapters/representations/delayedarrays.html#installation",
    "title": "Delayed Arrays",
    "section": "",
    "text": "pip install delayedarray",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Delayed Arrays</span>"
    ]
  },
  {
    "objectID": "chapters/representations/delayedarrays.html#quick-start",
    "href": "chapters/representations/delayedarrays.html#quick-start",
    "title": "Delayed Arrays",
    "section": "Quick start",
    "text": "Quick start\nWe can create a DelayedArray from any object that respects the seed contract, i.e., has the shape/dtype properties and supports NumPy slicing. For example, a typical NumPy array qualifies:\n\nimport numpy\nx = numpy.random.rand(100, 20)\nx\n\narray([[0.92320562, 0.3097894 , 0.53189351, ..., 0.27510105, 0.57956867,\n        0.94342275],\n       [0.71204588, 0.25514085, 0.10361842, ..., 0.73304687, 0.26942916,\n        0.16600196],\n       [0.59617088, 0.05113678, 0.70386359, ..., 0.52784139, 0.00552956,\n        0.50734403],\n       ...,\n       [0.84813968, 0.54212125, 0.76238212, ..., 0.94844677, 0.96750779,\n        0.76170653],\n       [0.35833657, 0.44683699, 0.92846285, ..., 0.17060735, 0.54414622,\n        0.19603526],\n       [0.88605157, 0.6316946 , 0.97400379, ..., 0.8470242 , 0.50531761,\n        0.56250471]])\n\n\nWe can wrap this in a DelayedArray class:\n\nimport delayedarray\nd = delayedarray.wrap(x)\nd\n\n&lt;100 x 20&gt; DelayedArray object of type 'float64'\n[[0.92320562, 0.3097894 , 0.53189351, ..., 0.27510105, 0.57956867,\n  0.94342275],\n [0.71204588, 0.25514085, 0.10361842, ..., 0.73304687, 0.26942916,\n  0.16600196],\n [0.59617088, 0.05113678, 0.70386359, ..., 0.52784139, 0.00552956,\n  0.50734403],\n ...,\n [0.84813968, 0.54212125, 0.76238212, ..., 0.94844677, 0.96750779,\n  0.76170653],\n [0.35833657, 0.44683699, 0.92846285, ..., 0.17060735, 0.54414622,\n  0.19603526],\n [0.88605157, 0.6316946 , 0.97400379, ..., 0.8470242 , 0.50531761,\n  0.56250471]]\n\n\nAnd then we can use it in a variety of operations. For example, in genomics, a typical quality control task is to slice the matrix to remove uninteresting features (rows) or samples (columns):\n\nfiltered = d[1:100:2,1:8]\nfiltered.shape\n\n(50, 7)\n\n\nWe then divide by the total sum of each column to compute normalized values between samples.\n\ntotal = filtered.sum(axis=0)\nnormalized = filtered / total\nnormalized.dtype\n\ndtype('float64')\n\n\nAnd finally we compute a log-transformation to get some log-normalized values for visualization.\n\ntransformed = numpy.log1p(normalized)\ntransformed[1:5,:]\n\n&lt;4 x 7&gt; DelayedArray object of type 'float64'\n[[0.03576153, 0.00916447, 0.03650709, ..., 0.02220312, 0.00699699,\n  0.03160379],\n [0.01395495, 0.01982355, 0.01470671, ..., 0.00770331, 0.0130848 ,\n  0.03325358],\n [0.0341034 , 0.02614178, 0.00854539, ..., 0.03264423, 0.03322269,\n  0.02731285],\n [0.02341959, 0.03130366, 0.0182745 , ..., 0.01645992, 0.00924269,\n  0.01340919]]\n\n\nEach operation just returns a DelayedArray with an increasing stack of delayed operations, without evaluating anything or making any copies. Check out the documentation for more information.",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Delayed Arrays</span>"
    ]
  },
  {
    "objectID": "chapters/representations/delayedarrays.html#extracting-data",
    "href": "chapters/representations/delayedarrays.html#extracting-data",
    "title": "Delayed Arrays",
    "section": "Extracting data",
    "text": "Extracting data\nA DelayedArray is typically used by iteratively extracting blocks into memory for further calculations. This “block processing” strategy improves memory efficiency by only realizing the delayed operations for a subset of the data. For example, to iterate over the rows with 100 MB blocks:\n\ngrid = delayedarray.chunk_grid(d)\ndims = (*range(len(d.shape)),)\nfor block in grid.iterate(dimensions=dims):\n    subsets = (*(range(s, e) for s, e in block),)\n    current = delayedarray.extract_dense_array(d, subsets)\n\nEach call to extract_dense_array() yields a NumPy array containing the the specified rows and columns. If the DelayedArray might contain masked values, a NumPy MaskedArray is returned instead; this can be determined by checking whether is_masked(d) returns True.\nThe above iteration can be simplified with the apply_over_dimension() function, which handles the block coordinate calculations for us. We could also use the apply_over_blocks() function to iterate over arbitrary block shapes, which may be more efficient if the best dimension for iteration is not known.\n# To iterate over a single dimension:\ndelayedarray.apply_over_dimension(\n    d,\n    dimension=0,\n    fun=some_user_supplied_function,\n    block_size=block_size,\n)\n\n# To iterate over arbitrary blocks.\ndelayedarray.apply_over_blocks(\n    d,\n    fun=another_user_supplied_function,\n    block_shape=(20, 100),\n)",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Delayed Arrays</span>"
    ]
  },
  {
    "objectID": "chapters/representations/delayedarrays.html#handling-sparse-data",
    "href": "chapters/representations/delayedarrays.html#handling-sparse-data",
    "title": "Delayed Arrays",
    "section": "Handling sparse data",
    "text": "Handling sparse data\nIf the DelayedArray contains sparse data, is_sparse(d) will return True. This allows callers to instead use the extract_sparse_array() function for block processing:\n\nif delayedarray.is_sparse(d):\n    current = delayedarray.extract_sparse_array(d, (*block_coords,))\n\nThis returns a SparseNdarray consisting of a tree of sparse vectors for the specified block. Users can retrieve the sparse vectors by inspecting the contents property of the SparseNdarray:\n\nIn the one-dimensional case, this is a tuple of two 1-dimensional NumPy arrays storing data about the non-zero elements. The first array contains sorted indices while the secon array contains the associated values. If is_masked(d) returns True, the values will be represented as NumPy MaskedArray objects.\nFor the two-dimensional case, this is a list of such tuples, with one tuple per column. This is roughly analogous to a compressed sparse column matrix. An entry of the list may also be None, indicating that no non-zero elements are present in that column.\nFor higher-dimensionals, the tree is a nested list of lists of tuples. Each nesting level corresponds to a dimension; the outermost level contains elements of the last dimension, the next nesting level contains elements of the second-last dimension, and so on, with the indices in the tuple referring to the first dimension. Any list element may be None indicating that the corresponding element of the dimension has no non-zero elements.\nIn all cases, it is possible for contents to be None, indicating that there are no non-zero elements in the entire array.\n\nThe apply_over_* functions can also be instructed to iteratively extract blocks as SparseNdarray objects. This only occurs if the input array is sparse (as specified by is_sparse).\n# To iterate over a single dimension:\ndelayedarray.apply_over_dimension(\n    d,\n    dimension=0,\n    fun=some_user_supplied_function,\n    block_size=block_size,\n    allow_sparse=True,\n)\n\nOther coercions\nA DelayedArray can be converted to a (possibly masked) NumPy array with the to_dense_array() function. Similarly, sparse DelayedArrays can be converted to SparseNdarrays with the to_sparse_array() function.\n\ndelayedarray.to_dense_array(d)\nif delayedarray.is_sparse(d):\n    delayedarray.to_sparse_array(d)\n\nUsers can easily convert a 2-dimensional SparseNdarray to some of the common SciPy sparse matrix classes downstream calculations.\ndelayedarray.to_scipy_sparse_matrix(current, \"csc\")\nMore simply, users can just call numpy.array() to realize the delayed operations into a standard NumPy array for consumption. Note that this discards any masking information so should not be called if is_masked() returns True.\n\nimport random\nsimple = numpy.array([random.random() for _ in range(50)])\ntype(simple)\n\nnumpy.ndarray\n\n\nUsers can also call delayedarray.create_dask_array(), to obtain a dask array that contains the delayed operations:\n\n# Note: requires installation as 'delayedarray[dask]'.\ndasky = delayedarray.create_dask_array(simple)\ntype(dasky)\n\ndask.array.core.Array",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Delayed Arrays</span>"
    ]
  },
  {
    "objectID": "chapters/representations/delayedarrays.html#interoperability-with-other-packages",
    "href": "chapters/representations/delayedarrays.html#interoperability-with-other-packages",
    "title": "Delayed Arrays",
    "section": "Interoperability with other packages",
    "text": "Interoperability with other packages\nThe general idea is that DelayedArrays should be a drop-in replacement for NumPy arrays, at least for BiocPy applications. So, for example, we can stuff the DelayedArray inside a SummarizedExperiment:\n\nimport summarizedexperiment as SE\nse = SE.SummarizedExperiment({ \"counts\": filtered, \"lognorm\": transformed })\nprint(se)\n\nclass: SummarizedExperiment\ndimensions: (50, 7)\nassays(2): ['counts', 'lognorm']\nrow_data columns(0): []\nrow_names(0):  \ncolumn_data columns(0): []\ncolumn_names(0):  \nmetadata(0): \n\n\n\nOne of the main goals of the DelayedArray package is to make it easier for Bioconductor developers to inspect the delayed operations. (See the developer notes for some comments on dask.) For example, we can pull out the “seed” object underlying our DelayedArray instance:\n\nd.seed\n\narray([[0.92320562, 0.3097894 , 0.53189351, ..., 0.27510105, 0.57956867,\n        0.94342275],\n       [0.71204588, 0.25514085, 0.10361842, ..., 0.73304687, 0.26942916,\n        0.16600196],\n       [0.59617088, 0.05113678, 0.70386359, ..., 0.52784139, 0.00552956,\n        0.50734403],\n       ...,\n       [0.84813968, 0.54212125, 0.76238212, ..., 0.94844677, 0.96750779,\n        0.76170653],\n       [0.35833657, 0.44683699, 0.92846285, ..., 0.17060735, 0.54414622,\n        0.19603526],\n       [0.88605157, 0.6316946 , 0.97400379, ..., 0.8470242 , 0.50531761,\n        0.56250471]])\n\n\nEach layer has its own specific attributes that define the operation, e.g.,\nd.seed.subset\nRecursively drilling through the object will eventually reach the underlying array(s):\nd.seed.seed.seed.seed.seed\nAll attributes required to reconstruct a delayed operation are public and considered part of the stable DelayedArray interface.",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Delayed Arrays</span>"
    ]
  },
  {
    "objectID": "chapters/representations/delayedarrays.html#developing-seeds",
    "href": "chapters/representations/delayedarrays.html#developing-seeds",
    "title": "Delayed Arrays",
    "section": "Developing seeds",
    "text": "Developing seeds\nAny array-like object can be used as a “seed” in a DelayedArray provided it has the following:\n\ndtype and shape properties, like those in NumPy arrays.\na method for the extract_dense_array() generic.\n\nIf the object may contain sparse data, it should also implement:\n\na method for the is_sparse() generic.\na method for the extract_sparse_generic() generic.\n\nIt may also be desirable to implement:\n\na method for the chunk_shape() generic.\na method for the create_dask_array() generic.\na method for the wrap() generic.\n\nDevelopers are referred to the documentation for each generic for more details.",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Delayed Arrays</span>"
    ]
  },
  {
    "objectID": "chapters/representations/filebackedarrays.html",
    "href": "chapters/representations/filebackedarrays.html",
    "title": "File-backed Arrays",
    "section": "",
    "text": "Installation\nThis package is published to PyPI and can be installed via the usual methods:",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>File-backed Arrays</span>"
    ]
  },
  {
    "objectID": "chapters/representations/filebackedarrays.html#installation",
    "href": "chapters/representations/filebackedarrays.html#installation",
    "title": "File-backed Arrays",
    "section": "",
    "text": "pip install hdf5array",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>File-backed Arrays</span>"
    ]
  },
  {
    "objectID": "chapters/representations/filebackedarrays.html#quick-start",
    "href": "chapters/representations/filebackedarrays.html#quick-start",
    "title": "File-backed Arrays",
    "section": "Quick start",
    "text": "Quick start\nLet’s mock up a dense array:\n\nimport numpy\ndata = numpy.random.rand(40, 50)\n\nimport h5py\nwith h5py.File(\"whee.h5\", \"w\") as handle:\n    handle.create_dataset(\"yay\", data=data)\n\nWe can now represent it as a Hdf5DenseArray:\n\nimport hdf5array\narr = hdf5array.Hdf5DenseArray(\"whee.h5\", \"yay\", native_order=True)\narr\n\n&lt;40 x 50&gt; Hdf5DenseArray object of type 'float64'\n[[0.11450998, 0.34998218, 0.92238322, ..., 0.28387924, 0.53697661,\n  0.52951597],\n [0.55704322, 0.52184008, 0.16966835, ..., 0.85197533, 0.22327118,\n  0.85623023],\n [0.75415126, 0.77979471, 0.21389933, ..., 0.36389382, 0.5645559 ,\n  0.56180309],\n ...,\n [0.86869871, 0.59972547, 0.72546562, ..., 0.22373497, 0.38015961,\n  0.55677532],\n [0.31723712, 0.74240447, 0.84670129, ..., 0.0130557 , 0.42904626,\n  0.38670994],\n [0.77736345, 0.33431891, 0.67891134, ..., 0.2857026 , 0.82806514,\n  0.1363053 ]]\n\n\nThis is just a subclass of a DelayedArray and can be used anywhere in the BiocPy framework. Parts of the NumPy API are also supported - for example, we could apply a variety of delayed operations:\n\nscaling = numpy.random.rand(100)\ntransformed = numpy.log1p(arr / scaling)\ntransformed\n\n&lt;40 x 50&gt; DelayedArray object of type 'float64'\n[[0.41253413, 0.49737318, 1.04470925, ..., 0.29691082, 0.52730643,\n  1.84302303],\n [1.24819706, 0.67336539, 0.29187305, ..., 0.71172209, 0.25364254,\n  2.26127935],\n [1.47316706, 0.89026613, 0.35577737, ..., 0.36681673, 0.54813582,\n  1.89306969],\n ...,\n [1.58388203, 0.74394947, 0.89576358, ..., 0.24094756, 0.39983787,\n  1.88543917],\n [0.88156439, 0.86159542, 0.99005709, ..., 0.01577358, 0.44134561,\n  1.58556077],\n [1.49661468, 0.47967945, 0.85705331, ..., 0.29855946, 0.72791939,\n  0.86217875]]\n\n\nCheck out the documentation for more details.",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>File-backed Arrays</span>"
    ]
  },
  {
    "objectID": "chapters/representations/filebackedarrays.html#handling-sparse-matrices",
    "href": "chapters/representations/filebackedarrays.html#handling-sparse-matrices",
    "title": "File-backed Arrays",
    "section": "Handling sparse matrices",
    "text": "Handling sparse matrices\nWe support a variety of compressed sparse formats where the non-zero elements are held inside three separate datasets - usually data, indices and indptr, based on the 10X Genomics sparse HDF5 format. To demonstrate, let’s mock up some sparse data using scipy:\n\nimport scipy.sparse\nmock = scipy.sparse.random(1000, 200, 0.1).tocsc()\n\nwith h5py.File(\"sparse_whee.h5\", \"w\") as handle:\n    handle.create_dataset(\"sparse_blah/data\", data=mock.data, compression=\"gzip\")\n    handle.create_dataset(\"sparse_blah/indices\", data=mock.indices, compression=\"gzip\")\n    handle.create_dataset(\"sparse_blah/indptr\", data=mock.indptr, compression=\"gzip\")\n\nWe can then create a sparse HDF5-backed matrix. Note that there is some variation in this HDF5 compressed sparse format, notably where the dimensions are stored and whether it is column/row-major. The constructor will not do any auto-detection so we need to provide this information explicitly:\n\nimport hdf5array\narr = hdf5array.Hdf5CompressedSparseMatrix(\n    \"sparse_whee.h5\", \n    \"sparse_blah\", \n    shape=(100, 200), \n    by_column=True\n)\narr\n\n&lt;100 x 200&gt; sparse Hdf5CompressedSparseMatrix object of type 'float64'\n[[0.        , 0.        , 0.        , ..., 0.        , 0.        ,\n  0.        ],\n [0.        , 0.        , 0.        , ..., 0.        , 0.94363819,\n  0.        ],\n [0.        , 0.        , 0.        , ..., 0.        , 0.        ,\n  0.        ],\n ...,\n [0.        , 0.        , 0.        , ..., 0.        , 0.        ,\n  0.5989228 ],\n [0.        , 0.        , 0.29702753, ..., 0.        , 0.        ,\n  0.        ],\n [0.30687293, 0.        , 0.        , ..., 0.        , 0.        ,\n  0.        ]]\n\n\nJust like delayedarrays, you can use file-backed matrices to represent experimental data in summarized experiment and its derivates, reducing the in-memory footprint to load large datasets.",
    "crumbs": [
      "The basics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>File-backed Arrays</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/index.html",
    "href": "chapters/experiments/index.html",
    "title": "Represent experimental data",
    "section": "",
    "text": "BiocPy provides (currently) three classes to represented experimental data. This includes\n\nSummarizedExperiment (GitHub, Docs, BioC): Container class to represent genomic experiments, following Bioconductor’s SummarizedExperiment.\nSingleCellExperiment (GitHub, Docs, BioC): Container class to represent single-cell experiments; follows Bioconductor’s SingleCellExperiment.\nMultiAssayExperiment (GitHub, Docs, BioC): Container class to represent multiple experiments and assays performed over a set of samples. follows Bioconductor’s MAE R/Bioc Package.",
    "crumbs": [
      "Represent experimental data"
    ]
  },
  {
    "objectID": "chapters/experiments/summarized_expt.html",
    "href": "chapters/experiments/summarized_expt.html",
    "title": "Summarized experiment",
    "section": "",
    "text": "Installation\nTo get started, install the package from PyPI",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Summarized experiment</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/summarized_expt.html#installation",
    "href": "chapters/experiments/summarized_expt.html#installation",
    "title": "Summarized experiment",
    "section": "",
    "text": "pip install summarizedexperiment",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Summarized experiment</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/summarized_expt.html#construction",
    "href": "chapters/experiments/summarized_expt.html#construction",
    "title": "Summarized experiment",
    "section": "Construction",
    "text": "Construction\nA SummarizedExperiment contains three key attributes,\n\nassays: A dictionary of matrices with assay names as keys, e.g. counts, logcounts etc.\nrow_data: Feature information e.g. genes, transcripts, exons, etc.\ncolumn_data: Sample information about the columns of the matrices.\n\nIn addition, these classes can optionally accept row_names and column_names. Since row_data and column_data may also contain names, the following rules are used in the implementation:\n\nOn construction, if row_names or column_names are not provided, these are automatically inferred from row_data and column_data objects.\nOn extraction of these objects, the row_names in row_data and column_data are replaced by the equivalents from the SE level.\nOn setters for these attributes, especially with the functional style (set_row_data and set_column_data methods), additional options are available to replace the names in the SE object.\n\n\n\n\n\n\n\nNote\n\n\n\nThis avoids unexpected mdifications in names, when either row_data or column_data objects are modified.\n\n\nTo construct a SummarizedExperiment, we’ll first generate a matrix of read counts, representing the read counts from a series of RNA-seq experiments. Following that, we’ll create a BiocFrame object to denote feature information and a table for column annotations. This table may include the names for the columns and any other values we wish to represent.\n\n\nShow the code\nfrom random import random\nimport pandas as pd\nimport numpy as np\nfrom biocframe import BiocFrame\n\nnrows = 200\nncols = 6\ncounts = np.random.rand(nrows, ncols)\nrow_data = BiocFrame(\n    {\n        \"seqnames\": [\n            \"chr1\",\n            \"chr2\",\n            \"chr2\",\n            \"chr2\",\n            \"chr1\",\n            \"chr1\",\n            \"chr3\",\n            \"chr3\",\n            \"chr3\",\n            \"chr3\",\n        ]\n        * 20,\n        \"starts\": range(100, 300),\n        \"ends\": range(110, 310),\n        \"strand\": [\"-\", \"+\", \"+\", \"*\", \"*\", \"+\", \"+\", \"+\", \"-\", \"-\"] * 20,\n        \"score\": range(0, 200),\n        \"GC\": [random() for _ in range(10)] * 20,\n    }\n)\n\ncol_data = pd.DataFrame(\n    {\n        \"treatment\": [\"ChIP\", \"Input\"] * 3,\n    }\n)\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe inputs row_data and column_data are expected to be BiocFrame objects and will be coerced to a BiocFrame if a pandas DataFrame is supplied.\n\n\nNow, we can construct a SummarizedExperiment from this information.\n\nfrom summarizedexperiment import SummarizedExperiment\n\nse = SummarizedExperiment(\n    assays={\"counts\": counts}, row_data=row_data, column_data=col_data\n)\n\nprint(se)\n\nclass: SummarizedExperiment\ndimensions: (200, 6)\nassays(1): ['counts']\nrow_data columns(6): ['seqnames', 'starts', 'ends', 'strand', 'score', 'GC']\nrow_names(0):  \ncolumn_data columns(1): ['treatment']\ncolumn_names(6): ['0', '1', '2', '3', '4', '5']\nmetadata(0): \n\n\n\nSimilarly, we can use the same information to construct a RangeSummarizedExperiment. We convert feature information into a GenomicRanges object and provide this as row_ranges:\n\nfrom genomicranges import GenomicRanges\nfrom summarizedexperiment import RangedSummarizedExperiment\n\ngr = GenomicRanges.from_pandas(row_data.to_pandas())\n\nrse = RangedSummarizedExperiment(\n    assays={\"counts\": counts}, row_data=row_data, row_ranges=gr, column_data=col_data\n)\nprint(rse)\n\nclass: RangedSummarizedExperiment\ndimensions: (200, 6)\nassays(1): ['counts']\nrow_data columns(6): ['seqnames', 'starts', 'ends', 'strand', 'score', 'GC']\nrow_names(0):  \ncolumn_data columns(1): ['treatment']\ncolumn_names(6): ['0', '1', '2', '3', '4', '5']\nmetadata(0): \n\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/genomicranges/SeqInfo.py:348: UserWarning: 'seqnames' is deprecated, use 'get_seqnames' instead\n  warn(\"'seqnames' is deprecated, use 'get_seqnames' instead\", UserWarning)",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Summarized experiment</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/summarized_expt.html#delayed-arrays",
    "href": "chapters/experiments/summarized_expt.html#delayed-arrays",
    "title": "Summarized experiment",
    "section": "Delayed arrays",
    "text": "Delayed arrays\nThe general idea is that DelayedArrays are a drop-in replacement for NumPy arrays, at least for BiocPy applications. Learn more about delayed arrays here.\nFor example, we can use the DelayedArray inside a SummarizedExperiment:\n\nimport numpy\nimport delayedarray\n\n# create a delayed array, can also be file-backed\nx = numpy.random.rand(100, 20)\nd = delayedarray.wrap(x)\n\n# operate over delayed arrays\nfiltered = d[1:100:2,1:8]\ntotal = filtered.sum(axis=0)\nnormalized = filtered / total\ntransformed = numpy.log1p(normalized)\n\nimport summarizedexperiment as SE\nse_delayed = SE.SummarizedExperiment({ \"counts\": filtered, \"lognorm\": transformed })\nprint(se_delayed)\n\nclass: SummarizedExperiment\ndimensions: (50, 7)\nassays(2): ['counts', 'lognorm']\nrow_data columns(0): []\nrow_names(0):  \ncolumn_data columns(0): []\ncolumn_names(0):  \nmetadata(0):",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Summarized experiment</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/summarized_expt.html#interop-with-anndata",
    "href": "chapters/experiments/summarized_expt.html#interop-with-anndata",
    "title": "Summarized experiment",
    "section": "Interop with anndata",
    "text": "Interop with anndata\nConverting a SummarizedExperiment to an AnnData representation is straightforward:\n\nadata = se.to_anndata()\nprint(adata)\n\nAnnData object with n_obs × n_vars = 6 × 200\n    obs: 'treatment'\n    var: 'seqnames', 'starts', 'ends', 'strand', 'score', 'GC'\n    layers: 'counts'\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/anndata/_core/anndata.py:183: ImplicitModificationWarning: Transforming to str index.\n  warnings.warn(\"Transforming to str index.\", ImplicitModificationWarning)\n\n\n\n\n\n\n\n\nTip\n\n\n\nTo convert an AnnData object to a BiocPy representation, utilize the from_anndata method in the SingleCellExperiment class. This minimizes the loss of information when converting between these two representations.",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Summarized experiment</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/summarized_expt.html#getterssetters",
    "href": "chapters/experiments/summarized_expt.html#getterssetters",
    "title": "Summarized experiment",
    "section": "Getters/Setters",
    "text": "Getters/Setters\nGetters are available to access various attributes using either the property notation or functional style.\n\n# access assay names\nprint(\"assay names (as property): \", se.assay_names)\nprint(\"assay names (functional style): \", se.get_assay_names())\n\n# access row data\nprint(se.row_data)\n\nassay names (as property):  ['counts']\nassay names (functional style):  ['counts']\nBiocFrame with 200 rows and 6 columns\n      seqnames  starts    ends strand   score                  GC\n        &lt;list&gt; &lt;range&gt; &lt;range&gt; &lt;list&gt; &lt;range&gt;              &lt;list&gt;\n  [0]     chr1     100     110      -       0 0.12249702309312605\n  [1]     chr2     101     111      +       1  0.8127318515694246\n  [2]     chr2     102     112      +       2  0.8173413604306461\n           ...     ...     ...    ...     ...                 ...\n[197]     chr3     297     307      +     197  0.9491572643704873\n[198]     chr3     298     308      -     198  0.9319358292299573\n[199]     chr3     299     309      -     199  0.6577684683677377\n\n\n\nAccess an assay\nOne can access an assay by index or name:\n\nse.assay(0) # same as se.assay(\"counts\")\n\narray([[0.78137522, 0.3988834 , 0.85370246, 0.91533197, 0.12813513,\n        0.92316269],\n       [0.35283751, 0.16975635, 0.03584519, 0.23260145, 0.91188408,\n        0.13965929],\n       [0.91708705, 0.38705443, 0.27584938, 0.79955546, 0.45602203,\n        0.32089359],\n       ...,\n       [0.27432497, 0.99040475, 0.5338549 , 0.13074846, 0.88625302,\n        0.65845203],\n       [0.64738095, 0.86722842, 0.50581788, 0.97741974, 0.88744428,\n        0.2861193 ],\n       [0.97666778, 0.84831844, 0.68077892, 0.25422331, 0.99001125,\n        0.15315596]])\n\n\n\n\nSetters\n\n\n\n\n\n\nImportant\n\n\n\nAll property-based setters are in_place operations, with further details discussed in functional paradigm section.\n\n\n\nmodified_column_data = se.column_data.set_column(\"score\", range(10,16))\nmodified_se = se.set_column_data(modified_column_data)\nprint(modified_se)\n\nclass: SummarizedExperiment\ndimensions: (200, 6)\nassays(1): ['counts']\nrow_data columns(6): ['seqnames', 'starts', 'ends', 'strand', 'score', 'GC']\nrow_names(0):  \ncolumn_data columns(2): ['treatment', 'score']\ncolumn_names(6): ['0', '1', '2', '3', '4', '5']\nmetadata(0): \n\n\n\nNow, lets check the column_data on the original object.\n\nprint(se.column_data)\n\nBiocFrame with 6 rows and 1 column\n  treatment\n     &lt;list&gt;\n0      ChIP\n1     Input\n2      ChIP\n3     Input\n4      ChIP\n5     Input",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Summarized experiment</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/summarized_expt.html#subset-experiments",
    "href": "chapters/experiments/summarized_expt.html#subset-experiments",
    "title": "Summarized experiment",
    "section": "Subset experiments",
    "text": "Subset experiments\nYou can subset experimental data by using the subset ([]) operator. This operation accepts different slice input types, such as a boolean vector, a slice object, a list of indices, or names (if available) to subset.\nIn our previous example, we didn’t include row or column names. Let’s create another SummarizedExperiment object that includes names.\n\n\nShow the code\nrow_data = BiocFrame({\n    \"seqnames\": [\"chr_5\", \"chr_3\", \"chr_2\"],\n    \"start\": [100, 200, 300],\n    \"end\": [110, 210, 310],\n})\n\ncol_data = BiocFrame({\n    \"sample\": [\"SAM_1\", \"SAM_3\", \"SAM_3\"],\n    \"disease\": [\"True\", \"True\", \"True\"],\n    },\n    row_names=[\"cell_1\", \"cell_2\", \"cell_3\"],\n)\n\nse_with_names = SummarizedExperiment(\n    assays={\n        \"counts\": np.random.poisson(lam=5, size=(3, 3)),\n        \"lognorm\": np.random.lognormal(size=(3, 3)),\n    },\n    row_data=row_data,\n    column_data=col_data,\n    row_names=[\"HER2\", \"BRCA1\", \"TPFK\"],\n    column_names=[\"cell_1\", \"cell_2\", \"cell_3\"],\n)\n\nprint(se_with_names)\n\n\nclass: SummarizedExperiment\ndimensions: (3, 3)\nassays(2): ['counts', 'lognorm']\nrow_data columns(3): ['seqnames', 'start', 'end']\nrow_names(3): ['HER2', 'BRCA1', 'TPFK']\ncolumn_data columns(2): ['sample', 'disease']\ncolumn_names(3): ['cell_1', 'cell_2', 'cell_3']\nmetadata(0): \n\n\n\n\nSubset by index position\nA straightforward slice operation:\n\nsubset_se = se_with_names[0:10, 0:3]\nprint(subset_se)\n\nclass: SummarizedExperiment\ndimensions: (3, 3)\nassays(2): ['counts', 'lognorm']\nrow_data columns(3): ['seqnames', 'start', 'end']\nrow_names(3): ['HER2', 'BRCA1', 'TPFK']\ncolumn_data columns(2): ['sample', 'disease']\ncolumn_names(3): ['cell_1', 'cell_2', 'cell_3']\nmetadata(0): \n\n\n\n\n\nSubset by row names or column names\nEither one or both of the slices can contain names. These names are mapped to row_names and column_names of the SummarizedExperiment object.\n\nsubset_se = se_with_names[:2, [\"cell_1\", \"cell_3\"]]\nprint(subset_se)\n\nclass: SummarizedExperiment\ndimensions: (2, 2)\nassays(2): ['counts', 'lognorm']\nrow_data columns(3): ['seqnames', 'start', 'end']\nrow_names(2): ['HER2', 'BRCA1']\ncolumn_data columns(2): ['sample', 'disease']\ncolumn_names(2): ['cell_1', 'cell_3']\nmetadata(0): \n\n\n\nAn Exception is raised if a names does not exist.\n\n\nSubset by boolean vector\nSimilarly, you can also slice by a boolean array. Note that the boolean vectors should contain the same number of features for the row slice and the same number of samples for the column slice.\n\nsubset_se_with_bools = se_with_names[[True, True, False], [True, False, True]]\nprint(subset_se_with_bools)\n\nclass: SummarizedExperiment\ndimensions: (2, 2)\nassays(2): ['counts', 'lognorm']\nrow_data columns(3): ['seqnames', 'start', 'end']\nrow_names(2): ['HER2', 'BRCA1']\ncolumn_data columns(2): ['sample', 'disease']\ncolumn_names(2): ['cell_1', 'cell_3']\nmetadata(0): \n\n\n\n\n\nSubset by empty list\nThis is a feature not a bug :), you can specify an empty list to completely remove all rows or samples.\n\nsubset = se_with_names[:2, []]\nprint(subset)\n\nclass: SummarizedExperiment\ndimensions: (2, 0)\nassays(2): ['counts', 'lognorm']\nrow_data columns(3): ['seqnames', 'start', 'end']\nrow_names(2): ['HER2', 'BRCA1']\ncolumn_data columns(2): ['sample', 'disease']\ncolumn_names(0): []\nmetadata(0):",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Summarized experiment</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/summarized_expt.html#range-based-operations",
    "href": "chapters/experiments/summarized_expt.html#range-based-operations",
    "title": "Summarized experiment",
    "section": "Range-based operations",
    "text": "Range-based operations\nAdditionally, since RangeSummarizedExperiment contain row_ranges, this allows us to perform a number of range based operations that are possible on a GenomicRanges object.\nFor example, to subset RangeSummarizedExperiment with a query set of regions:\n\nfrom iranges import IRanges\nquery = GenomicRanges(seqnames=[\"chr2\"], ranges=IRanges([4], [6]), strand=[\"+\"])\n\nresult = rse.subset_by_overlaps(query)\nprint(result)\n\nclass: RangedSummarizedExperiment\ndimensions: (0, 6)\nassays(1): ['counts']\nrow_data columns(6): ['seqnames', 'starts', 'ends', 'strand', 'score', 'GC']\nrow_names(0):  \ncolumn_data columns(1): ['treatment']\ncolumn_names(6): ['0', '1', '2', '3', '4', '5']\nmetadata(0): \n\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/genomicranges/SeqInfo.py:348: UserWarning: 'seqnames' is deprecated, use 'get_seqnames' instead\n  warn(\"'seqnames' is deprecated, use 'get_seqnames' instead\", UserWarning)\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/genomicranges/SeqInfo.py:348: UserWarning: 'seqnames' is deprecated, use 'get_seqnames' instead\n  warn(\"'seqnames' is deprecated, use 'get_seqnames' instead\", UserWarning)\n\n\nAdditionally, RSE supports many other interval based operations. Checkout the documentation for more details.",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Summarized experiment</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/summarized_expt.html#sec-se-combine",
    "href": "chapters/experiments/summarized_expt.html#sec-se-combine",
    "title": "Summarized experiment",
    "section": "Combining experiments",
    "text": "Combining experiments\nSummarizedExperiment implements methods for the various combine generics from BiocUtils.\nThese methods enable the merging or combining of multiple SummarizedExperiment objects, allowing users to aggregate data from different experiments or conditions. To demonstrate, let’s create multiple SummarizedExperiment objects.\n\n\nShow the code\nrowData1 = pd.DataFrame(\n    {\n        \"seqnames\": [\"chr_5\", \"chr_3\", \"chr_2\"],\n        \"start\": [10293804, 12098948, 20984392],\n        \"end\": [28937947, 3872839, 329837492]\n    },\n    index=[\"HER2\", \"BRCA1\", \"TPFK\"],\n)\ncolData1 = pd.DataFrame(\n    {\n        \"sample\": [\"SAM_1\", \"SAM_3\", \"SAM_3\"],\n        \"disease\": [\"True\", \"True\", \"True\"],\n    },\n    index=[\"cell_1\", \"cell_2\", \"cell_3\"],\n)\nse1 = SummarizedExperiment(\n    assays={\n        \"counts\": np.random.poisson(lam=5, size=(3, 3)),\n        \"lognorm\": np.random.lognormal(size=(3, 3))\n    },\n    row_data=rowData1,\n    column_data=colData1,\n    metadata={\"seq_type\": \"paired\"},\n)\n\nrowData2 = pd.DataFrame(\n    {\n        \"seqnames\": [\"chr_5\", \"chr_3\", \"chr_2\"],\n        \"start\": [10293804, 12098948, 20984392],\n        \"end\": [28937947, 3872839, 329837492]\n    },\n    index=[\"HER2\", \"BRCA1\", \"TPFK\"],\n)\ncolData2 = pd.DataFrame(\n    {\n        \"sample\": [\"SAM_4\", \"SAM_5\", \"SAM_6\"],\n        \"disease\": [\"True\", \"False\", \"True\"],\n    },\n    index=[\"cell_4\", \"cell_5\", \"cell_6\"],\n)\nse2 = SummarizedExperiment(\n    assays={\n        \"counts\": np.random.poisson(lam=5, size=(3, 3)),\n        \"lognorm\": np.random.lognormal(size=(3, 3))\n    },\n    row_data=rowData2,\n    column_data=colData2,\n    metadata={\"seq_platform\": \"Illumina NovaSeq 6000\"},\n)\n\nrowData3 = pd.DataFrame(\n    {\n        \"seqnames\": [\"chr_7\", \"chr_1\", \"chr_Y\"],\n        \"start\": [1084390, 1874937, 243879798],\n        \"end\": [243895239, 358908298, 390820395]\n    },\n    index=[\"MYC\", \"BRCA2\", \"TPFK\"],\n)\ncolData3 = pd.DataFrame(\n    {\n        \"sample\": [\"SAM_7\", \"SAM_8\", \"SAM_9\"],\n        \"disease\": [\"True\", \"False\", \"False\"],\n        \"doublet_score\": [.15, .62, .18]\n    },\n    index=[\"cell_7\", \"cell_8\", \"cell_9\"],\n)\nse3 = SummarizedExperiment(\n    assays={\n        \"counts\": np.random.poisson(lam=5, size=(3, 3)),\n        \"lognorm\": np.random.lognormal(size=(3, 3)),\n        \"beta\": np.random.beta(a=1, b=1, size=(3, 3))\n    },\n    row_data=rowData3,\n    column_data=colData3,\n    metadata={\"seq_platform\": \"Illumina NovaSeq 6000\"},\n)\n\nprint(se1)\nprint(se2)\nprint(se3)\n\n\nclass: SummarizedExperiment\ndimensions: (3, 3)\nassays(2): ['counts', 'lognorm']\nrow_data columns(3): ['seqnames', 'start', 'end']\nrow_names(3): ['HER2', 'BRCA1', 'TPFK']\ncolumn_data columns(2): ['sample', 'disease']\ncolumn_names(3): ['cell_1', 'cell_2', 'cell_3']\nmetadata(1): seq_type\n\nclass: SummarizedExperiment\ndimensions: (3, 3)\nassays(2): ['counts', 'lognorm']\nrow_data columns(3): ['seqnames', 'start', 'end']\nrow_names(3): ['HER2', 'BRCA1', 'TPFK']\ncolumn_data columns(2): ['sample', 'disease']\ncolumn_names(3): ['cell_4', 'cell_5', 'cell_6']\nmetadata(1): seq_platform\n\nclass: SummarizedExperiment\ndimensions: (3, 3)\nassays(3): ['counts', 'lognorm', 'beta']\nrow_data columns(3): ['seqnames', 'start', 'end']\nrow_names(3): ['MYC', 'BRCA2', 'TPFK']\ncolumn_data columns(3): ['sample', 'disease', 'doublet_score']\ncolumn_names(3): ['cell_7', 'cell_8', 'cell_9']\nmetadata(1): seq_platform\n\n\n\nThe combine_rows or combine_columns operations, expect all experiments to contain the same assay names. To combine experiments by row:\n\nfrom biocutils import relaxed_combine_columns, combine_columns, combine_rows, relaxed_combine_rows\nse_combined = combine_rows(se2, se1)\nprint(se_combined)\n\nclass: SummarizedExperiment\ndimensions: (6, 3)\nassays(2): ['counts', 'lognorm']\nrow_data columns(3): ['seqnames', 'start', 'end']\nrow_names(6): ['HER2', 'BRCA1', 'TPFK', 'HER2', 'BRCA1', 'TPFK']\ncolumn_data columns(2): ['sample', 'disease']\ncolumn_names(3): ['cell_4', 'cell_5', 'cell_6']\nmetadata(1): seq_platform\n\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/summarizedexperiment/BaseSE.py:96: UserWarning: 'row_data' does not contain unique 'row_names'.\n  warn(\"'row_data' does not contain unique 'row_names'.\", UserWarning)\n\n\nSimilarly to combine by column:\n\nse_combined = combine_columns(se2, se1)\nprint(se_combined)\n\nclass: SummarizedExperiment\ndimensions: (3, 6)\nassays(2): ['counts', 'lognorm']\nrow_data columns(3): ['seqnames', 'start', 'end']\nrow_names(3): ['HER2', 'BRCA1', 'TPFK']\ncolumn_data columns(2): ['sample', 'disease']\ncolumn_names(6): ['cell_4', 'cell_5', 'cell_6', 'cell_1', 'cell_2', 'cell_3']\nmetadata(1): seq_platform\n\n\n\nYou can use relaxed_combine_columns or relaxed_combined_rows when there’s mismatch in the number of features or samples. Missing rows or columns in any object are filled in with appropriate placeholder values before combining, e.g. missing assay’s are replaced with a masked numpy array.\n\n# se3 contains an additional assay not present in se1\nse_relaxed_combine = relaxed_combine_columns(se3, se1)\nprint(se_relaxed_combine)\n\nclass: SummarizedExperiment\ndimensions: (3, 6)\nassays(3): ['counts', 'lognorm', 'beta']\nrow_data columns(3): ['seqnames', 'start', 'end']\nrow_names(3): ['MYC', 'BRCA2', 'TPFK']\ncolumn_data columns(3): ['sample', 'disease', 'doublet_score']\ncolumn_names(6): ['cell_7', 'cell_8', 'cell_9', 'cell_1', 'cell_2', 'cell_3']\nmetadata(1): seq_platform",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Summarized experiment</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/summarized_expt.html#empty-experiments",
    "href": "chapters/experiments/summarized_expt.html#empty-experiments",
    "title": "Summarized experiment",
    "section": "Empty experiments",
    "text": "Empty experiments\nBoth these classes can also contain no experimental data, and they tend to be useful when integrated into more extensive data structures but do not contain any data themselves.\nTo create an empty SummarizedExperiment:\n\nempty_se = SummarizedExperiment()\nprint(empty_se)\n\nclass: SummarizedExperiment\ndimensions: (0, 0)\nassays(0): []\nrow_data columns(0): []\nrow_names(0):  \ncolumn_data columns(0): []\ncolumn_names(0):  \nmetadata(0): \n\n\n\nSimilarly an empty RangeSummarizedExperiment:\n\nempty_rse = RangedSummarizedExperiment()\nprint(empty_rse)\n\nclass: RangedSummarizedExperiment\ndimensions: (0, 0)\nassays(0): []\nrow_data columns(0): []\nrow_names(0):  \ncolumn_data columns(0): []\ncolumn_names(0):  \nmetadata(0): \n\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/genomicranges/SeqInfo.py:348: UserWarning: 'seqnames' is deprecated, use 'get_seqnames' instead\n  warn(\"'seqnames' is deprecated, use 'get_seqnames' instead\", UserWarning)",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Summarized experiment</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/summarized_expt.html#further-reading",
    "href": "chapters/experiments/summarized_expt.html#further-reading",
    "title": "Summarized experiment",
    "section": "Further reading",
    "text": "Further reading\n\nCheck out reference documentation for more details.\nR/Bioconductor’s SummarizedExperiment package.",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Summarized experiment</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/singlecell_expt.html",
    "href": "chapters/experiments/singlecell_expt.html",
    "title": "Single-cell experiment",
    "section": "",
    "text": "Installation\nTo get started, install the package from PyPI",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Single-cell experiment</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/singlecell_expt.html#installation",
    "href": "chapters/experiments/singlecell_expt.html#installation",
    "title": "Single-cell experiment",
    "section": "",
    "text": "pip install singlecellexperiment",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Single-cell experiment</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/singlecell_expt.html#construction",
    "href": "chapters/experiments/singlecell_expt.html#construction",
    "title": "Single-cell experiment",
    "section": "Construction",
    "text": "Construction\nThe SingleCellExperiment extends RangeSummarizedExperiment and contains few additional attributes:\n\nreduced_dims: Slot for low-dimensionality embeddings for each cell.\nalternative_experiments: Manages multi-modal experiments performed on the same sample or set of cells.\nrow_pairs or column_pairs: Stores relationships between features or cells.\n\nIn contrast to R, matrices in Python are unnamed and do not contain row or column names. Hence, these matrices cannot be directly used as values in assays or alternative experiments. We strictly enforce type checks in these cases. To relax these restrictions for alternative experiments, set type_check_alternative_experiments to False.\nIf you are using the alternative_experiments slot, the number of cells must match the parent experiment. Otherwise, the expectation is that the cells do not share the same sample or annotations and cannot be set in alternative experiments!\nNote: Validation checks do not apply to row_pairs or col_pairs.\nBefore we construct a SingleCellExperiment object, lets generate information about rows, columns and a mock experimental data from single-cell rna-seq experiments:\n\n\nShow the code\nimport pandas as pd\nimport numpy as np\nfrom scipy import sparse as sp\nfrom biocframe import BiocFrame\nfrom genomicranges import GenomicRanges\nfrom random import random \n\nnrows = 200\nncols = 6\ncounts = sp.rand(nrows, ncols, density=0.2, format=\"csr\")\nrow_data = BiocFrame(\n    {\n        \"seqnames\": [\n            \"chr1\",\n            \"chr2\",\n            \"chr2\",\n            \"chr2\",\n            \"chr1\",\n            \"chr1\",\n            \"chr3\",\n            \"chr3\",\n            \"chr3\",\n            \"chr3\",\n        ]\n        * 20,\n        \"starts\": range(100, 300),\n        \"ends\": range(110, 310),\n        \"strand\": [\"-\", \"+\", \"+\", \"*\", \"*\", \"+\", \"+\", \"+\", \"-\", \"-\"] * 20,\n        \"score\": range(0, 200),\n        \"GC\": [random() for _ in range(10)] * 20,\n    }\n)\n\ncol_data = pd.DataFrame(\n    {\n        \"celltype\": [\"cluster1\", \"cluster2\"] * 3,\n    }\n)\n\ncounts\n\n\n&lt;200x6 sparse matrix of type '&lt;class 'numpy.float64'&gt;'\n    with 240 stored elements in Compressed Sparse Row format&gt;\n\n\nNow lets create the SingleCellExperiment instance:\n\nfrom singlecellexperiment import SingleCellExperiment\n\nsce = SingleCellExperiment(\n    assays={\"counts\": counts}, row_data=row_data, column_data=col_data,\n    reduced_dims = {\"random_embeds\": np.random.rand(ncols, 4)}\n)\n\nprint(sce)\n\nclass: SingleCellExperiment\ndimensions: (200, 6)\nassays(1): ['counts']\nrow_data columns(6): ['seqnames', 'starts', 'ends', 'strand', 'score', 'GC']\nrow_names(0):  \ncolumn_data columns(1): ['celltype']\ncolumn_names(6): ['0', '1', '2', '3', '4', '5']\nmain_experiment_name:  \nreduced_dims(1): ['random_embeds']\nalternative_experiments(0): []\nrow_pairs(0): []\ncolumn_pairs(0): []\nmetadata(0): \n\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/genomicranges/SeqInfo.py:348: UserWarning: 'seqnames' is deprecated, use 'get_seqnames' instead\n  warn(\"'seqnames' is deprecated, use 'get_seqnames' instead\", UserWarning)\n\n\n\nInterop with anndata\nWe provide convenient methods for loading an AnnData or h5ad file into SingleCellExperiment objects.\nFor example, lets create an AnnData object,\n\nimport anndata as ad\nfrom scipy import sparse as sp\n\ncounts = sp.csr_matrix(np.random.poisson(1, size=(100, 2000)), dtype=np.float32)\nadata = ad.AnnData(counts)\nadata\n\nAnnData object with n_obs × n_vars = 100 × 2000\n\n\nConverting AnnData as SingleCellExperiment is straightforward:\n\nsce_adata = SingleCellExperiment.from_anndata(adata) \n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/genomicranges/SeqInfo.py:348: UserWarning: 'seqnames' is deprecated, use 'get_seqnames' instead\n  warn(\"'seqnames' is deprecated, use 'get_seqnames' instead\", UserWarning)\n\n\nand vice-verse. All assays from SCE are represented in the layers slot of the AnnData object:\n\nadata2 = sce_adata.to_anndata()\nprint(adata2)\n\n(AnnData object with n_obs × n_vars = 100 × 2000\n    layers: 'X', None)\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/anndata/_core/anndata.py:183: ImplicitModificationWarning: Transforming to str index.\n  warnings.warn(\"Transforming to str index.\", ImplicitModificationWarning)\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/anndata/_core/anndata.py:183: ImplicitModificationWarning: Transforming to str index.\n  warnings.warn(\"Transforming to str index.\", ImplicitModificationWarning)\n\n\nSimilarly, one can load a h5ad file:\n\nfrom singlecellexperiment import read_h5ad\nsce_h5 = read_h5ad(\"../../assets/data/adata.h5ad\")\nprint(sce_h5)\n\nclass: SingleCellExperiment\ndimensions: (20, 30)\nassays(3): ['array', 'sparse', 'X']\nrow_data columns(5): ['var_cat', 'cat_ordered', 'int64', 'float64', 'uint8']\nrow_names(20): ['gene0', 'gene1', 'gene2', ..., 'gene17', 'gene18', 'gene19']\ncolumn_data columns(5): ['obs_cat', 'cat_ordered', 'int64', 'float64', 'uint8']\ncolumn_names(30): ['cell0', 'cell1', 'cell2', ..., 'cell27', 'cell28', 'cell29']\nmain_experiment_name:  \nreduced_dims(0): []\nalternative_experiments(0): []\nrow_pairs(0): []\ncolumn_pairs(0): []\nmetadata(2): O_recarray nested\n\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/genomicranges/SeqInfo.py:348: UserWarning: 'seqnames' is deprecated, use 'get_seqnames' instead\n  warn(\"'seqnames' is deprecated, use 'get_seqnames' instead\", UserWarning)\n\n\n\n\nfrom tenx formats\nIn addition, we also provide convenient methods to load a 10X H5 file. We currently only support version 3 of the 10X H5 format.\n\nfrom singlecellexperiment import read_tenx_h5\nsce_h5 = read_tenx_h5(\"../../assets/data/tenx.sub.h5\")\nprint(sce_h5)\n\nclass: SingleCellExperiment\ndimensions: (1000, 3005)\nassays(1): ['counts']\nrow_data columns(2): ['id', 'name']\nrow_names(0):  \ncolumn_data columns(0): []\ncolumn_names(0):  \nmain_experiment_name:  \nreduced_dims(0): []\nalternative_experiments(0): []\nrow_pairs(0): []\ncolumn_pairs(0): []\nmetadata(0): \n\n\n\n\n\n\n\n\n\nNote\n\n\n\nMethods are also available to read a 10x matrix market directory using the read_tenx_mtx function.",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Single-cell experiment</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/singlecell_expt.html#getterssetters",
    "href": "chapters/experiments/singlecell_expt.html#getterssetters",
    "title": "Single-cell experiment",
    "section": "Getters/Setters",
    "text": "Getters/Setters\nGetters are available to access various attributes using either the property notation or functional style.\nSince SingleCellExperiment extends RangedSummarizedExperiment, all getters and setters from the base class are accessible here; more details here.\n\n# access assay names\nprint(\"reduced dim names (as property): \", sce.reduced_dim_names)\nprint(\"reduced dim names (functional style): \", sce.get_reduced_dim_names())\n\n# access row data\nprint(sce.row_data)\n\nreduced dim names (as property):  ['random_embeds']\nreduced dim names (functional style):  ['random_embeds']\nBiocFrame with 200 rows and 6 columns\n      seqnames  starts    ends strand   score                 GC\n        &lt;list&gt; &lt;range&gt; &lt;range&gt; &lt;list&gt; &lt;range&gt;             &lt;list&gt;\n  [0]     chr1     100     110      -       0 0.8246004638758156\n  [1]     chr2     101     111      +       1 0.6355533946519477\n  [2]     chr2     102     112      +       2 0.2332531986841615\n           ...     ...     ...    ...     ...                ...\n[197]     chr3     297     307      +     197 0.8333552443180684\n[198]     chr3     298     308      -     198 0.9676177838083165\n[199]     chr3     299     309      -     199 0.8369340587229227\n\n\n\nAccess a reduced dimension\nOne can access an reduced dimension by index or name:\n\nsce.reduced_dim(0) # same as se.reduced_dim(\"random_embeds\")\n\narray([[0.00840306, 0.54338856, 0.85922231, 0.2583082 ],\n       [0.49128283, 0.54597176, 0.43724642, 0.651946  ],\n       [0.42515474, 0.7820863 , 0.0428926 , 0.81901174],\n       [0.97255338, 0.86644178, 0.03027746, 0.95454644],\n       [0.06607901, 0.47524039, 0.98095373, 0.71495683],\n       [0.39639564, 0.15271194, 0.43874553, 0.96264174]])",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Single-cell experiment</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/singlecell_expt.html#subset-experiments",
    "href": "chapters/experiments/singlecell_expt.html#subset-experiments",
    "title": "Single-cell experiment",
    "section": "Subset experiments",
    "text": "Subset experiments\nYou can subset experimental data by using the subset ([]) operator. This operation accepts different slice input types, such as a boolean vector, a slice object, a list of indices, or names (if available) to subset.\nIn our previous example, we didn’t include row or column names. Let’s create another SingleCellExperiment object that includes names.\n\nsubset_sce = sce[0:10, 0:3]\nprint(subset_sce)\n\nclass: SingleCellExperiment\ndimensions: (10, 3)\nassays(1): ['counts']\nrow_data columns(6): ['seqnames', 'starts', 'ends', 'strand', 'score', 'GC']\nrow_names(0):  \ncolumn_data columns(1): ['celltype']\ncolumn_names(3): ['0', '1', '2']\nmain_experiment_name:  \nreduced_dims(1): ['random_embeds']\nalternative_experiments(0): []\nrow_pairs(0): []\ncolumn_pairs(0): []\nmetadata(0):",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Single-cell experiment</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/singlecell_expt.html#sec-sce-combine",
    "href": "chapters/experiments/singlecell_expt.html#sec-sce-combine",
    "title": "Single-cell experiment",
    "section": "Combining experiments",
    "text": "Combining experiments\nSingleCellExperiment implements methods for the various combine generics from BiocUtils.\nThese methods enable the merging or combining of multiple SingleCellExperiment objects, allowing users to aggregate data from different experiments or conditions. Note: row_pairs and column_pairs are not ignored as part of this operation.\nTo demonstrate, let’s create multiple SingleCellExperiment objects (read more about this in combine section from SummarizedExperiment).\n\n\nShow the code\nncols = 10\nnrows = 100\nsce1 = SingleCellExperiment(\n    assays={\"counts\": np.random.poisson(lam=10, size=(nrows, ncols))},\n    row_data=BiocFrame({\"A\": [1] * nrows}),\n    column_data=BiocFrame({\"A\": [1] * ncols}),\n)\n\nsce2 = SingleCellExperiment(\n    assays={\n        \"counts\": np.random.poisson(lam=10, size=(nrows, ncols)),\n        # \"normalized\": np.random.normal(size=(nrows, ncols)),\n    },\n    row_data=BiocFrame({\"A\": [3] * nrows}),\n    column_data=BiocFrame({\"A\": [3] * ncols}),\n)\n\nrowdata1 = pd.DataFrame(\n    {\n        \"seqnames\": [\"chr_5\", \"chr_3\", \"chr_2\"],\n        \"start\": [500, 300, 200],\n        \"end\": [510, 310, 210],\n    },\n    index=[\"HER2\", \"BRCA1\", \"TPFK\"],\n)\ncoldata1 = pd.DataFrame(\n    {\n        \"sample\": [\"SAM_1\", \"SAM_2\", \"SAM_3\"],\n        \"disease\": [\"True\", \"True\", \"True\"],\n        \"doublet_score\": [0.15, 0.62, 0.18],\n    },\n    index=[\"cell_1\", \"cell_2\", \"cell_3\"],\n)\nsce_alts1 = SingleCellExperiment(\n    assays={\n        \"counts\": np.random.poisson(lam=5, size=(3, 3)),\n        \"lognorm\": np.random.lognormal(size=(3, 3)),\n    },\n    row_data=rowdata1,\n    column_data=coldata1,\n    row_names=[\"HER2\", \"BRCA1\", \"TPFK\"],\n    column_names=[\"cell_1\", \"cell_2\", \"cell_3\"],\n    metadata={\"seq_type\": \"paired\"},\n    reduced_dims={\"PCA\": np.random.poisson(lam=10, size=(3, 5))},\n    alternative_experiments={\n        \"modality1\": SingleCellExperiment(\n            assays={\"counts2\": np.random.poisson(lam=10, size=(3, 3))},\n        )\n    },\n)\n\nrowdata2 = pd.DataFrame(\n    {\n        \"seqnames\": [\"chr_5\", \"chr_3\", \"chr_2\"],\n        \"start\": [500, 300, 200],\n        \"end\": [510, 310, 210],\n    },\n    index=[\"HER2\", \"BRCA1\", \"TPFK\"],\n)\ncoldata2 = pd.DataFrame(\n    {\n        \"sample\": [\"SAM_4\", \"SAM_5\", \"SAM_6\"],\n        \"disease\": [\"True\", \"False\", \"True\"],\n        \"doublet_score\": [0.05, 0.23, 0.54],\n    },\n    index=[\"cell_4\", \"cell_5\", \"cell_6\"],\n)\nsce_alts2 = SingleCellExperiment(\n    assays={\n        \"counts\": np.random.poisson(lam=5, size=(3, 3)),\n        # \"lognorm\": np.random.lognormal(size=(3, 3)),\n    },\n    row_data=rowdata2,\n    column_data=coldata2,\n    metadata={\"seq_platform\": \"Illumina NovaSeq 6000\"},\n    reduced_dims={\"PCA\": np.random.poisson(lam=5, size=(3, 5))},\n    alternative_experiments={\n        \"modality1\": SingleCellExperiment(\n            assays={\"counts2\": np.random.poisson(lam=5, size=(3, 3))},\n        )\n    },\n)\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/genomicranges/SeqInfo.py:348: UserWarning: 'seqnames' is deprecated, use 'get_seqnames' instead\n  warn(\"'seqnames' is deprecated, use 'get_seqnames' instead\", UserWarning)\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/genomicranges/SeqInfo.py:348: UserWarning: 'seqnames' is deprecated, use 'get_seqnames' instead\n  warn(\"'seqnames' is deprecated, use 'get_seqnames' instead\", UserWarning)\n\n\nThe combine_rows or combine_columns operations, expect all experiments to contain the same assay names. To combine experiments by row:\n\nfrom biocutils import relaxed_combine_columns, combine_columns, combine_rows, relaxed_combine_rows\nsce_combined = combine_rows(sce2, sce1)\nprint(sce_combined)\n\nclass: SingleCellExperiment\ndimensions: (200, 10)\nassays(1): ['counts']\nrow_data columns(1): ['A']\nrow_names(0):  \ncolumn_data columns(1): ['A']\ncolumn_names(0):  \nmain_experiment_name:  \nreduced_dims(0): []\nalternative_experiments(0): []\nrow_pairs(0): []\ncolumn_pairs(0): []\nmetadata(0): \n\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/singlecellexperiment/SingleCellExperiment.py:1089: UserWarning: 'row_pairs' and 'column_pairs' are currently ignored during this operation.\n  warn(\n\n\nSimilarly to combine by column:\n\nsce_combined = combine_columns(sce2, sce1)\nprint(sce_combined)\n\nclass: SingleCellExperiment\ndimensions: (100, 20)\nassays(1): ['counts']\nrow_data columns(1): ['A']\nrow_names(0):  \ncolumn_data columns(1): ['A']\ncolumn_names(0):  \nmain_experiment_name:  \nreduced_dims(0): []\nalternative_experiments(0): []\nrow_pairs(0): []\ncolumn_pairs(0): []\nmetadata(0): \n\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/singlecellexperiment/SingleCellExperiment.py:1131: UserWarning: 'row_pairs' and 'column_pairs' are currently ignored during this operation.\n  warn(\n\n\nYou can use relaxed_combine_columns or relaxed_combined_rows when there’s mismatch in the number of features or samples. Missing rows or columns in any object are filled in with appropriate placeholder values before combining, e.g. missing assay’s are replaced with a masked numpy array.\n\n# sce_alts1 contains an additional assay not present in sce_alts2\nsce_relaxed_combine = relaxed_combine_columns(sce_alts1, sce_alts2)\nprint(sce_relaxed_combine)\n\nclass: SingleCellExperiment\ndimensions: (3, 6)\nassays(2): ['counts', 'lognorm']\nrow_data columns(3): ['seqnames', 'start', 'end']\nrow_names(3): ['HER2', 'BRCA1', 'TPFK']\ncolumn_data columns(3): ['sample', 'disease', 'doublet_score']\ncolumn_names(6): ['cell_1', 'cell_2', 'cell_3', 'cell_4', 'cell_5', 'cell_6']\nmain_experiment_name:  \nreduced_dims(1): ['PCA']\nalternative_experiments(1): ['modality1']\nrow_pairs(0): []\ncolumn_pairs(0): []\nmetadata(1): seq_type\n\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/singlecellexperiment/SingleCellExperiment.py:1241: UserWarning: 'row_pairs' and 'column_pairs' are currently ignored during this operation.\n  warn(\"'row_pairs' and 'column_pairs' are currently ignored during this operation.\")",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Single-cell experiment</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/singlecell_expt.html#export-as-mudata",
    "href": "chapters/experiments/singlecell_expt.html#export-as-mudata",
    "title": "Single-cell experiment",
    "section": "Export as MuData",
    "text": "Export as MuData\nThe package also provides methods to convert a SingleCellExperiment object into a MuData representation:\n\nmdata = sce.to_mudata()\nmdata\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/anndata/_core/anndata.py:183: ImplicitModificationWarning: Transforming to str index.\n  warnings.warn(\"Transforming to str index.\", ImplicitModificationWarning)\n\n\nMuData object with n_obs × n_vars = 6 × 200\n  var:  'seqnames', 'starts', 'ends', 'strand', 'score', 'GC'\n  1 modality\n    Unknown Modality:   6 x 200\n      obs:  'celltype'\n      var:  'seqnames', 'starts', 'ends', 'strand', 'score', 'GC'\n      obsm: 'random_embeds'\n      layers:   'counts'",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Single-cell experiment</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/singlecell_expt.html#further-reading",
    "href": "chapters/experiments/singlecell_expt.html#further-reading",
    "title": "Single-cell experiment",
    "section": "Further reading",
    "text": "Further reading\n\nCheck out reference documentation for more details.\nR/Bioconductor’s SingleCellExperiment package.",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Single-cell experiment</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/extending_se.html",
    "href": "chapters/experiments/extending_se.html",
    "title": "Extending summarized experiments",
    "section": "",
    "text": "Define the new class\nAs a simple example, let’s create a new class called BioSampleSE that stores biosample information on which the experiment was conducted. This may contain anonymized information about the patient(s) or sample(s). First, we extend the SummarizedExperiment class:\nfrom summarizedexperiment import SummarizedExperiment\n\nclass BioSampleSE(SummarizedExperiment):\n    pass",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Extending summarized experiments</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/extending_se.html#add-a-new-slot-or-attribute",
    "href": "chapters/experiments/extending_se.html#add-a-new-slot-or-attribute",
    "title": "Extending summarized experiments",
    "section": "Add a new slot or attribute",
    "text": "Add a new slot or attribute\nTo add a new slot to this class, we accept a new parameter bio_sample_information when the class is initialized through the init method. We also provide type hints to set expectations on the accepted types for these arguments. Type hints are helpful for users and are automatically annotated in the documentation. More information on type hints can be found in our developer guide.\nWe forward the default parameters to the base SummarizedExperiment class (using the super method) and store the new attribute.\n\nfrom summarizedexperiment import SummarizedExperiment\nimport biocframe\nfrom typing import Dict, Any, List, Optional\n\nclass BioSampleSE(SummarizedExperiment):\n    \n    def __init__(\n        self,\n        assays: Dict[str, Any] = None,\n        row_data: Optional[biocframe.BiocFrame] = None,\n        column_data: Optional[biocframe.BiocFrame] = None,\n        row_names: Optional[List[str]] = None,\n        column_names: Optional[List[str]] = None,\n        metadata: Optional[dict] = None,\n        bio_sample_information: Optional[biocframe.BiocFrame] = None, # NEW SLOT\n        validate: bool = True,\n    ) -&gt; None:\n        super().__init__(\n            assays,\n            row_data=row_data,\n            column_data=column_data,\n            row_names=row_names,\n            column_names=column_names,\n            metadata=metadata,\n            validate=validate,\n        )\n\n        self._bio_sample_information = bio_sample_information\n\nThe new slot can be validated using a dedicated validator:\n\ndef _validate_bio_sample_information(bio_sample_info):\n    if not isinstance(bio_sample_info, biocframe.BiocFrame):\n        raise Exception(\"Biosample information must be a BiocFrame object.\")\n\n    # any other validations. for example, if you have expectations on the columns \n    # of this frame or the number of rows. \n\nOur class now validates the new slot:\n\nclass BioSampleSE(SummarizedExperiment):\n    \n    def __init__(\n        self,\n        assays: Dict[str, Any] = None,\n        row_data: Optional[biocframe.BiocFrame] = None,\n        column_data: Optional[biocframe.BiocFrame] = None,\n        row_names: Optional[List[str]] = None,\n        column_names: Optional[List[str]] = None,\n        metadata: Optional[dict] = None,\n        bio_sample_information: Optional[biocframe.BiocFrame] = None, # NEW SLOT\n        validate: bool = True,\n    ) -&gt; None:\n        super().__init__(\n            assays,\n            row_data=row_data,\n            column_data=column_data,\n            row_names=row_names,\n            column_names=column_names,\n            metadata=metadata,\n            validate=validate,\n        )\n\n        self._bio_sample_information = bio_sample_information\n\n        if validate:\n            _validate_bio_sample_information(self._bio_sample_information)",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Extending summarized experiments</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/extending_se.html#define-getterssetters",
    "href": "chapters/experiments/extending_se.html#define-getterssetters",
    "title": "Extending summarized experiments",
    "section": "Define getters/setters",
    "text": "Define getters/setters\nWe need accessors and setters so users can interact with this new property. We provide these accessors in both functional and property-based approaches. More details can be found in our class design document.\ndef get_bio_sample_information(self) -&gt; Optional[biocframe.BiocFrame]:\n    \"\"\"Get biosample information.\n\n    Returns:\n        biosample information or None if not availabl.\n    \"\"\"\n    return self._bio_sample_information\n\ndef set_bio_sample_information(\n    self, bio_sample_information: Optional[biocframe.BiocFrame], in_place: bool = False\n) -&gt; \"BioSampleSE\":\n    \"\"\"Set new biosample information.\n\n    Args:\n        bio_sample_information:\n            A new `BiocFrame` object containing biosample information.\n\n        in_place:\n            Whether to modify the ``BioSampleSE`` in place.\n\n    Returns:\n        A modified ``BioSampleSE`` object, either as a copy of the original\n        or as a reference to the (in-place-modified) original.\n    \"\"\"\n    _validate_bio_sample_information(bio_sample_info)\n\n    output = self._define_output(in_place) # MAKES A SHALLOW COPY\n    output._bio_sample_information = bio_sample_info\n    return output\nAdditionally, let’s provide property-based accessors to the new attribute:\n@property\ndef bio_sample_information(self) -&gt; biocframe.BiocFrame:\n    \"\"\"Alias for :py:meth:`~get_bio_sample_info`.\"\"\"\n    return self.get_bio_sample_info()\n\n@bio_sample_information.setter\ndef bio_sample_information(self, bio_sample_info: biocframe.BiocFrame) -&gt; None:\n    \"\"\"Alias for :py:meth:`~set_bio_sample_info`.\"\"\"\n    warn(\n        \"Setting property 'bio_sample_information' is an in-place operation, use 'set_bio_sample_info' instead\",\n        UserWarning,\n    )\n    return self.set_bio_sample_information(row_ranges=row_ranges, in_place=True)\nThis allows users to easily access the new property using the dot notation on an instance, for example, obj.bio_sample_info provides access to the attribute.",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Extending summarized experiments</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/extending_se.html#define-shallow-and-deep-copy-methods",
    "href": "chapters/experiments/extending_se.html#define-shallow-and-deep-copy-methods",
    "title": "Extending summarized experiments",
    "section": "Define shallow and deep copy methods",
    "text": "Define shallow and deep copy methods\nTo avoid mutating objects in-place, methods for making shallow and deep copies of the class attributes are implemented.\ndef __deepcopy__(self, memo=None, _nil=[]):\n    \"\"\"\n    Returns:\n        A deep copy of the current ``BioSampleSE``.\n    \"\"\"\n    from copy import deepcopy\n\n    _assays_copy = deepcopy(self._assays)\n    _rows_copy = deepcopy(self._rows)\n    _cols_copy = deepcopy(self._cols)\n    _row_names_copy = deepcopy(self._row_names)\n    _col_names_copy = deepcopy(self._column_names)\n    _bio_sample_information_copy = deepcopy(self._bio_sample_information)\n    _metadata_copy = deepcopy(self.metadata)\n\n    current_class_const = type(self)\n    return current_class_const(\n        assays=_assays_copy,\n        row_data=_rows_copy,\n        column_data=_cols_copy,\n        row_names=_row_names_copy,\n        column_names=_col_names_copy,\n        bio_sample_information=_bio_sample_information_copy,\n        metadata=_metadata_copy,\n    )\n\ndef __copy__(self):\n    \"\"\"\n    Returns:\n        A shallow copy of the current ``BioSampleSE``.\n    \"\"\"\n    current_class_const = type(self)\n    return current_class_const(\n        assays=self._assays,\n        row_data=self._rows,\n        column_data=self._cols,\n        row_names=self._row_names,\n        column_names=self._column_names,\n        bio_sample_information=self._bio_sample_information,\n        metadata=self._metadata,\n    )\n\ndef copy(self):\n    \"\"\"Alias for :py:meth:`~__copy__`.\"\"\"\n    return self.__copy__()",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Extending summarized experiments</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/extending_se.html#subset-operation",
    "href": "chapters/experiments/extending_se.html#subset-operation",
    "title": "Extending summarized experiments",
    "section": "Subset operation",
    "text": "Subset operation\nWhen the experiment is subsetted using the [] operator, we may also have to subset the new slots added to the extended class. Developers only need to extend the get_slice function from the base class that accepts row and column subsets. The _generic_slice function returns a slicer object containing normalized row and column indices, and properties from the base class.\nfrom typing import Sequence\n\ndef get_slice(\n    self,\n    rows: Optional[Union[str, int, bool, Sequence]],\n    columns: Optional[Union[str, int, bool, Sequence]],\n) -&gt; \"BioSampleSE\":\n    \"\"\"Alias for :py:attr:`~__getitem__`, for back-compatibility.\"\"\"\n\n    slicer = self._generic_slice(rows=rows, columns=columns)\n\n    # An illustrative example\n    new_bio_sample_info = None\n    if slicer.row_indices != slice(None):\n        new_bio_sample_info = self.bio_sample_info[slicer.row_indices]\n\n    current_class_const = type(self)\n    return current_class_const(\n        assays=slicer.assays,\n        row_data=slicer.rows,\n        column_data=slicer.columns,\n        row_names=slicer.row_names,\n        column_names=slicer.column_names,\n        bio_sample_info=self.bio_sample_info.\n        metadata=self._metadata,\n    )",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Extending summarized experiments</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/extending_se.html#putting-it-all-together",
    "href": "chapters/experiments/extending_se.html#putting-it-all-together",
    "title": "Extending summarized experiments",
    "section": "Putting it all together",
    "text": "Putting it all together\n\n\nShow the full class\ndef _validate_bio_sample_information(bio_sample_info):\n    if not isinstance(bio_sample_info, biocframe.BiocFrame):\n        raise Exception(\"Biosample information must be a BiocFrame object.\")\n\nclass BioSampleSE(SummarizedExperiment):\n    \n    def __init__(\n        self,\n        assays: Dict[str, Any] = None,\n        row_data: Optional[biocframe.BiocFrame] = None,\n        column_data: Optional[biocframe.BiocFrame] = None,\n        row_names: Optional[List[str]] = None,\n        column_names: Optional[List[str]] = None,\n        metadata: Optional[dict] = None,\n        bio_sample_information: Optional[biocframe.BiocFrame] = None, # NEW SLOT\n        validate: bool = True,\n    ) -&gt; None:\n        super().__init__(\n            assays,\n            row_data=row_data,\n            column_data=column_data,\n            row_names=row_names,\n            column_names=column_names,\n            metadata=metadata,\n            validate=validate,\n        )\n\n        self._bio_sample_information = bio_sample_information\n\n        if validate:\n            _validate_bio_sample_information(self._bio_sample_information)\n\n    def __deepcopy__(self, memo=None, _nil=[]):\n        \"\"\"\n        Returns:\n            A deep copy of the current ``BioSampleSE``.\n        \"\"\"\n        from copy import deepcopy\n\n        _assays_copy = deepcopy(self._assays)\n        _rows_copy = deepcopy(self._rows)\n        _cols_copy = deepcopy(self._cols)\n        _row_names_copy = deepcopy(self._row_names)\n        _col_names_copy = deepcopy(self._column_names)\n        _bio_sample_information_copy = deepcopy(self._bio_sample_information)\n        _metadata_copy = deepcopy(self.metadata)\n\n        current_class_const = type(self)\n        return current_class_const(\n            assays=_assays_copy,\n            row_data=_rows_copy,\n            column_data=_cols_copy,\n            row_names=_row_names_copy,\n            column_names=_col_names_copy,\n            bio_sample_information=_bio_sample_information_copy,\n            metadata=_metadata_copy,\n        )\n\n    def __copy__(self):\n        \"\"\"\n        Returns:\n            A shallow copy of the current ``BioSampleSE``.\n        \"\"\"\n        current_class_const = type(self)\n        return current_class_const(\n            assays=self._assays,\n            row_data=self._rows,\n            column_data=self._cols,\n            row_names=self._row_names,\n            column_names=self._column_names,\n            bio_sample_information=self._bio_sample_information,\n            metadata=self._metadata,\n        )\n\n    def copy(self):\n        \"\"\"Alias for :py:meth:`~__copy__`.\"\"\"\n        return self.__copy__()\n\n\n    def get_bio_sample_information(self) -&gt; Optional[biocframe.BiocFrame]:\n        \"\"\"Get biosample information.\n\n        Returns:\n            biosample information or None if not availabl.\n        \"\"\"\n        return self._bio_sample_information\n\n    def set_bio_sample_information(\n        self, bio_sample_information: Optional[biocframe.BiocFrame], in_place: bool = False\n    ) -&gt; \"BioSampleSE\":\n        \"\"\"Set new biosample information.\n\n        Args:\n            bio_sample_information:\n                A new `BiocFrame` object containing biosample information.\n\n            in_place:\n                Whether to modify the ``BioSampleSE`` in place.\n\n        Returns:\n            A modified ``BioSampleSE`` object, either as a copy of the original\n            or as a reference to the (in-place-modified) original.\n        \"\"\"\n        _validate_bio_sample_information(bio_sample_info)\n\n        output = self._define_output(in_place) # MAKES A SHALLOW COPY\n        output._bio_sample_information = bio_sample_info\n        return output\n\n\n    @property\n    def bio_sample_information(self) -&gt; biocframe.BiocFrame:\n        \"\"\"Alias for :py:meth:`~get_bio_sample_info`.\"\"\"\n        return self.get_bio_sample_info()\n\n    @bio_sample_information.setter\n    def bio_sample_information(self, bio_sample_info: biocframe.BiocFrame) -&gt; None:\n        \"\"\"Alias for :py:meth:`~set_bio_sample_info`.\"\"\"\n        warn(\n            \"Setting property 'bio_sample_information' is an in-place operation, use 'set_bio_sample_info' instead\",\n            UserWarning,\n        )\n        return self.set_bio_sample_information(row_ranges=row_ranges, in_place=True)\n\n\nThat’s the minimum required to extend a SummarizedExperiment and adapt it to new use cases. Please follow the developer guide, which provides information on class design, package setup, and documentation to ensure consistency in how BiocPy-related packages are developed.",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Extending summarized experiments</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/multiassay_expt.html",
    "href": "chapters/experiments/multiassay_expt.html",
    "title": "Multiple experiments",
    "section": "",
    "text": "Installation\nTo get started, install the package from PyPI",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Multiple experiments</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/multiassay_expt.html#installation",
    "href": "chapters/experiments/multiassay_expt.html#installation",
    "title": "Multiple experiments",
    "section": "",
    "text": "pip install multiassayexperiment",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Multiple experiments</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/multiassay_expt.html#construction",
    "href": "chapters/experiments/multiassay_expt.html#construction",
    "title": "Multiple experiments",
    "section": "Construction",
    "text": "Construction\nAn MAE contains three main entities,\n\nPrimary information (column_data): Bio-specimen/sample information. The column_data may provide information about patients, cell lines, or other biological units. Each row in this table represents an independent biological unit. It must contain an index that maps to the ‘primary’ in sample_map.\nExperiments (experiments): Genomic data from each experiment. either a SingleCellExperiment, SummarizedExperiment, RangedSummarizedExperiment or any class that extends a SummarizedExperiment.\nSample Map (sample_map): Map biological units from column_data to the list of experiments. Must contain columns,\n\nassay provides the names of the different experiments performed on the biological units. All experiment names from experiments must be present in this column.\nprimary contains the sample name. All names in this column must match with row labels from col_data.\ncolname is the mapping of samples/cells within each experiment back to its biosample information in col_data.\n\nEach sample in column_data may map to one or more columns per assay.\n\nLet’s start by first creating few experiments:\n\n\nShow the code\nfrom random import random\n\nimport numpy as np\nfrom biocframe import BiocFrame\nfrom genomicranges import GenomicRanges\nfrom iranges import IRanges\n\nnrows = 200\nncols = 6\ncounts = np.random.rand(nrows, ncols)\ngr = GenomicRanges(\n    seqnames=[\n            \"chr1\",\n            \"chr2\",\n            \"chr2\",\n            \"chr2\",\n            \"chr1\",\n            \"chr1\",\n            \"chr3\",\n            \"chr3\",\n            \"chr3\",\n            \"chr3\",\n        ] * 20,\n    ranges=IRanges(range(100, 300), range(110, 310)),\n    strand = [\"-\", \"+\", \"+\", \"*\", \"*\", \"+\", \"+\", \"+\", \"-\", \"-\"] * 20,\n    mcols=BiocFrame({\n        \"score\": range(0, 200),\n        \"GC\": [random() for _ in range(10)] * 20,\n    })\n)\n\ncol_data_sce = BiocFrame({\"treatment\": [\"ChIP\", \"Input\"] * 3},\n    row_names=[f\"sce_{i}\" for i in range(6)],\n)\n\ncol_data_se = BiocFrame({\"treatment\": [\"ChIP\", \"Input\"] * 3},\n    row_names=[f\"se_{i}\" for i in range(6)],\n)\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/genomicranges/SeqInfo.py:348: UserWarning: 'seqnames' is deprecated, use 'get_seqnames' instead\n  warn(\"'seqnames' is deprecated, use 'get_seqnames' instead\", UserWarning)\n\n\nMore importantly, we need to provide sample_map information:\n\nsample_map = BiocFrame({\n    \"assay\": [\"sce\", \"se\"] * 6,\n    \"primary\": [\"sample1\", \"sample2\"] * 6,\n    \"colname\": [\"sce_0\", \"se_0\", \"sce_1\", \"se_1\", \"sce_2\", \"se_2\", \"sce_3\", \"se_3\", \"sce_4\", \"se_4\", \"sce_5\", \"se_5\"]\n})\n\nsample_data = BiocFrame({\"samples\": [\"sample1\", \"sample2\"]}, row_names= [\"sample1\", \"sample2\"])\n\nprint(sample_map)\n\nBiocFrame with 12 rows and 3 columns\n      assay primary colname\n     &lt;list&gt;  &lt;list&gt;  &lt;list&gt;\n [0]    sce sample1   sce_0\n [1]     se sample2    se_0\n [2]    sce sample1   sce_1\n        ...     ...     ...\n [9]     se sample2    se_4\n[10]    sce sample1   sce_5\n[11]     se sample2    se_5\n\n\nFinally, we can create an MultiAssayExperiment object:\n\nfrom multiassayexperiment import MultiAssayExperiment\nfrom singlecellexperiment import SingleCellExperiment\nfrom summarizedexperiment import SummarizedExperiment\n\ntsce = SingleCellExperiment(\n    assays={\"counts\": counts}, row_data=gr.to_pandas(), column_data=col_data_sce\n)\n\ntse2 = SummarizedExperiment(\n    assays={\"counts\": counts.copy()},\n    row_data=gr.to_pandas().copy(),\n    column_data=col_data_se.copy(),\n)\n\nmae = MultiAssayExperiment(\n    experiments={\"sce\": tsce, \"se\": tse2},\n    column_data=sample_data,\n    sample_map=sample_map,\n    metadata={\"could be\": \"anything\"},\n)\n\nprint(mae)\n\nclass: MultiAssayExperiment containing 2 experiments\n[0] sce: SingleCellExperiment with 200 rows and 6 columns \n[1] se: SummarizedExperiment with 200 rows and 6 columns \ncolumn_data columns(1): ['samples']\nsample_map columns(3): ['assay', 'primary', 'colname']\nmetadata(1): could be\n\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/genomicranges/SeqInfo.py:348: UserWarning: 'seqnames' is deprecated, use 'get_seqnames' instead\n  warn(\"'seqnames' is deprecated, use 'get_seqnames' instead\", UserWarning)\n\n\n\nNo sample mapping?\nIf both column_data and sample_map are None, the constructor naively creates sample mapping, with each experiment considered to be a independent sample. We add a sample to column_data in this pattern - unknown_sample_{experiment_name}.\nAll cells from the each experiment are considered to be from the same sample and is reflected in sample_map. This is not a recommended approach, but if you don’t have sample mapping, then it doesn’t matter.\n\nmae = MultiAssayExperiment(\n    experiments={\"sce\": tsce, \"se\": tse2},\n    metadata={\"could be\": \"anything\"},\n)\n\nprint(mae)\n\nclass: MultiAssayExperiment containing 2 experiments\n[0] sce: SingleCellExperiment with 200 rows and 6 columns \n[1] se: SummarizedExperiment with 200 rows and 6 columns \ncolumn_data columns(1): ['samples']\nsample_map columns(3): ['assay', 'primary', 'colname']\nmetadata(1): could be\n\n\n\n\n\nInterop with anndata or mudata\nWe provide convenient methods to easily convert a MuData object into an MultiAssayExperiment.\nLet’s create a mudata object:\n\n\nShow the code\nimport numpy as np\nfrom anndata import AnnData\n\nnp.random.seed(1)\n\nn, d, k = 1000, 100, 10\n\nz = np.random.normal(loc=np.arange(k), scale=np.arange(k) * 2, size=(n, k))\nw = np.random.normal(size=(d, k))\ny = np.dot(z, w.T)\n\nadata = AnnData(y)\nadata.obs_names = [f\"obs_{i+1}\" for i in range(n)]\nadata.var_names = [f\"var_{j+1}\" for j in range(d)]\n\nd2 = 50\nw2 = np.random.normal(size=(d2, k))\ny2 = np.dot(z, w2.T)\n\nadata2 = AnnData(y2)\nadata2.obs_names = [f\"obs_{i+1}\" for i in range(n)]\nadata2.var_names = [f\"var2_{j+1}\" for j in range(d2)]\n\nfrom mudata import MuData\nmdata = MuData({\"rna\": adata, \"spatial\": adata2})\n\nprint(mdata)\n\n\nMuData object with n_obs × n_vars = 1000 × 150\n  2 modalities\n    rna:    1000 x 100\n    spatial:    1000 x 50\n\n\nLets convert this object to an MAE:\n\nfrom multiassayexperiment import MultiAssayExperiment\n\nmae_obj = MultiAssayExperiment.from_mudata(input=mdata)\nprint(mae_obj)\n\nclass: MultiAssayExperiment containing 2 experiments\n[0] rna: SingleCellExperiment with 100 rows and 1000 columns \n[1] spatial: SingleCellExperiment with 50 rows and 1000 columns \ncolumn_data columns(1): ['samples']\nsample_map columns(3): ['assay', 'primary', 'colname']\nmetadata(0): \n\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/genomicranges/SeqInfo.py:348: UserWarning: 'seqnames' is deprecated, use 'get_seqnames' instead\n  warn(\"'seqnames' is deprecated, use 'get_seqnames' instead\", UserWarning)\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/genomicranges/SeqInfo.py:348: UserWarning: 'seqnames' is deprecated, use 'get_seqnames' instead\n  warn(\"'seqnames' is deprecated, use 'get_seqnames' instead\", UserWarning)",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Multiple experiments</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/multiassay_expt.html#getterssetters",
    "href": "chapters/experiments/multiassay_expt.html#getterssetters",
    "title": "Multiple experiments",
    "section": "Getters/Setters",
    "text": "Getters/Setters\nGetters are available to access various attributes using either the property notation or functional style.\n\n# access assays\nprint(\"experiment names (as property): \", mae.experiment_names)\nprint(\"experiment names (functional style): \", mae.get_experiment_names())\n\n# access sample data\nprint(mae.column_data)\n\nexperiment names (as property):  ['sce', 'se']\nexperiment names (functional style):  ['sce', 'se']\nBiocFrame with 2 rows and 1 column\n                              samples\n                               &lt;list&gt;\nunknown_sample_sce unknown_sample_sce\n unknown_sample_se  unknown_sample_se\n\n\nCheck out the class documentation for the full list of accessors and setters.\n\nRow or column name accessors\nA helper method is available to easily access row or column names across all experiments. This method returns a dictionary with experiment names as keys and the corresponding values, which can be either the row or column names depending on the function:\n\nfrom rich import print as pprint\npprint(\"row names:\", mae.get_row_names())\npprint(\"column names:\", mae.get_column_names())\n\nrow names:\n{\n    'sce': Names(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17',\n'18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '36', \n'37', '38', '39', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '50', '51', '52', '53', '54', '55', \n'56', '57', '58', '59', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '70', '71', '72', '73', '74', \n'75', '76', '77', '78', '79', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '90', '91', '92', '93', \n'94', '95', '96', '97', '98', '99', '100', '101', '102', '103', '104', '105', '106', '107', '108', '109', '110', \n'111', '112', '113', '114', '115', '116', '117', '118', '119', '120', '121', '122', '123', '124', '125', '126', \n'127', '128', '129', '130', '131', '132', '133', '134', '135', '136', '137', '138', '139', '140', '141', '142', \n'143', '144', '145', '146', '147', '148', '149', '150', '151', '152', '153', '154', '155', '156', '157', '158', \n'159', '160', '161', '162', '163', '164', '165', '166', '167', '168', '169', '170', '171', '172', '173', '174', \n'175', '176', '177', '178', '179', '180', '181', '182', '183', '184', '185', '186', '187', '188', '189', '190', \n'191', '192', '193', '194', '195', '196', '197', '198', '199']),\n    'se': Names(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', \n'18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '36', \n'37', '38', '39', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '50', '51', '52', '53', '54', '55', \n'56', '57', '58', '59', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '70', '71', '72', '73', '74', \n'75', '76', '77', '78', '79', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '90', '91', '92', '93', \n'94', '95', '96', '97', '98', '99', '100', '101', '102', '103', '104', '105', '106', '107', '108', '109', '110', \n'111', '112', '113', '114', '115', '116', '117', '118', '119', '120', '121', '122', '123', '124', '125', '126', \n'127', '128', '129', '130', '131', '132', '133', '134', '135', '136', '137', '138', '139', '140', '141', '142', \n'143', '144', '145', '146', '147', '148', '149', '150', '151', '152', '153', '154', '155', '156', '157', '158', \n'159', '160', '161', '162', '163', '164', '165', '166', '167', '168', '169', '170', '171', '172', '173', '174', \n'175', '176', '177', '178', '179', '180', '181', '182', '183', '184', '185', '186', '187', '188', '189', '190', \n'191', '192', '193', '194', '195', '196', '197', '198', '199'])\n}\n\n\n\ncolumn names:\n{\n    'sce': Names(['sce_0', 'sce_1', 'sce_2', 'sce_3', 'sce_4', 'sce_5']),\n    'se': Names(['se_0', 'se_1', 'se_2', 'se_3', 'se_4', 'se_5'])\n}\n\n\n\n\n\nAccess an experiment\nOne can access an experiment by name:\n\nprint(mae.experiment(\"se\"))\n\nclass: SummarizedExperiment\ndimensions: (200, 6)\nassays(1): ['counts']\nrow_data columns(7): ['starts', 'widths', 'ends', 'seqnames', 'strand', 'score', 'GC']\nrow_names(200): ['0', '1', '2', ..., '197', '198', '199']\ncolumn_data columns(1): ['treatment']\ncolumn_names(6): ['se_0', 'se_1', 'se_2', 'se_3', 'se_4', 'se_5']\nmetadata(0): \n\n\n\nAdditionally you may access an experiment with the sample information included in the column data of the experiment. Note, this creates a copy of the experiment:\n\nexpt_with_sample_info = mae.experiment(\"se\", with_sample_data=True)\nprint(expt_with_sample_info)\n\nclass: SummarizedExperiment\ndimensions: (200, 6)\nassays(1): ['counts']\nrow_data columns(7): ['starts', 'widths', 'ends', 'seqnames', 'strand', 'score', 'GC']\nrow_names(200): ['0', '1', '2', ..., '197', '198', '199']\ncolumn_data columns(5): ['assay', 'primary', 'colname', 'treatment', 'samples']\ncolumn_names(6): ['se_0', 'se_1', 'se_2', 'se_3', 'se_4', 'se_5']\nmetadata(0): \n\n\n\n\n\n\n\n\n\nNote\n\n\n\nFor consistency with the R MAE’s interface, we also provide get_with_col_data method, that performs the same operation.\n\n\n\n\nSetters\n\n\n\n\n\n\nImportant\n\n\n\nAll property-based setters are in_place operations, with further details discussed in functional paradigm section.\n\n\n\nmodified_column_data = mae.column_data.set_column(\"score\", range(len(mae.column_data)))\nmodified_mae = mae.set_column_data(modified_column_data)\nprint(modified_mae)\n\nclass: MultiAssayExperiment containing 2 experiments\n[0] sce: SingleCellExperiment with 200 rows and 6 columns \n[1] se: SummarizedExperiment with 200 rows and 6 columns \ncolumn_data columns(2): ['samples', 'score']\nsample_map columns(3): ['assay', 'primary', 'colname']\nmetadata(1): could be\n\n\n\nNow, lets check the column_data on the original object.\n\nprint(mae.column_data)\n\nBiocFrame with 2 rows and 1 column\n                              samples\n                               &lt;list&gt;\nunknown_sample_sce unknown_sample_sce\n unknown_sample_se  unknown_sample_se",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Multiple experiments</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/multiassay_expt.html#subsetting",
    "href": "chapters/experiments/multiassay_expt.html#subsetting",
    "title": "Multiple experiments",
    "section": "Subsetting",
    "text": "Subsetting\nYou can subset MultiAssayExperiment by using the subset ([]) operator. This operation accepts different slice input types, such as a boolean vector, a slice object, a list of indices, or names (if available) to subset.\nMultiAssayExperiment allows subsetting by three dimensions: rows, columns, and experiments. sample_map is automatically filtered during this operation.\n\nSubset by indices\n\nsubset_mae = mae[1:5, 0:4]\nprint(subset_mae)\n\nclass: MultiAssayExperiment containing 2 experiments\n[0] sce: SingleCellExperiment with 4 rows and 6 columns \n[1] se: SummarizedExperiment with 4 rows and 6 columns \ncolumn_data columns(1): ['samples']\nsample_map columns(3): ['assay', 'primary', 'colname']\nmetadata(1): could be\n\n\n\n\n\nSubset by experiments dimension\nThe following creates a subset based on the experiments dimension:\n\nsubset_mae = mae[1:5, 0:1, [\"se\"]]\nprint(subset_mae)\n\nclass: MultiAssayExperiment containing 1 experiments\n[0] se: SummarizedExperiment with 4 rows and 0 columns \ncolumn_data columns(1): ['samples']\nsample_map columns(3): ['assay', 'primary', 'colname']\nmetadata(1): could be\n\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/multiassayexperiment/MultiAssayExperiment.py:63: UserWarning: 'primary' from `sample_map` & `column_data` mismatch.\n  warn(\"'primary' from `sample_map` & `column_data` mismatch.\", UserWarning)\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/multiassayexperiment/MultiAssayExperiment.py:74: UserWarning: 'experiments' contains names not represented in 'sample_map' or vice-versa.\n  warn(\n\n\n\n\n\n\n\n\nNote\n\n\n\nIf you’re wondering about why the experiment “se” has 0 columns, it’s important to note that our MAE implementation does not remove columns from an experiment solely because none of the columns map to the samples of interest. This approach aims to prevent unexpected outcomes in complex subset operations.",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Multiple experiments</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/multiassay_expt.html#helper-functions",
    "href": "chapters/experiments/multiassay_expt.html#helper-functions",
    "title": "Multiple experiments",
    "section": "Helper functions",
    "text": "Helper functions\nThe MultiAssayExperiment class also provides a few methods for sample management.\n\nComplete cases\nThe complete_cases function is designed to identify samples that contain data across all experiments. It produces a boolean vector with the same length as the number of samples in column_data. Each element in the vector is True if the sample is present in all experiments, or False otherwise.\n\nprint(mae.complete_cases())\n\n[False, False]\n\n\nYou can use this boolean vector to select samples with complete data across all assays or experiments.\n\nsubset_mae = mae[:, mae.complete_cases(),]\nprint(subset_mae)\n\nclass: MultiAssayExperiment containing 2 experiments\n[0] sce: SingleCellExperiment with 200 rows and 0 columns \n[1] se: SummarizedExperiment with 200 rows and 0 columns \ncolumn_data columns(1): ['samples']\nsample_map columns(3): ['assay', 'primary', 'colname']\nmetadata(1): could be\n\n\n\n\n\nReplicates\nThis method identifies ‘samples’ with replicates within each experiment. The result is a dictionary where experiment names serve as keys, and the corresponding values indicate whether the sample is replicated within each experiment.\n\nfrom rich import print as pprint # mainly for pretty printing\npprint(mae.replicated())\n\n{\n    'sce': {\n        'unknown_sample_sce': [True, True, True, True, True, True],\n        'unknown_sample_se': [False, False, False, False, False, False]\n    },\n    'se': {\n        'unknown_sample_sce': [False, False, False, False, False, False],\n        'unknown_sample_se': [True, True, True, True, True, True]\n    }\n}\n\n\n\n\n\nIntersect rows\nThe intersect_rows finds common row_names across all experiments and returns a MultiAssayExperiment with those rows.\n\ncommon_rows_mae = mae.intersect_rows()\nprint(common_rows_mae)\n\nclass: MultiAssayExperiment containing 2 experiments\n[0] sce: SingleCellExperiment with 200 rows and 6 columns \n[1] se: SummarizedExperiment with 200 rows and 6 columns \ncolumn_data columns(1): ['samples']\nsample_map columns(3): ['assay', 'primary', 'colname']\nmetadata(1): could be\n\n\n\nIf you are only interested in finding common row_names across all experiments:\n\ncommon_rows = mae.find_common_row_names()\nprint(common_rows)\n\n{'61', '137', '167', '170', '34', '50', '133', '88', '180', '58', '17', '192', '30', '84', '154', '71', '20', '7', '65', '28', '157', '98', '3', '108', '97', '196', '81', '36', '169', '70', '76', '91', '31', '67', '161', '185', '119', '187', '18', '72', '94', '128', '63', '135', '59', '80', '166', '101', '148', '195', '182', '15', '86', '45', '40', '188', '171', '164', '32', '2', '100', '178', '193', '199', '120', '25', '41', '134', '127', '194', '69', '145', '66', '115', '37', '1', '29', '90', '55', '175', '24', '102', '183', '147', '68', '48', '156', '42', '104', '21', '124', '116', '130', '149', '53', '49', '14', '46', '144', '10', '54', '62', '93', '103', '96', '121', '136', '106', '95', '122', '52', '138', '113', '118', '64', '132', '44', '33', '56', '73', '146', '160', '12', '155', '22', '111', '89', '186', '114', '77', '16', '173', '39', '35', '26', '158', '143', '4', '19', '131', '140', '126', '189', '123', '9', '78', '153', '162', '151', '8', '87', '165', '112', '38', '85', '125', '139', '184', '197', '0', '172', '141', '191', '79', '83', '129', '99', '142', '181', '105', '174', '57', '177', '110', '190', '198', '43', '11', '27', '179', '150', '5', '176', '47', '168', '60', '159', '82', '75', '6', '117', '109', '107', '74', '23', '152', '163', '13', '92', '51'}\n\n\n\n\nEmpty MAE\nWhile the necessity of an empty MultiAssayExperiment might not be apparent, for the sake of consistency with the rest of the tutorials:\n\nmae = MultiAssayExperiment(experiments={})\nprint(mae)\n\nclass: MultiAssayExperiment containing 0 experiments\ncolumn_data columns(1): ['samples']\nsample_map columns(3): ['assay', 'primary', 'colname']\nmetadata(0):",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Multiple experiments</span>"
    ]
  },
  {
    "objectID": "chapters/experiments/multiassay_expt.html#further-reading",
    "href": "chapters/experiments/multiassay_expt.html#further-reading",
    "title": "Multiple experiments",
    "section": "Further reading",
    "text": "Further reading\n\nCheck out reference documentation for more details.\nR/Bioconductor’s MultiAssayExperiment package.",
    "crumbs": [
      "Represent experimental data",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Multiple experiments</span>"
    ]
  },
  {
    "objectID": "chapters/interop.html",
    "href": "chapters/interop.html",
    "title": "Interop with RDS files",
    "section": "",
    "text": "Installation\nTo get started, install the package from PyPI",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Interop with RDS files</span>"
    ]
  },
  {
    "objectID": "chapters/interop.html#installation",
    "href": "chapters/interop.html#installation",
    "title": "Interop with RDS files",
    "section": "",
    "text": "pip install multiassayexperiment",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Interop with RDS files</span>"
    ]
  },
  {
    "objectID": "chapters/interop.html#reading-rds-objects",
    "href": "chapters/interop.html#reading-rds-objects",
    "title": "Interop with RDS files",
    "section": "Reading RDS objects",
    "text": "Reading RDS objects\nReading an RDS file in Python involves a two-step process. First, we parse the serialized RDS into a readable Python object, typically a dictionary. This object contains both the data and relevant metadata about the structure and internal representation of the R object. Subsequently, we use one of the available functions to convert this object into a Python representation.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Interop with RDS files</span>"
    ]
  },
  {
    "objectID": "chapters/interop.html#step-0-save-an-rds-file",
    "href": "chapters/interop.html#step-0-save-an-rds-file",
    "title": "Interop with RDS files",
    "section": "Step 0: Save an RDS file",
    "text": "Step 0: Save an RDS file\nBefore we begin, let’s create a test dataset from R. In this example, we’ll download the “zeisel brain” dataset from the scRNAseq package. For tutorial purposes, we’ll filter the dataset to the first 1000 rows and save it as an RDS file.\nlibrary(scRNAseq)\nsce &lt;- ZeiselBrainData()\nsub &lt;- sce[1:1000,]\nsaveRDS(sub, \"../assets/data/zeisel-brain-subset.rds\")",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Interop with RDS files</span>"
    ]
  },
  {
    "objectID": "chapters/interop.html#step-1-parse-the-rds-file",
    "href": "chapters/interop.html#step-1-parse-the-rds-file",
    "title": "Interop with RDS files",
    "section": "Step 1: Parse the RDS file",
    "text": "Step 1: Parse the RDS file\nNow, we can read the RDS file in Python using the read_rds function, which parses the file contents and returns a dictionary of the R object.\n\nfrom rds2py import read_rds\n\nr_object = read_rds(\"../assets/data/zeisel-brain-subset.rds\")\n\nfrom rich import print as pprint\npprint(r_object) # hiding the response\n\n\n\n\n\n\n\nNote\n\n\n\nThe output of the above code block is hidden to maintain the cleanliness and visual appeal of this document :)\n\n\nOnce we have a realized structure, we can convert this object into useful Python representations. It contains two keys: - data: If atomic entities, contains the NumPy view of the memory space. - attributes: Additional properties available for the object.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Interop with RDS files</span>"
    ]
  },
  {
    "objectID": "chapters/interop.html#step-2-conversion-to-python-representations",
    "href": "chapters/interop.html#step-2-conversion-to-python-representations",
    "title": "Interop with RDS files",
    "section": "Step 2: Conversion to Python representations",
    "text": "Step 2: Conversion to Python representations\nThe package provides functions to convert these R objects into useful Python representations.\n\nfrom rds2py import as_summarized_experiment\n\n# to convert an robject to SCE\nsce = as_summarized_experiment(r_object)\n\nprint(sce)\n\nclass: SingleCellExperiment\ndimensions: (1000, 3005)\nassays(1): ['counts']\nrow_data columns(1): ['featureType']\nrow_names(1000): ['0', '1', '2', ..., '997', '998', '999']\ncolumn_data columns(10): ['tissue', 'group #', 'total mRNA mol', 'well', 'sex', 'age', 'diameter', 'cell_id', 'level1class', 'level2class']\ncolumn_names(3005): ['1772071015_C02', '1772071017_G12', '1772071017_A05', ..., '1772063068_D01', '1772066098_A12', '1772058148_F03']\nmain_experiment_name:  \nreduced_dims(0): []\nalternative_experiments(2): ['ERCC', 'repeat']\nrow_pairs(0): []\ncolumn_pairs(0): []\nmetadata(0): \n\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/genomicranges/SeqInfo.py:348: UserWarning: 'seqnames' is deprecated, use 'get_seqnames' instead\n  warn(\"'seqnames' is deprecated, use 'get_seqnames' instead\", UserWarning)\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/genomicranges/SeqInfo.py:348: UserWarning: 'seqnames' is deprecated, use 'get_seqnames' instead\n  warn(\"'seqnames' is deprecated, use 'get_seqnames' instead\", UserWarning)\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/genomicranges/SeqInfo.py:348: UserWarning: 'seqnames' is deprecated, use 'get_seqnames' instead\n  warn(\"'seqnames' is deprecated, use 'get_seqnames' instead\", UserWarning)\n\n\nAnd that’s it! It’s as straightforward as that. The as_summarized_experiment function serves as an example of how to convert complex R structures into Python representations. Similarly, the package offers parsers for atomic vectors, lists, sparse/dense matrices, data frames, and most R data structures.\nYou can continue to convert this object into AnnData representation and perform analysis. For more details on SingleCellExperiment, refer to the documentation here.\n\nsce.to_anndata()\n\n(AnnData object with n_obs × n_vars = 3005 × 1000\n     obs: 'tissue', 'group #', 'total mRNA mol', 'well', 'sex', 'age', 'diameter', 'cell_id', 'level1class', 'level2class'\n     var: 'featureType'\n     layers: 'counts',\n None)\n\n\nWell, that’s all. Dive in, explore, and create more base representations to encapsulate complex R structures. If you wish to add more representations, we are more than happy to accept contributions.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Interop with RDS files</span>"
    ]
  },
  {
    "objectID": "chapters/language_agnostic.html",
    "href": "chapters/language_agnostic.html",
    "title": "Language-agnostic genomic data store",
    "section": "",
    "text": "In this section, we will illustrate a workflow that utilizes language-agnostic representations for storing genomic data, facilitating seamless access to datasets and analysis results across multiple programming frameworks such as R and Python. The ArtifactDB framework provides this functionality.\nTo begin, we will download the “zilionis lung” dataset from the scRNAseq package. Subsequently, we will store this dataset in a language-agnostic format using the alabaster suite of R packages.\nlibrary(scRNAseq)\nlibrary(alabaster)\n\nsce &lt;- ZilionisLungData()\nsaveObject(sce, path=paste(getwd(), \"zilinoislung\", sep=\"/\"))\n\n\n\n\n\n\nNote\n\n\n\nAdditionally, you can save this dataset as an RDS object for access in Python. Refer to interop with R section for more details.\n\n\nWe can now load this dataset in Python using the dolomite suite of Python packages. Both dolomite and alabaster are integral parts of the ArtifactDB ecosystem designed to read artifacts stored in language-agnostic formats.\nfrom dolomite_base import read_object\n\ndata = read_object(\"./zilinoislung\")\nprint(data)\nYou can now convert this to AnnData representations for downstream analysis.\nadata = data.to_anndata()\n\n\n\n\n\n\nNote\n\n\n\nCheck out ArtifactDB framework for more information.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Language-agnostic genomic data store</span>"
    ]
  },
  {
    "objectID": "chapters/workflow.html",
    "href": "chapters/workflow.html",
    "title": "Seamless analysis workflow",
    "section": "",
    "text": "Further reading",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Seamless analysis workflow</span>"
    ]
  },
  {
    "objectID": "chapters/workflow.html#further-reading",
    "href": "chapters/workflow.html#further-reading",
    "title": "Seamless analysis workflow",
    "section": "",
    "text": "ArtifactDB GitHub organization - https://github.com/ArtifactDB.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Seamless analysis workflow</span>"
    ]
  },
  {
    "objectID": "chapters/extras/iranges.html",
    "href": "chapters/extras/iranges.html",
    "title": "IRanges: Interval arithmetic",
    "section": "",
    "text": "Installation\nTo get started, install the package from PyPI",
    "crumbs": [
      "Additional packages",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>`IRanges`: Interval arithmetic</span>"
    ]
  },
  {
    "objectID": "chapters/extras/iranges.html#sec-iranges",
    "href": "chapters/extras/iranges.html#sec-iranges",
    "title": "IRanges: Interval arithmetic",
    "section": "",
    "text": "pip install iranges\n\n\n\n\n\n\nNote\n\n\n\nThe descriptions for some of these methods come from the Bioconductor documentation.",
    "crumbs": [
      "Additional packages",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>`IRanges`: Interval arithmetic</span>"
    ]
  },
  {
    "objectID": "chapters/extras/iranges.html#construction",
    "href": "chapters/extras/iranges.html#construction",
    "title": "IRanges: Interval arithmetic",
    "section": "Construction",
    "text": "Construction\nAn IRanges holds a start position and a width, and is most typically used to represent coordinates along some genomic sequence. The interpretation of the start position depends on the application; for sequences, the start is usually a 1-based position, but other use cases may allow zero or even negative values (e.g. circular genomes).\n\nfrom iranges import IRanges\n\nstarts = [-2, 6, 9, -4, 1, 0, -6, 10]\nwidths = [5, 0, 6, 1, 4, 3, 2, 3]\nir = IRanges(starts, widths)\n\nprint(ir)\n\nIRanges object with 8 ranges and 0 metadata columns\n               start              end            width\n    &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt;\n[0]               -2                3                5\n[1]                6                6                0\n[2]                9               15                6\n[3]               -4               -3                1\n[4]                1                5                4\n[5]                0                3                3\n[6]               -6               -4                2\n[7]               10               13                3",
    "crumbs": [
      "Additional packages",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>`IRanges`: Interval arithmetic</span>"
    ]
  },
  {
    "objectID": "chapters/extras/iranges.html#accessing-properties",
    "href": "chapters/extras/iranges.html#accessing-properties",
    "title": "IRanges: Interval arithmetic",
    "section": "Accessing properties",
    "text": "Accessing properties\nProperties can be accessed directly from the object:\n\nprint(\"Number of intervals:\", len(ir))\n\nprint(\"start positions:\", ir.get_start())\nprint(\"width of each interval:\", ir.get_width())\nprint(\"end positions:\", ir.get_end())\n\nNumber of intervals: 8\nstart positions: [-2  6  9 -4  1  0 -6 10]\nwidth of each interval: [5 0 6 1 4 3 2 3]\nend positions: [ 3  6 15 -3  5  3 -4 13]\n\n\n\n\n\n\n\n\nTip\n\n\n\nJust like BiocFrame, these classes offer both functional-style and property-based getters and setters.\n\n\n\nprint(\"start positions:\", ir.start)\nprint(\"width of each interval:\", ir.width)\nprint(\"end positions:\", ir.end)\n\nstart positions: [-2  6  9 -4  1  0 -6 10]\nwidth of each interval: [5 0 6 1 4 3 2 3]\nend positions: [ 3  6 15 -3  5  3 -4 13]",
    "crumbs": [
      "Additional packages",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>`IRanges`: Interval arithmetic</span>"
    ]
  },
  {
    "objectID": "chapters/extras/iranges.html#reduced-ranges-normality",
    "href": "chapters/extras/iranges.html#reduced-ranges-normality",
    "title": "IRanges: Interval arithmetic",
    "section": "Reduced ranges (Normality)",
    "text": "Reduced ranges (Normality)\nreduce method reduces the intervals to an IRanges where the intervals are:\n\nnot empty\nnot overlapping\nordered from left to right\nnot even adjacent (i.e. there must be a non empty gap between 2 consecutive ranges).\n\n\nreduced = ir.reduce()\nprint(reduced)\n\nIRanges object with 4 ranges and 0 metadata columns\n               start              end            width\n    &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt;\n[0]               -6               -3                3\n[1]               -2                5                7\n[2]                6                6                0\n[3]                9               15                6",
    "crumbs": [
      "Additional packages",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>`IRanges`: Interval arithmetic</span>"
    ]
  },
  {
    "objectID": "chapters/extras/iranges.html#overlap-operations",
    "href": "chapters/extras/iranges.html#overlap-operations",
    "title": "IRanges: Interval arithmetic",
    "section": "Overlap operations",
    "text": "Overlap operations\nIRanges uses nested containment lists under the hood to perform fast overlap and search-based operations.\n\nsubject = IRanges([2, 2, 10], [1, 2, 3])\nquery = IRanges([1, 4, 9], [5, 4, 2])\n\noverlap = subject.find_overlaps(query)\nprint(overlap)\n\n[[1, 0], [], [2]]\n\n\n\nFinding neighboring ranges\nThe nearest, precede or follow methods finds the nearest overlapping range along the specified direction.\n\nquery = IRanges([1, 3, 9], [2, 5, 2])\nsubject = IRanges([3, 5, 12], [1, 2, 1])\n\nnearest = subject.nearest(query, select=\"all\")\nprint(nearest)\n\n[[0], [0, 1], [2]]\n\n\n\n\n\n\n\n\nNote\n\n\n\nThese methods typically return a list of indices from subject for each interval in query.\n\n\n\n\ncoverage\nThe coverage method counts the number of overlaps for each position.\n\ncov = subject.coverage()\nprint(cov)\n\n[0 0 1 0 1 1 0 0 0 0 0 1]",
    "crumbs": [
      "Additional packages",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>`IRanges`: Interval arithmetic</span>"
    ]
  },
  {
    "objectID": "chapters/extras/iranges.html#transforming-ranges",
    "href": "chapters/extras/iranges.html#transforming-ranges",
    "title": "IRanges: Interval arithmetic",
    "section": "Transforming ranges",
    "text": "Transforming ranges\nshift adjusts the start positions by their shift.\n\nshifted = ir.shift(shift=10)\nprint(shifted)\n\nIRanges object with 8 ranges and 0 metadata columns\n               start              end            width\n    &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt;\n[0]                8               13                5\n[1]               16               16                0\n[2]               19               25                6\n[3]                6                7                1\n[4]               11               15                4\n[5]               10               13                3\n[6]                4                6                2\n[7]               20               23                3\n\n\nOther range transformation methods include narrow, resize, flank, reflect and restrict. For example narrow supports the adjustment of start, end and width values, which should be relative to each range.\n\nnarrowed = ir.narrow(start=4, width=2)\nprint(narrowed)\n\nIRanges object with 8 ranges and 0 metadata columns\n               start              end            width\n    &lt;ndarray[int64]&gt; &lt;ndarray[int64]&gt; &lt;ndarray[int64]&gt;\n[0]                1                3                2\n[1]                9               11                2\n[2]               12               14                2\n[3]               -1                1                2\n[4]                4                6                2\n[5]                3                5                2\n[6]               -3               -1                2\n[7]               13               15                2\n\n\n\nDisjoin intervals\nWell as the name says, computes disjoint intervals.\n\ndisjoint = ir.disjoin()\nprint(disjoint)\n\nIRanges object with 9 ranges and 0 metadata columns\n               start              end            width\n    &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt;\n[0]               -6               -4                2\n[1]               -4               -3                1\n[2]               -2                0                2\n[3]                0                1                1\n[4]                1                3                2\n[5]                3                5                2\n[6]                9               10                1\n[7]               10               13                3\n[8]               13               15                2\n\n\n\n\nreflect and flank\nreflect reverses each range within a set of common reference bounds.\n\nstarts = [2, 5, 1]\nwidths = [2, 3, 3]\nx = IRanges(starts, widths)\nbounds = IRanges([0, 5, 3], [11, 2, 7])\n\nres = x.reflect(bounds=bounds)\nprint(res)\n\nIRanges object with 3 ranges and 0 metadata columns\n               start              end            width\n    &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt;\n[0]                7                9                2\n[1]                4                7                3\n[2]                9               12                3\n\n\nflank returns ranges of a specified width that flank, to the left (default) or right, each input range. One use case of this is forming promoter regions for a set of genes.\n\nstarts = [2, 5, 1]\nwidths = [2, 3, 3]\nx = IRanges(starts, widths)\n\nres = x.flank(2, start=False)\nprint(res)\n\nIRanges object with 3 ranges and 0 metadata columns\n               start                end              width\n    &lt;ndarray[int32]&gt; &lt;ndarray[float64]&gt; &lt;ndarray[float64]&gt;\n[0]                4                6.0                2.0\n[1]                8               10.0                2.0\n[2]                4                6.0                2.0",
    "crumbs": [
      "Additional packages",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>`IRanges`: Interval arithmetic</span>"
    ]
  },
  {
    "objectID": "chapters/extras/iranges.html#set-operations",
    "href": "chapters/extras/iranges.html#set-operations",
    "title": "IRanges: Interval arithmetic",
    "section": "Set operations",
    "text": "Set operations\nIRanges supports most interval set operations. For example, to compute gaps:\n\ngaps = ir.gaps()\nprint(gaps)\n\nIRanges object with 2 ranges and 0 metadata columns\n               start              end            width\n    &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt;\n[0]               -3               -2                1\n[1]                5                9                4\n\n\nOr Perform interval set operations, e..g union, intersection, disjoin:\n\nx = IRanges([1, 5, -2, 0, 14], [10, 5, 6, 12, 4])\ny = IRanges([14, 0, -5, 6, 18], [7, 3, 8, 3, 3])\n\nintersection = x.intersect(y)\nprint(intersection)\n\nIRanges object with 3 ranges and 0 metadata columns\n               start              end            width\n    &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt;\n[0]               -2                3                5\n[1]                6                9                3\n[2]               14               18                4",
    "crumbs": [
      "Additional packages",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>`IRanges`: Interval arithmetic</span>"
    ]
  },
  {
    "objectID": "chapters/extras/iranges.html#further-reading",
    "href": "chapters/extras/iranges.html#further-reading",
    "title": "IRanges: Interval arithmetic",
    "section": "Further reading",
    "text": "Further reading\n\nIRanges reference\nBioc/IRanges",
    "crumbs": [
      "Additional packages",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>`IRanges`: Interval arithmetic</span>"
    ]
  },
  {
    "objectID": "chapters/philosophy.html",
    "href": "chapters/philosophy.html",
    "title": "Programming philosophy",
    "section": "",
    "text": "Class design\nOur objective is to provide a consistent user experience in Python for each Bioconductor class. In most cases, this is achieved by directly re-implementing the class and its associated methods in Python. Occasionally, there are cases where the Bioconductor implementation has historical idiosyncrasies that lead to unintuitive user experience e.g., the storage of rowData in a RangedSummarizedExperiment, MultiAssayExperiment harmonization; developers should use their own discretion to decide whether replicating this behavior in Python is necessary.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Programming philosophy</span>"
    ]
  },
  {
    "objectID": "chapters/philosophy.html#naming",
    "href": "chapters/philosophy.html#naming",
    "title": "Programming philosophy",
    "section": "Naming",
    "text": "Naming\nWe highly recommend adhering to Google’s Python style guide for consistency in naming conventions. In summary, classes should use PascalCase and follow Bioconductor’s class names. Methods should use snake_case and take the form of &lt;verb&gt;[_&lt;details&gt;], such as get_start(), set_names() and so forth. Method arguments should also follow the snake_case format.\nUsability has been another crucial objective, to facilitate an easy transition for users between R and Python classes. For instance, when computing flanking regions in R:\nflank(gr, width=2, start=FALSE, both=TRUE)\nIn the GenomicRanges Python packages, we maintain consistency by expecting the same method name. The only difference lies in the shift from a functional to an object-oriented programming paradigm:\ngr.flank(width=2, start=False, both=True)",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Programming philosophy</span>"
    ]
  },
  {
    "objectID": "chapters/philosophy.html#sec-functional",
    "href": "chapters/philosophy.html#sec-functional",
    "title": "Programming philosophy",
    "section": "Functional discipline",
    "text": "Functional discipline\nThe existence of mutable types in Python introduces the potential for inadvertently modifying complex objects. Generally, users lack knowledge about whether an object (or their reference to it) serves as a component of another object, such as a BiocFrame set as column_data in a SummarizedExperiment. Any user modifications to an instance of a mutable type may unexpectedly impact all objects containing that instance.\nTo address these issues, we recommend adopting a functional programming paradigm in all class methods. By default, methods should refrain from causing side effects that mutate the object. This simplifies reasoning about the effects of methods and mutations in large, complex objects.\n\nSetter methods\nThe most notable application of this philosophy is in setter methods. Instead of directly mutating the object, these methods should return a new copy of the object with the desired modification. The “depth” of the copy is left to the discretion of the developer. For example, some methods may choose to use a shallow copy for efficiency. The only requirement is to avoid any modification to the contents in self. While implementations may offer an in_place= option to modify the original object, this should default to False.\n\n\nGetter methods\nThe return value of a getter method should remain unaltered to avoid potential mutations in self. For getters that return mutable types, developers should document that the return value is read-only. This aims to discourage users from unintentionally modifying self by mutating the return value. (Note that functional style setters can still be applied - they are compatible with a read-only philosophy since they do not actually modify the object.) Developers may also choose to return a copy that can be more freely modified, depending on the depth of the copy, users should refer to the relevant method’s documentation.\n\n\nProperty-based getters and setters\nDirect access to class members (via properties or @property decorator) should generally be avoided, as it mutates the object in-place. This could lead to unexpected side effects as previously discussed. Nevertheless, developers may provide these methods for compatibility purposes.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Programming philosophy</span>"
    ]
  },
  {
    "objectID": "chapters/philosophy.html#type-hints",
    "href": "chapters/philosophy.html#type-hints",
    "title": "Programming philosophy",
    "section": "Type hints",
    "text": "Type hints\nAs the term suggests, type hints serve as “hints” to enhance the developer experience, and they should not dictate how we write our code.\nFor this reason, we prefer for using simple types in these hints, typically corresponding to base Python types with minimal nesting. For example, if a function is expected to operate on any arbitrary list, the basic list type hint should suffice.\ndef find_element(arr: list, query: int)\n    pass\nIf the function expects a list of strings:\nfrom typing import List\n\ndef find_element(arr: List[str], query: str):\n    pass\nIn cases where the function accepts multiple types as inputs:\nfrom typing import Union\n\ndef find_element(arr: List[str], query: Union[int, str, slice]):\n    pass",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Programming philosophy</span>"
    ]
  },
  {
    "objectID": "chapters/philosophy.html#notes",
    "href": "chapters/philosophy.html#notes",
    "title": "Programming philosophy",
    "section": "Notes",
    "text": "Notes\nAdditionally, we provide recommendations on setting up the package using PyScaffold, different testing environments, documentation, and publishing workflows. These details can be found in the developer guide.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Programming philosophy</span>"
    ]
  },
  {
    "objectID": "chapters/summary.html",
    "href": "chapters/summary.html",
    "title": "Summary",
    "section": "",
    "text": "Core contributors",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Summary</span>"
    ]
  },
  {
    "objectID": "chapters/summary.html#logo",
    "href": "chapters/summary.html#logo",
    "title": "Summary",
    "section": "Logo",
    "text": "Logo\nThis is truly a work of art from Aaron Lun:",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Summary</span>"
    ]
  },
  {
    "objectID": "chapters/sessioninfo.html",
    "href": "chapters/sessioninfo.html",
    "title": "Reproduce me!",
    "section": "",
    "text": "Pre-requisites\nimport sys\nimport subprocess\n\nfrom rich import print",
    "crumbs": [
      "Reproduce me!"
    ]
  },
  {
    "objectID": "chapters/sessioninfo.html#python",
    "href": "chapters/sessioninfo.html#python",
    "title": "Reproduce me!",
    "section": "Python",
    "text": "Python\nLets make sure we have all packages we need for this section\n\nsys.version_info\n\nsys.version_info(major=3, minor=9, micro=18, releaselevel='final', serial=0)",
    "crumbs": [
      "Reproduce me!"
    ]
  },
  {
    "objectID": "chapters/sessioninfo.html#packages",
    "href": "chapters/sessioninfo.html#packages",
    "title": "Reproduce me!",
    "section": "Packages",
    "text": "Packages\n\nimport math\n\nimport biocframe\nimport biocutils\nimport genomicranges\nimport summarizedexperiment\nimport singlecellexperiment\nimport multiassayexperiment\nimport rds2py\nimport session_info\n\n\nsession_info.show()\n\n\nClick to view session information\n-----\nbiocframe                   0.5.9\nbiocutils                   0.1.5\ngenomicranges               0.4.12\nmultiassayexperiment        0.4.2\nrds2py                      0.4.2\nrich                        NA\nsession_info                1.0.0\nsinglecellexperiment        0.4.4\nsummarizedexperiment        0.4.3\n-----\n\n\nClick to view modules imported as dependencies\nPIL                         10.2.0\nanyio                       NA\narrow                       1.3.0\nasttokens                   NA\nattr                        23.2.0\nattrs                       23.2.0\nbabel                       2.14.0\ncertifi                     2024.02.02\ncffi                        1.16.0\ncharset_normalizer          3.3.2\ncomm                        0.2.1\ncycler                      0.12.1\ncython_runtime              NA\ndateutil                    2.8.2\ndebugpy                     1.8.1\ndecorator                   5.1.1\ndefusedxml                  0.7.1\nexceptiongroup              1.2.0\nexecuting                   2.0.1\nfastjsonschema              NA\nfqdn                        NA\nidna                        3.6\nimportlib_metadata          NA\nimportlib_resources         NA\nipykernel                   6.29.2\niranges                     0.2.3\nisoduration                 NA\njedi                        0.19.1\njinja2                      3.1.3\njson5                       NA\njsonpointer                 2.4\njsonschema                  4.21.1\njsonschema_specifications   NA\njupyter_events              0.9.0\njupyter_server              2.12.5\njupyterlab_server           2.25.3\nkiwisolver                  1.4.5\nmarkupsafe                  2.1.5\nmatplotlib                  3.8.3\nmatplotlib_inline           0.1.6\nmpl_toolkits                NA\nnbformat                    5.9.2\nnumpy                       1.26.4\noverrides                   NA\npackaging                   23.2\npandas                      2.2.1\nparso                       0.8.3\npexpect                     4.9.0\nplatformdirs                4.2.0\nprometheus_client           NA\nprompt_toolkit              3.0.43\npsutil                      5.9.8\nptyprocess                  0.7.0\npure_eval                   0.2.2\npydev_ipython               NA\npydevconsole                NA\npydevd                      2.9.5\npydevd_file_utils           NA\npydevd_plugins              NA\npydevd_tracing              NA\npygments                    2.17.2\npyparsing                   3.1.1\npythonjsonlogger            NA\npytz                        2024.1\nreferencing                 NA\nrequests                    2.31.0\nrfc3339_validator           0.1.4\nrfc3986_validator           0.1.1\nrpds                        NA\nscipy                       1.12.0\nsend2trash                  NA\nsix                         1.16.0\nsniffio                     1.3.0\nstack_data                  0.6.3\ntornado                     6.4\ntraitlets                   5.14.1\ntyping_extensions           NA\nuri_template                NA\nurllib3                     2.2.1\nwcwidth                     0.2.13\nwebcolors                   1.13\nwebsocket                   1.7.0\nyaml                        6.0.1\nzipp                        NA\nzmq                         25.1.2\nzoneinfo                    NA\n\n \n-----\nIPython             8.18.1\njupyter_client      8.6.0\njupyter_core        5.7.1\njupyterlab          4.1.2\nnotebook            7.1.0\n-----\nPython 3.9.18 (main, Aug 28 2023, 08:38:32) [GCC 11.4.0]\nLinux-6.2.0-1019-azure-x86_64-with-glibc2.35\n-----\nSession information updated at 2024-02-24 18:44",
    "crumbs": [
      "Reproduce me!"
    ]
  }
]