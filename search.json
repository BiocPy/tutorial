[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BiocPy: Enabling Bioconductor workflows in Python",
    "section": "",
    "text": "Welcome\nBiocPy is an effort to bring core data structures and representations from Bioconductor to Python.\n\n\nPackages in BiocPy\nCurrently, the following core representations are implemented in Python\n\nBiocUtils (GitHub, Docs): Common utilities for use across packages, mostly to mimic convenient aspects of base R.\nBiocFrame (GitHub, Docs): Bioconductor-like dataframes in Python.\nIRanges (GitHub, Docs): Python implementation of the IRanges package to support interval arithmetic.\nGenomicRanges (GitHub, Docs, BioC): Container class to represent genomic locations and support genomic analysis. Similar to Bioconductor’s GenomicRanges.\nSummarizedExperiment (GitHub, Docs, BioC): Container class to represent genomic experiments, following Bioconductor’s SummarizedExperiment.\nSingleCellExperiment (GitHub, Docs, BioC): Container class to represent single-cell experiments; follows Bioconductor’s SingleCellExperiment.\nMultiAssayExperiment (GitHub, Docs, BioC): Container class to represent multiple experiments and assays performed over a set of samples. follows Bioconductor’s MAE R/Bioc Package.\n\nAnalysis packages\n\nscranpy(GitHub, Docs): Python bindings to the single-cell analysis methods from libscran and related C++ libraries.\nsingler(GitHub, Docs): Python bindings to the singleR algorithm to annotate cell types from known references.\n\nUtility packages\n\nrds2py (GitHub, Docs): Parse, extract and create Python representations for datasets stored in RDS files. Currently supports Bioconductor’s SummarizedExperiment and SingleCellExperiment objects.\nmopsy (GitHub, Docs): Convenience library to perform row/column operations over numpy and scipy matrices. Provides an interface similar to base R matrix methods/MatrixStats methods.\npyBiocFileCache (GitHub, Docs, BioC): File system based cache for resources & metadata.\n\nThis book will focus on end user tutorials as develop more packages and integrations.\n\n\nNotes\nThis is a Quarto book and contains reusable snippets. To learn more about Quarto books visit https://quarto.org/docs/books."
  },
  {
    "objectID": "chapters/intro.html",
    "href": "chapters/intro.html",
    "title": "Installation",
    "section": "",
    "text": "All packages in the BiocPy ecosystem are published to Python’s Package Index - PyPI.\nbiocpy is a wrapper package that install all core packages in the ecosystem.\npip install biocpy\nOR install packages as needed. e.g.\npip install summarizedexperiment # &lt;package-name&gt;\n\nUpdate packages\npip install -U biocpy # or &lt;package-name&gt;\n\n\n\n\n\n\nNote\n\n\n\nCheckout documentation to install individual packages - packages in BiocPy."
  },
  {
    "objectID": "chapters/biocframe/index.html#installation",
    "href": "chapters/biocframe/index.html#installation",
    "title": "BiocFrame - Bioconductor-like data frames",
    "section": "Installation",
    "text": "Installation\nPackage is published to PyPI\npip install biocframe"
  },
  {
    "objectID": "chapters/biocframe/index.html#further-reading",
    "href": "chapters/biocframe/index.html#further-reading",
    "title": "BiocFrame - Bioconductor-like data frames",
    "section": "Further reading",
    "text": "Further reading\nCheck out the reference documentation for more details.\nAlso see check out Bioconductor’s S4Vectors package, which implements the DFrame class on which BiocFrame was based."
  },
  {
    "objectID": "chapters/biocframe/intro.html#construction",
    "href": "chapters/biocframe/intro.html#construction",
    "title": "1  Overview",
    "section": "1.1 Construction",
    "text": "1.1 Construction\nTo construct a BiocFrame object, simply provide the data as a dictionary.\n\nfrom biocframe import BiocFrame\n\nobj = {\n    \"ensembl\": [\"ENS00001\", \"ENS00002\", \"ENS00003\"],\n    \"symbol\": [\"MAP1A\", \"BIN1\", \"ESR1\"],\n}\nbframe = BiocFrame(obj)\nprint(bframe)\n\nBiocFrame with 3 rows and 2 columns\n     ensembl symbol\n      &lt;list&gt; &lt;list&gt;\n[0] ENS00001  MAP1A\n[1] ENS00002   BIN1\n[2] ENS00003   ESR1\n\n\n\n\n\n\n\n\nTip\n\n\n\nYou can specify complex objects as columns, as long as they have some “length” equal to the number of rows. For example, we can nest a BiocFrame inside another BiocFrame:\n\n\n\nobj = {\n    \"ensembl\": [\"ENS00001\", \"ENS00002\", \"ENS00002\"],\n    \"symbol\": [\"MAP1A\", \"BIN1\", \"ESR1\"],\n    \"ranges\": BiocFrame({\n        \"chr\": [\"chr1\", \"chr2\", \"chr3\"],\n        \"start\": [1000, 1100, 5000],\n        \"end\": [1100, 4000, 5500]\n    }),\n}\n\nbframe2 = BiocFrame(obj, row_names=[\"row1\", \"row2\", \"row3\"])\nprint(bframe2)\n\nBiocFrame with 3 rows and 3 columns\n      ensembl symbol         ranges\n       &lt;list&gt; &lt;list&gt;    &lt;BiocFrame&gt;\nrow1 ENS00001  MAP1A chr1:1000:1100\nrow2 ENS00002   BIN1 chr2:1100:4000\nrow3 ENS00002   ESR1 chr3:5000:5500"
  },
  {
    "objectID": "chapters/biocframe/intro.html#extracting-data",
    "href": "chapters/biocframe/intro.html#extracting-data",
    "title": "1  Overview",
    "section": "1.2 Extracting data",
    "text": "1.2 Extracting data\nProperties can be accessed directly from the object:\n\nprint(\"shape:\", bframe.shape)\n\nprint(\"column names (functional style):\", bframe.get_column_names())\n\nprint(\"column names (as property):\", bframe.column_names) # same as above\n\nshape: (3, 2)\ncolumn names (functional style): ['ensembl', 'symbol']\ncolumn names (as property): ['ensembl', 'symbol']\n\n\nWe can fetch individual columns:\n\nprint(\"functional style:\", bframe.get_column(\"ensembl\"))\n\nprint(\"w/ accessor\", bframe[\"ensembl\"])\n\nfunctional style: ['ENS00001', 'ENS00002', 'ENS00003']\nw/ accessor ['ENS00001', 'ENS00002', 'ENS00003']\n\n\nAnd we can get individual rows as a dictionary:\n\nbframe.get_row(2)\n\n{'ensembl': 'ENS00003', 'symbol': 'ESR1'}\n\n\n\n\n\n\n\n\nImportant\n\n\n\nTo extract a subset of the data in the BiocFrame, we use the subset ([]) operator. This accepts different subsetting arguments like a boolean vector, a slice object, a sequence of indices, or row/column names.\n\n\n\nsliced_with_bools = bframe[1:2, [True, False, False]]\nprint(\"Subset using booleans: \\n\", sliced_with_bools)\n\nsliced_with_names = bframe[[0,2], [\"symbol\", \"ensembl\"]]\nprint(\"\\nSubset using column names: \\n\", sliced_with_names)\n\n# Short-hand to get a single column:\nprint(\"\\nShort-hand to get a single column: \\n\", bframe[\"ensembl\"])\n\nSubset using booleans: \n BiocFrame with 1 row and 1 column\n     ensembl\n      &lt;list&gt;\n[0] ENS00002\n\nSubset using column names: \n BiocFrame with 2 rows and 2 columns\n    symbol  ensembl\n    &lt;list&gt;   &lt;list&gt;\n[0]  MAP1A ENS00001\n[1]   ESR1 ENS00003\n\nShort-hand to get a single column: \n ['ENS00001', 'ENS00002', 'ENS00003']"
  },
  {
    "objectID": "chapters/biocframe/intro.html#setting-data",
    "href": "chapters/biocframe/intro.html#setting-data",
    "title": "1  Overview",
    "section": "1.3 Setting data",
    "text": "1.3 Setting data\n\n1.3.1 Preferred approach\nTo set BiocFrame properties, we encourage a functional style of programming that avoids mutating the object. This avoids inadvertent modification of BiocFrames that are part of larger data structures.\n\nmodified = bframe.set_column_names([\"column1\", \"column2\"])\nprint(modified)\n\nBiocFrame with 3 rows and 2 columns\n     column1 column2\n      &lt;list&gt;  &lt;list&gt;\n[0] ENS00001   MAP1A\n[1] ENS00002    BIN1\n[2] ENS00003    ESR1\n\n\nNow lets check the column names of the original object,\n\n# Original is unchanged:\nprint(bframe.get_column_names())\n\n['ensembl', 'symbol']\n\n\nTo add new columns, or replace existing columns:\n\nmodified = bframe.set_column(\"symbol\", [\"A\", \"B\", \"C\"])\nprint(modified)\n\nmodified = bframe.set_column(\"new_col_name\", range(2, 5))\nprint(modified)\n\nBiocFrame with 3 rows and 2 columns\n     ensembl symbol\n      &lt;list&gt; &lt;list&gt;\n[0] ENS00001      A\n[1] ENS00002      B\n[2] ENS00003      C\nBiocFrame with 3 rows and 3 columns\n     ensembl symbol new_col_name\n      &lt;list&gt; &lt;list&gt;      &lt;range&gt;\n[0] ENS00001  MAP1A            2\n[1] ENS00002   BIN1            3\n[2] ENS00003   ESR1            4\n\n\nChange the row or column names:\n\n\n\n\n\n\nNote\n\n\n\nThe functional style allows you to chain multiple operations as in the example below.\n\n\n\nmodified = bframe.\\\n    set_column_names([\"FOO\", \"BAR\"]).\\\n    set_row_names(['alpha', 'bravo', 'charlie'])\nprint(modified)\n\nBiocFrame with 3 rows and 2 columns\n             FOO    BAR\n          &lt;list&gt; &lt;list&gt;\n  alpha ENS00001  MAP1A\n  bravo ENS00002   BIN1\ncharlie ENS00003   ESR1\n\n\nWe also support Bioconductor’s metadata concepts, either along the columns or for the entire object:\n\nmodified = bframe.\\\n    set_metadata({ \"author\": \"Jayaram Kancherla\" }).\\\n    set_column_data(BiocFrame({\"column_source\": [\"Ensembl\", \"HGNC\" ]}))\nprint(modified)\n\nBiocFrame with 3 rows and 2 columns\n     ensembl symbol\n      &lt;list&gt; &lt;list&gt;\n[0] ENS00001  MAP1A\n[1] ENS00002   BIN1\n[2] ENS00003   ESR1\n------\ncolumn_data(1): column_source\nmetadata(1): author\n\n\n\n\n1.3.2 The other way\nProperties can also be set by direct assignment for in-place modification. We prefer not to do it this way as it can silently mutate BiocFrame instances inside other data structures. Nonetheless:\n\ntestframe = BiocFrame({ \"A\": [1,2,3], \"B\": [4,5,6] })\ntestframe.column_names = [\"column1\", \"column2\" ]\nprint(testframe)\n\nBiocFrame with 3 rows and 2 columns\n    column1 column2\n     &lt;list&gt;  &lt;list&gt;\n[0]       1       4\n[1]       2       5\n[2]       3       6\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/biocframe/BiocFrame.py:466: UserWarning: Setting property 'column_names' is an in-place operation, use 'set_column_names' instead\n  warn(\n\n\n\n\n\n\n\n\nCaution\n\n\n\nWarnings are raised when properties are directly mutated. These assignments are the same as calling the corresponding set_*() methods with in_place = True. It is best to do this only if the BiocFrame object is not being used anywhere else; otherwise, it is safer to just create a (shallow) copy via the default in_place = False.\n\n\nSimilarly, we could set or replace columns directly:\n\ntestframe[\"column2\"] = [\"A\", \"B\", \"C\"]\ntestframe[1:3, [\"column1\",\"column2\"]] = BiocFrame({\"x\":[4, 5], \"y\":[\"E\", \"F\"]})\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/biocframe/BiocFrame.py:819: UserWarning: This method performs an in-place operation, use 'set_column' instead\n  warn(\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/biocframe/BiocFrame.py:813: UserWarning: This method performs an in-place operation, use 'set_slice' instead\n  warn("
  },
  {
    "objectID": "chapters/biocframe/intro.html#combining-objects",
    "href": "chapters/biocframe/intro.html#combining-objects",
    "title": "1  Overview",
    "section": "1.4 Combining objects",
    "text": "1.4 Combining objects\nBiocFrame implements methods for the various combine generics from BiocUtils. So, for example, to combine by row:\n\nimport biocutils\n\nbframe1 = BiocFrame({\n    \"odd\": [1, 3, 5, 7, 9],\n    \"even\": [0, 2, 4, 6, 8],\n})\n\nbframe2 = BiocFrame({\n    \"odd\": [11, 33, 55, 77, 99],\n    \"even\": [0, 22, 44, 66, 88],\n})\n\ncombined = biocutils.combine_rows(bframe1, bframe2)\nprint(combined)\n\nBiocFrame with 10 rows and 2 columns\n       odd   even\n    &lt;list&gt; &lt;list&gt;\n[0]      1      0\n[1]      3      2\n[2]      5      4\n[3]      7      6\n[4]      9      8\n[5]     11      0\n[6]     33     22\n[7]     55     44\n[8]     77     66\n[9]     99     88\n\n\nSimilarly, to combine by column:\n\nbframe3 = BiocFrame({\n    \"foo\": [\"A\", \"B\", \"C\", \"D\", \"E\"],\n    \"bar\": [True, False, True, False, True]\n})\n\ncombined = biocutils.combine_columns(bframe1, bframe3)\nprint(combined)\n\nBiocFrame with 5 rows and 4 columns\n       odd   even    foo    bar\n    &lt;list&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt;\n[0]      1      0      A   True\n[1]      3      2      B  False\n[2]      5      4      C   True\n[3]      7      6      D  False\n[4]      9      8      E   True\n\n\n\n\n\n\n\n\nNote\n\n\n\nBy default, both methods above assume that the number and identity of columns (for combine_rows()) or rows (for combine_columns()) are the same across objects.\n\n\nIf this is not the case, e.g., with different columns across objects, we can use relaxed_combine_rows() instead:\n\nfrom biocframe import relaxed_combine_rows\n\nmodified2 = bframe2.set_column(\"foo\", [\"A\", \"B\", \"C\", \"D\", \"E\"])\n\ncombined = biocutils.relaxed_combine_rows(bframe1, modified2)\nprint(combined)\n\nBiocFrame with 10 rows and 3 columns\n       odd   even    foo\n    &lt;list&gt; &lt;list&gt; &lt;list&gt;\n[0]      1      0   None\n[1]      3      2   None\n[2]      5      4   None\n[3]      7      6   None\n[4]      9      8   None\n[5]     11      0      A\n[6]     33     22      B\n[7]     55     44      C\n[8]     77     66      D\n[9]     99     88      E\n\n\nSimilarly, if the rows are different, we can use BiocFrame’s merge function:\n\nfrom biocframe import merge\n\nmodified1 = bframe1.set_row_names([\"A\", \"B\", \"C\", \"D\", \"E\"])\nmodified3 = bframe3.set_row_names([\"C\", \"D\", \"E\", \"F\", \"G\"])\n\ncombined = merge([modified1, modified3], by=None, join=\"outer\")\nprint(combined)\n\nBiocFrame with 7 rows and 4 columns\n     odd   even    foo    bar\n  &lt;list&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt;\nA      1      0   None   None\nB      3      2   None   None\nC      5      4      A   True\nD      7      6      B  False\nE      9      8      C   True\nF   None   None      D  False\nG   None   None      E   True"
  },
  {
    "objectID": "chapters/biocframe/intro.html#interop-with-pandas",
    "href": "chapters/biocframe/intro.html#interop-with-pandas",
    "title": "1  Overview",
    "section": "1.5 Interop with pandas",
    "text": "1.5 Interop with pandas\nBiocFrame is intended for accurate representation of Bioconductor objects for interoperability with R. Most users will probably prefer to work with pandas DataFrame objects for their actual analyses. This conversion is easily achieved:\n\nfrom biocframe import BiocFrame\nbframe = BiocFrame(\n    {\n        \"foo\": [\"A\", \"B\", \"C\", \"D\", \"E\"],\n        \"bar\": [True, False, True, False, True]\n    }\n)\n\npd = bframe.to_pandas()\nprint(pd)\n\n  foo    bar\n0   A   True\n1   B  False\n2   C   True\n3   D  False\n4   E   True\n\n\nConversion back to a BiocFrame is similarly easy:\n\nout = BiocFrame.from_pandas(pd)\nprint(out)\n\nBiocFrame with 5 rows and 2 columns\n     foo    bar\n  &lt;list&gt; &lt;list&gt;\n0      A   True\n1      B  False\n2      C   True\n3      D  False\n4      E   True"
  },
  {
    "objectID": "chapters/biocframe/intro.html#empty-frames",
    "href": "chapters/biocframe/intro.html#empty-frames",
    "title": "1  Overview",
    "section": "1.6 Empty Frames",
    "text": "1.6 Empty Frames\nWe can create empty BiocFrame objects that hold no information except the number of rows. This is useful when BiocFrame objects are part of larger datastructures but hold no data.\n\nempty = BiocFrame(number_of_rows=100)\nprint(empty)\n\nBiocFrame with 100 rows and 0 columns\n\n\n\nMost operations described in the document can also be performed on an empty BiocFrame object.\n\nprint(\"Column names:\", empty.column_names)\n\nsubset_empty = empty[1:10,:]\nprint(\"\\nSubsetting an empty BiocFrame: \\n\", subset_empty)\n\nColumn names: []\n\nSubsetting an empty BiocFrame: \n BiocFrame with 9 rows and 0 columns\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nSimilarly one can create an empty BiocFrame with only row names."
  },
  {
    "objectID": "chapters/biocframe/intro.html#further-reading",
    "href": "chapters/biocframe/intro.html#further-reading",
    "title": "1  Overview",
    "section": "1.7 Further reading",
    "text": "1.7 Further reading\nCheck out the reference documentation for more details.\nAlso see check out Bioconductor’s S4Vectors package, which implements the DFrame class on which BiocFrame was based."
  },
  {
    "objectID": "chapters/summary.html",
    "href": "chapters/summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever."
  }
]