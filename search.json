[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BiocPy: Enabling Bioconductor workflows in Python",
    "section": "",
    "text": "Welcome\nBioconductor is an open-source software project that provides tools for the analysis and comprehension of genomic data. One of the main advantages of Bioconductor is the availability of standard data representations and large number of analysis tools for genomic experiments. These tools allow researchers to efficiently store, manipulate, and analyze their data, leading to a deeper understanding of the underlying biological processes.\nInspired by Bioconductor, BiocPy aims to facilitate bioconductor workflows in Python. To achieve this goal, we developed several core data structures that align closely to the bioconductor implementations. These structures efficiently manage genomic intervals and genome annotations through GenomicRanges and/or IRanges, provide container classes to represent single (SummarizedExperiment, SingleCellExperiment) or multi-omic experimental data and metadata (MultiAssayExperiment). In addition, BiocPy provides infrastructure packages to support delayed operations (DelayedArray), Bioconductor-like dataframes (BiocFrame), and incorporate numerous generics and utilities in BiocUtils. While there are prior initiatives aiming to port bioconductor representations into Python, BiocPy distinguishes itself as the first to develop seamless, well-integrated data structures and representations.\nBiocPy additionally provides bindings to libscran and various other single-cell analysis methods incorporated into the scranpy package to support analysis of multi-modal single-cell datasets. It also features integration with the singler algorithm to annotate cell types by matching cells to known references based on their expression profiles.\nFor convenient access to experimental data stored in RDS files, the rds2py package provides bindings to the rds2cpp library. This allows direct reading of RDS files in Python, eliminating the need for additional data conversion tools or intermediate formats. This package functionality streamlines the transition between Python and R for seamless analysis.\nAll packages within the BiocPy ecosystem are published to Python’s Package Index (PyPI)."
  },
  {
    "objectID": "index.html#selected-packages",
    "href": "index.html#selected-packages",
    "title": "BiocPy: Enabling Bioconductor workflows in Python",
    "section": "Selected packages",
    "text": "Selected packages\nFor complete list of all packages, visit the GitHub:BiocPy repository.\n\nCore representations:\n\nBiocUtils (GitHub, Docs): Common utilities for use across packages, mostly to mimic convenient aspects of base R.\nBiocFrame (GitHub, Docs): Bioconductor-like dataframes in Python.\nIRanges (GitHub, Docs): Python implementation of the IRanges package to support interval arithmetic.\nGenomicRanges (GitHub, Docs, BioC): Container class to represent genomic locations and support genomic analysis. Similar to Bioconductor’s GenomicRanges.\nSummarizedExperiment (GitHub, Docs, BioC): Container class to represent genomic experiments, following Bioconductor’s SummarizedExperiment.\nSingleCellExperiment (GitHub, Docs, BioC): Container class to represent single-cell experiments; follows Bioconductor’s SingleCellExperiment.\nMultiAssayExperiment (GitHub, Docs, BioC): Container class to represent multiple experiments and assays performed over a set of samples. follows Bioconductor’s MAE R/Bioc Package.\n\n\n\nAnalysis packages\n\nscranpy(GitHub, Docs): Python bindings to the single-cell analysis methods from libscran and related C++ libraries.\nsingler(GitHub, Docs): Python bindings to the singleR algorithm to annotate cell types from known references.\n\n\n\nInteroperability with R\n\nrds2py (GitHub, Docs): Read RDS files directly in Python. Supports Bioconductor’s SummarizedExperiment and SingleCellExperiment in addition to matrices, dataframes and vectors.\n\n\n\nUtility packages\n\nmopsy (GitHub, Docs): Helper functions to perform row or column operations over numpy and scipy matrices. Provides an interface similar to base R matrix methods/MatrixStats methods.\npyBiocFileCache (GitHub, Docs, BioC): File system based cache for resources & metadata."
  },
  {
    "objectID": "index.html#further-reading",
    "href": "index.html#further-reading",
    "title": "BiocPy: Enabling Bioconductor workflows in Python",
    "section": "Further reading",
    "text": "Further reading\nMany online resources provide detailed info on these data structures, namely\n\nhttps://compgenomr.github.io/book/\nhttps://www.nature.com/articles/nmeth.3252\nhttps://www.nature.com/articles/s41592-019-0654-x\nhttps://github.com/waldronlab/EPIC-BiocIntro\n\n\nNotes\nThis is a reproducible Quarto book with reusable snippets. To learn more about Quarto books visit https://quarto.org/docs/books. Checkout Reproduce me for more information."
  },
  {
    "objectID": "chapters/philosophy.html#class-design",
    "href": "chapters/philosophy.html#class-design",
    "title": "Programming philosophy",
    "section": "Class design",
    "text": "Class design\nOur objective is to provide a consistent user experience in Python for each Bioconductor class. In most cases, this is achieved by directly re-implementing the class and its associated methods in Python. Occasionally, the Bioconductor implementation contains historical baggage (e.g., the storage of rowData in a RangedSummarizedExperiment, MultiAssayExperiment harmonization); developers should use their own discretion to decide whether that really needs to be replicated in Python."
  },
  {
    "objectID": "chapters/philosophy.html#naming",
    "href": "chapters/philosophy.html#naming",
    "title": "Programming philosophy",
    "section": "Naming",
    "text": "Naming\nWe highly recommend adhering to Google’s Python style guide for consistency. In summary, classes should use PascalCase and follow Bioconductor’s class names. Methods should use snake_case and take the form of &lt;verb&gt;[_&lt;details&gt;], such as get_start(), set_names() and so on. Method arguments should also use snake_case format.\nUsability has been another crucial objective, to facilitate an easy transition for users between R and Python classes. For instance, when computing flanking regions in R:\nflank(gr, width=2, start=FALSE, both=TRUE)\nIn the GenomicRanges Python packages, we maintain consistency by expecting the same method name. The only difference lies in the shift from a functional to an object-oriented programming paradigm:\ngr.flank(width=2, start=False, both=True)\n\nFunctional discipline\nThe existence of mutable types in Python introduces the potential danger of modifying complex objects. If a mutable object has a user-visible reference and is also a member of a larger Bioconductor object, a user-specified modification to that object may violate the constraints of the parent object.\nTo address these issues, we enforce a functional programming discipline in all class methods. By default, all methods should avoid side effects that mutate the object. This simplifies reasoning around the effects of methods and/or mutations in large complex objects.\nThe most notable application of this philosophy is in setter methods. Instead of mutating the object directly, they should return a new copy of the object with the desired modification. The “depth” of the copy depends on the nature of the field being set; the aim should be to avoid any modification of the contents in self. Implementations may offer an in_place= option to apply the modification to the original object, but this default to False.\nTo avoid performance issues, getter methods may return mutable objects without copying, assuming that their return values are read-only and will not be directly mutated (Setter methods that operate via a copy are allowed). In some cases, the return value of a getter method may be directly mutated, e.g., because a copy was already created in the getter; this should be clearly stated in the documentation but should not be treated as the default.\n\nProperty based getters and setters\nDirect access to class members (via properties or @property decorator) should generally be avoided, as it is too easy to perform modifications via one-liners with the class.property notation on the left-hand-side of an assignment.\nThe default assumption is that property-based setters will mutate the object in-place."
  },
  {
    "objectID": "chapters/philosophy.html#type-hints",
    "href": "chapters/philosophy.html#type-hints",
    "title": "Programming philosophy",
    "section": "Type hints",
    "text": "Type hints\nAs the term suggests, type hints are “hints” used to enhance the developer experience; they should not dictate how we write our code.\nFor this reason, we prefer simple types in these hints, usually corresponding to base Python types with minimal nesting. For example, if a function is expected to operate on any arbitrary list, the basic list type hint should suffice.\ndef find_element(arr: list, query: int)\n    pass\nIf the function expects a list of strings,\nfrom typing import List\n\ndef find_element(arr: List[str], query: str):\n    pass\nIf the function accepts multiple types as inputs,\nfrom typing import Union\n\ndef find_element(arr: List[str], query: Union[int, str, slice]):\n    pass"
  },
  {
    "objectID": "chapters/philosophy.html#notes",
    "href": "chapters/philosophy.html#notes",
    "title": "Programming philosophy",
    "section": "Notes",
    "text": "Notes\nAdditionally, we provide recommendations on setting up the package, different testing environments, documentation, and publishing workflows. These details can be found in the developer guide."
  },
  {
    "objectID": "chapters/representations/index.html",
    "href": "chapters/representations/index.html",
    "title": "The basics",
    "section": "",
    "text": "All packages in the BiocPy ecosystem are released on Python’s package registry - PyPI.\nThe biocpy package serves as a convenient wrapper that installs all the core packages within the ecosystem.\npip install biocpy\nAlternatively, you can install specific packages as required. For example:\npip install summarizedexperiment # &lt;package-name&gt;\n\nUpdate packages\nTo update packages, use the following command:\npip install -U biocpy # or &lt;package-name&gt;"
  },
  {
    "objectID": "chapters/representations/biocframe.html#installation",
    "href": "chapters/representations/biocframe.html#installation",
    "title": "BiocFrame - Bioconductor-like data frames",
    "section": "Installation",
    "text": "Installation\nTo get started, install the package from PyPI\npip install biocframe"
  },
  {
    "objectID": "chapters/representations/biocframe.html#advantages-of-biocframe",
    "href": "chapters/representations/biocframe.html#advantages-of-biocframe",
    "title": "BiocFrame - Bioconductor-like data frames",
    "section": "Advantages of BiocFrame",
    "text": "Advantages of BiocFrame\nOne of the core principles guiding the implementation of the BiocFrame class is “what you put is what you get.” Unlike Pandas DataFrame, BiocFrame makes no assumptions about the types of the columns provided as input. Some key differences to highlight the advantages of using BiocFrame are especially in terms of modifications to column types and handling nested dataframes.\n\nInadvertent modification of types\nAs an example, Pandas DataFrame modifies the types of the input data. These assumptions can cause issues when interoperating between R and Python.\n\nimport pandas as pd\nimport numpy as np\nfrom array import array\n\ndf = pd.DataFrame({\n    \"numpy_vec\": np.zeros(10),\n    \"list_vec\": [1]* 10,\n    \"native_array_vec\": array('d', [3.14] * 10) # less used but native python arrays\n})\n\nprint(\"type of numpy_vector column:\", type(df[\"numpy_vec\"]), df[\"numpy_vec\"].dtype)\nprint(\"type of list_vector column:\", type(df[\"list_vec\"]), df[\"list_vec\"].dtype)\nprint(\"type of native_array_vector column:\", type(df[\"native_array_vec\"]), df[\"native_array_vec\"].dtype)\n\nprint(df)\n\ntype of numpy_vector column: &lt;class 'pandas.core.series.Series'&gt; float64\ntype of list_vector column: &lt;class 'pandas.core.series.Series'&gt; int64\ntype of native_array_vector column: &lt;class 'pandas.core.series.Series'&gt; float64\n   numpy_vec  list_vec  native_array_vec\n0        0.0         1              3.14\n1        0.0         1              3.14\n2        0.0         1              3.14\n3        0.0         1              3.14\n4        0.0         1              3.14\n5        0.0         1              3.14\n6        0.0         1              3.14\n7        0.0         1              3.14\n8        0.0         1              3.14\n9        0.0         1              3.14\n\n\nWith BiocFrame, no assumptions are made, and the input data is not cast into expected types:\n\nfrom biocframe import BiocFrame\nimport numpy as np\nfrom array import array\n\nbframe_types = BiocFrame({\n    \"numpy_vec\": np.zeros(10),\n    \"list_vec\": [1]* 10,\n    \"native_array_vec\": array('d', [3.14] * 10)\n})\n\nprint(\"type of numpy_vector column:\", type(bframe_types[\"numpy_vec\"]))\nprint(\"type of list_vector column:\", type(bframe_types[\"list_vec\"]))\nprint(\"type of native_array_vector column:\", type(bframe_types[\"native_array_vec\"]))\n\nprint(bframe_types)\n\ntype of numpy_vector column: &lt;class 'numpy.ndarray'&gt;\ntype of list_vector column: &lt;class 'list'&gt;\ntype of native_array_vector column: &lt;class 'array.array'&gt;\nBiocFrame with 10 rows and 3 columns\n             numpy_vec list_vec native_array_vec\n    &lt;ndarray[float64]&gt;   &lt;list&gt;          &lt;array&gt;\n[0]                0.0        1             3.14\n[1]                0.0        1             3.14\n[2]                0.0        1             3.14\n[3]                0.0        1             3.14\n[4]                0.0        1             3.14\n[5]                0.0        1             3.14\n[6]                0.0        1             3.14\n[7]                0.0        1             3.14\n[8]                0.0        1             3.14\n[9]                0.0        1             3.14\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis behavior remains consistent when extracting, slicing, combining, or performing any other supported operations on BiocFrame objects.\n\n\n\n\nHandling complex nested frames\nPandas DataFrame does not support nested structures; therefore, running the snippet below will result in an error:\n\ndf = pd.DataFrame({\n    \"ensembl\": [\"ENS00001\", \"ENS00002\", \"ENS00002\"],\n    \"symbol\": [\"MAP1A\", \"BIN1\", \"ESR1\"],\n    \"ranges\": pd.DataFrame({\n        \"chr\": [\"chr1\", \"chr2\", \"chr3\"],\n        \"start\": [1000, 1100, 5000],\n        \"end\": [1100, 4000, 5500]\n    }),\n})\nprint(df)\n\nHowever, it is handled seamlessly with BiocFrame:\n\nbframe_nested = BiocFrame({\n    \"ensembl\": [\"ENS00001\", \"ENS00002\", \"ENS00002\"],\n    \"symbol\": [\"MAP1A\", \"BIN1\", \"ESR1\"],\n    \"ranges\": BiocFrame({\n        \"chr\": [\"chr1\", \"chr2\", \"chr3\"],\n        \"start\": [1000, 1100, 5000],\n        \"end\": [1100, 4000, 5500]\n    }),\n})\n\nprint(bframe_nested)\n\nBiocFrame with 3 rows and 3 columns\n     ensembl symbol         ranges\n      &lt;list&gt; &lt;list&gt;    &lt;BiocFrame&gt;\n[0] ENS00001  MAP1A chr1:1000:1100\n[1] ENS00002   BIN1 chr2:1100:4000\n[2] ENS00002   ESR1 chr3:5000:5500\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis behavior remains consistent when extracting, slicing, combining, or performing any other supported operations on BiocFrame objects."
  },
  {
    "objectID": "chapters/representations/biocframe.html#construction",
    "href": "chapters/representations/biocframe.html#construction",
    "title": "BiocFrame - Bioconductor-like data frames",
    "section": "Construction",
    "text": "Construction\nCreating a BiocFrame object is straightforward; just provide the data as a dictionary.\n\nfrom biocframe import BiocFrame\n\nobj = {\n    \"ensembl\": [\"ENS00001\", \"ENS00002\", \"ENS00003\"],\n    \"symbol\": [\"MAP1A\", \"BIN1\", \"ESR1\"],\n}\nbframe = BiocFrame(obj)\nprint(bframe)\n\nBiocFrame with 3 rows and 2 columns\n     ensembl symbol\n      &lt;list&gt; &lt;list&gt;\n[0] ENS00001  MAP1A\n[1] ENS00002   BIN1\n[2] ENS00003   ESR1\n\n\n\n\n\n\n\n\nTip\n\n\n\nYou can specify complex objects as columns, as long as they have some “length” equal to the number of rows. For example, we can embed a BiocFrame within another BiocFrame.\n\n\n\nobj = {\n    \"ensembl\": [\"ENS00001\", \"ENS00002\", \"ENS00002\"],\n    \"symbol\": [\"MAP1A\", \"BIN1\", \"ESR1\"],\n    \"ranges\": BiocFrame({\n        \"chr\": [\"chr1\", \"chr2\", \"chr3\"],\n        \"start\": [1000, 1100, 5000],\n        \"end\": [1100, 4000, 5500]\n    }),\n}\n\nbframe2 = BiocFrame(obj, row_names=[\"row1\", \"row2\", \"row3\"])\nprint(bframe2)\n\nBiocFrame with 3 rows and 3 columns\n      ensembl symbol         ranges\n       &lt;list&gt; &lt;list&gt;    &lt;BiocFrame&gt;\nrow1 ENS00001  MAP1A chr1:1000:1100\nrow2 ENS00002   BIN1 chr2:1100:4000\nrow3 ENS00002   ESR1 chr3:5000:5500\n\n\nThe row_names parameter is analogous to index in the pandas world and should not contain missing strings. Additionally, you may provide:\n\ncolumn_data: A BiocFrameobject containing metadata about the columns. This must have the same number of rows as the numbers of columns.\nmetadata: Additional metadata about the object, usually a dictionary.\ncolumn_names: If different from the keys in the data. If not provided, this is automatically extracted from the keys in the data.\n\n\nInterop with pandas\nBiocFrame is intended for accurate representation of Bioconductor objects for interoperability with R, many users may prefer working with pandas DataFrame objects for their actual analyses. This conversion is easily achieved:\n\nfrom biocframe import BiocFrame\nbframe3 = BiocFrame(\n    {\n        \"foo\": [\"A\", \"B\", \"C\", \"D\", \"E\"],\n        \"bar\": [True, False, True, False, True]\n    }\n)\n\ndf = bframe3.to_pandas()\nprint(type(df))\nprint(df)\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\n  foo    bar\n0   A   True\n1   B  False\n2   C   True\n3   D  False\n4   E   True\n\n\nConverting back to a BiocFrame is similarly straightforward:\n\nout = BiocFrame.from_pandas(df)\nprint(out)\n\nBiocFrame with 5 rows and 2 columns\n     foo    bar\n  &lt;list&gt; &lt;list&gt;\n0      A   True\n1      B  False\n2      C   True\n3      D  False\n4      E   True"
  },
  {
    "objectID": "chapters/representations/biocframe.html#extracting-data",
    "href": "chapters/representations/biocframe.html#extracting-data",
    "title": "BiocFrame - Bioconductor-like data frames",
    "section": "Extracting data",
    "text": "Extracting data\nBiocPy classes follow a functional paradigm for accessing or setting properties, with further details discussed in functional paradigm section.\nProperties can be directly accessed from the object:\n\nprint(\"shape:\", bframe.shape)\nprint(\"column names (functional style):\", bframe.get_column_names())\nprint(\"column names (as property):\", bframe.column_names) # same as above\n\nshape: (3, 2)\ncolumn names (functional style): ['ensembl', 'symbol']\ncolumn names (as property): ['ensembl', 'symbol']\n\n\nWe can fetch individual columns:\n\nprint(\"functional style:\", bframe.get_column(\"ensembl\"))\nprint(\"w/ accessor\", bframe[\"ensembl\"])\n\nfunctional style: ['ENS00001', 'ENS00002', 'ENS00003']\nw/ accessor ['ENS00001', 'ENS00002', 'ENS00003']\n\n\nAnd we can get individual rows as a dictionary:\n\nbframe.get_row(2)\n\n{'ensembl': 'ENS00003', 'symbol': 'ESR1'}\n\n\n\n\n\n\n\n\nTo retrieve a subset of the data in the BiocFrame, we use the subset ([]) operator. This operator accepts different subsetting arguments, such as a boolean vector, a slice object, a sequence of indices, or row/column names.\n\n\n\n\nsliced_with_bools = bframe[1:2, [True, False, False]]\nprint(\"Subset using booleans: \\n\", sliced_with_bools)\n\nsliced_with_names = bframe[[0,2], [\"symbol\", \"ensembl\"]]\nprint(\"\\nSubset using column names: \\n\", sliced_with_names)\n\n# Short-hand to get a single column:\nprint(\"\\nShort-hand to get a single column: \\n\", bframe[\"ensembl\"])\n\nSubset using booleans: \n BiocFrame with 1 row and 1 column\n     ensembl\n      &lt;list&gt;\n[0] ENS00002\n\nSubset using column names: \n BiocFrame with 2 rows and 2 columns\n    symbol  ensembl\n    &lt;list&gt;   &lt;list&gt;\n[0]  MAP1A ENS00001\n[1]   ESR1 ENS00003\n\nShort-hand to get a single column: \n ['ENS00001', 'ENS00002', 'ENS00003']"
  },
  {
    "objectID": "chapters/representations/biocframe.html#setting-data",
    "href": "chapters/representations/biocframe.html#setting-data",
    "title": "BiocFrame - Bioconductor-like data frames",
    "section": "Setting data",
    "text": "Setting data\n\nPreferred approach\nFor setting properties, we encourage a functional style of programming to avoid mutating the object directly. This helps prevent inadvertent modifications of BiocFrame instances within larger data structures.\n\nmodified = bframe.set_column_names([\"column1\", \"column2\"])\nprint(modified)\n\nBiocFrame with 3 rows and 2 columns\n     column1 column2\n      &lt;list&gt;  &lt;list&gt;\n[0] ENS00001   MAP1A\n[1] ENS00002    BIN1\n[2] ENS00003    ESR1\n\n\nNow let’s check the column names of the original object,\n\n# Original is unchanged:\nprint(bframe.get_column_names())\n\n['ensembl', 'symbol']\n\n\nTo add new columns, or replace existing ones:\n\nmodified = bframe.set_column(\"symbol\", [\"A\", \"B\", \"C\"])\nprint(modified)\n\nmodified = bframe.set_column(\"new_col_name\", range(2, 5))\nprint(modified)\n\nBiocFrame with 3 rows and 2 columns\n     ensembl symbol\n      &lt;list&gt; &lt;list&gt;\n[0] ENS00001      A\n[1] ENS00002      B\n[2] ENS00003      C\nBiocFrame with 3 rows and 3 columns\n     ensembl symbol new_col_name\n      &lt;list&gt; &lt;list&gt;      &lt;range&gt;\n[0] ENS00001  MAP1A            2\n[1] ENS00002   BIN1            3\n[2] ENS00003   ESR1            4\n\n\nChange the row or column names:\n\nmodified = bframe.\\\n    set_column_names([\"FOO\", \"BAR\"]).\\\n    set_row_names(['alpha', 'bravo', 'charlie'])\nprint(modified)\n\nBiocFrame with 3 rows and 2 columns\n             FOO    BAR\n          &lt;list&gt; &lt;list&gt;\n  alpha ENS00001  MAP1A\n  bravo ENS00002   BIN1\ncharlie ENS00003   ESR1\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe functional style allows you to chain multiple operations.\n\n\nWe also support Bioconductor’s metadata concepts, either along the columns or for the entire object:\n\nmodified = bframe.\\\n    set_metadata({ \"author\": \"Jayaram Kancherla\" }).\\\n    set_column_data(BiocFrame({\"column_source\": [\"Ensembl\", \"HGNC\" ]}))\nprint(modified)\n\nBiocFrame with 3 rows and 2 columns\n     ensembl symbol\n      &lt;list&gt; &lt;list&gt;\n[0] ENS00001  MAP1A\n[1] ENS00002   BIN1\n[2] ENS00003   ESR1\n------\ncolumn_data(1): column_source\nmetadata(1): author\n\n\n\n\nThe not-preferred-way\nProperties can also be set by direct assignment for in-place modification. We prefer not to do it this way as it can silently mutate BiocFrame instances inside other data structures. Nonetheless:\n\ntestframe = BiocFrame({ \"A\": [1,2,3], \"B\": [4,5,6] })\ntestframe.column_names = [\"column1\", \"column2\" ]\nprint(testframe)\n\nBiocFrame with 3 rows and 2 columns\n    column1 column2\n     &lt;list&gt;  &lt;list&gt;\n[0]       1       4\n[1]       2       5\n[2]       3       6\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/biocframe/BiocFrame.py:466: UserWarning: Setting property 'column_names' is an in-place operation, use 'set_column_names' instead\n  warn(\n\n\n\n\n\n\n\n\nCaution\n\n\n\nWarnings are raised when properties are directly mutated. These assignments are the same as calling the corresponding set_*() methods with in_place = True. It is best to do this only if the BiocFrame object is not being used anywhere else; otherwise, it is safer to just create a (shallow) copy via the default in_place = False.\n\n\nSimilarly, we could set or replace columns directly:\n\ntestframe[\"column2\"] = [\"A\", \"B\", \"C\"]\ntestframe[1:3, [\"column1\",\"column2\"]] = BiocFrame({\"x\":[4, 5], \"y\":[\"E\", \"F\"]})\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/biocframe/BiocFrame.py:819: UserWarning: This method performs an in-place operation, use 'set_column' instead\n  warn(\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/biocframe/BiocFrame.py:813: UserWarning: This method performs an in-place operation, use 'set_slice' instead\n  warn("
  },
  {
    "objectID": "chapters/representations/biocframe.html#combining-objects",
    "href": "chapters/representations/biocframe.html#combining-objects",
    "title": "BiocFrame - Bioconductor-like data frames",
    "section": "Combining objects",
    "text": "Combining objects\nBiocFrame implements methods for the various combine generics from BiocUtils. For example, to combine by row:\n\nimport biocutils\n\nbframe1 = BiocFrame({\n    \"odd\": [1, 3, 5, 7, 9],\n    \"even\": [0, 2, 4, 6, 8],\n})\n\nbframe2 = BiocFrame({\n    \"odd\": [11, 33, 55, 77, 99],\n    \"even\": [0, 22, 44, 66, 88],\n})\n\ncombined = biocutils.combine_rows(bframe1, bframe2)\nprint(combined)\n\nBiocFrame with 10 rows and 2 columns\n       odd   even\n    &lt;list&gt; &lt;list&gt;\n[0]      1      0\n[1]      3      2\n[2]      5      4\n[3]      7      6\n[4]      9      8\n[5]     11      0\n[6]     33     22\n[7]     55     44\n[8]     77     66\n[9]     99     88\n\n\nSimilarly, to combine by column:\n\nbframe3 = BiocFrame({\n    \"foo\": [\"A\", \"B\", \"C\", \"D\", \"E\"],\n    \"bar\": [True, False, True, False, True]\n})\n\ncombined = biocutils.combine_columns(bframe1, bframe3)\nprint(combined)\n\nBiocFrame with 5 rows and 4 columns\n       odd   even    foo    bar\n    &lt;list&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt;\n[0]      1      0      A   True\n[1]      3      2      B  False\n[2]      5      4      C   True\n[3]      7      6      D  False\n[4]      9      8      E   True\n\n\n\n\n\n\n\n\nNote\n\n\n\nBy default, both methods above assume that the number and identity of columns (for combine_rows()) or rows (for combine_columns()) are the same across objects.\n\n\n\nRelaxed combine operation\nIf this is not the case, e.g., with different columns across objects, we can use relaxed_combine_rows() instead:\n\nfrom biocframe import relaxed_combine_rows\n\nmodified2 = bframe2.set_column(\"foo\", [\"A\", \"B\", \"C\", \"D\", \"E\"])\n\ncombined = biocutils.relaxed_combine_rows(bframe1, modified2)\nprint(combined)\n\nBiocFrame with 10 rows and 3 columns\n       odd   even    foo\n    &lt;list&gt; &lt;list&gt; &lt;list&gt;\n[0]      1      0   None\n[1]      3      2   None\n[2]      5      4   None\n[3]      7      6   None\n[4]      9      8   None\n[5]     11      0      A\n[6]     33     22      B\n[7]     55     44      C\n[8]     77     66      D\n[9]     99     88      E\n\n\nSimilarly, if the rows are different, we can use BiocFrame’s merge function:\n\nfrom biocframe import merge\n\nmodified1 = bframe1.set_row_names([\"A\", \"B\", \"C\", \"D\", \"E\"])\nmodified3 = bframe3.set_row_names([\"C\", \"D\", \"E\", \"F\", \"G\"])\n\ncombined = merge([modified1, modified3], by=None, join=\"outer\")\nprint(combined)\n\nBiocFrame with 7 rows and 4 columns\n     odd   even    foo    bar\n  &lt;list&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt;\nA      1      0   None   None\nB      3      2   None   None\nC      5      4      A   True\nD      7      6      B  False\nE      9      8      C   True\nF   None   None      D  False\nG   None   None      E   True"
  },
  {
    "objectID": "chapters/representations/biocframe.html#empty-frames",
    "href": "chapters/representations/biocframe.html#empty-frames",
    "title": "BiocFrame - Bioconductor-like data frames",
    "section": "Empty Frames",
    "text": "Empty Frames\nWe can create empty BiocFrame objects that only specify the number of rows. This is beneficial in situations where BiocFrame objects are integrated into more extensive data structures but do not contain any data themselves.\n\nempty = BiocFrame(number_of_rows=100)\nprint(empty)\n\nBiocFrame with 100 rows and 0 columns\n\n\n\nMost operations described in this document can be performed on an empty BiocFrame object.\n\nprint(\"Column names:\", empty.column_names)\n\nsubset_empty = empty[1:10,:]\nprint(\"\\nSubsetting an empty BiocFrame: \\n\", subset_empty)\n\nColumn names: []\n\nSubsetting an empty BiocFrame: \n BiocFrame with 9 rows and 0 columns"
  },
  {
    "objectID": "chapters/representations/biocframe.html#further-reading",
    "href": "chapters/representations/biocframe.html#further-reading",
    "title": "BiocFrame - Bioconductor-like data frames",
    "section": "Further reading",
    "text": "Further reading\nCheck out the reference documentation for more details.\nAlso check out Bioconductor’s S4Vectors package, which implements the DFrame class on which BiocFrame was based."
  },
  {
    "objectID": "chapters/representations/genomicranges.html#installation",
    "href": "chapters/representations/genomicranges.html#installation",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Installation",
    "text": "Installation\nTo get started, install the package from PyPI\npip install genomicranges"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#construct-a-genomicranges-object",
    "href": "chapters/representations/genomicranges.html#construct-a-genomicranges-object",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Construct a GenomicRanges object",
    "text": "Construct a GenomicRanges object\nWe support multiple ways to initialize a GenomicRanges object.\n\nPreferred way\nTo construct a GenomicRanges object from interval ranges and sequence names:\n\nfrom genomicranges import GenomicRanges\nfrom iranges import IRanges\nfrom biocframe import BiocFrame\nfrom random import random\n\ngr = GenomicRanges(\n    seqnames=[\n        \"chr1\",\n        \"chr2\",\n        \"chr3\",\n        \"chr2\",\n        \"chr3\",\n    ],\n    ranges=IRanges([x for x in range(101, 106)], [11, 21, 25, 30, 5]),\n    strand=[\"*\", \"-\", \"*\", \"+\", \"-\"],\n    mcols=BiocFrame(\n        {\n            \"score\": range(0, 5),\n            \"GC\": [random() for _ in range(5)],\n        }\n    ),\n)\n\nprint(gr)\n\nGenomicRanges with 5 ranges and 5 metadata columns\n    seqnames    ranges          strand     score                  GC\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;range&gt;              &lt;list&gt;\n[0]     chr1 101 - 112               * |       0 0.01585069826354124\n[1]     chr2 102 - 123               - |       1  0.5586989043688331\n[2]     chr3 103 - 128               * |       2  0.8682768502009266\n[3]     chr2 104 - 134               + |       3  0.8183350955623728\n[4]     chr3 105 - 110               - |       4   0.782721041898957\n------\nseqinfo(3 sequences): chr1 chr2 chr3\n\n\n\n\n\n\n\n\nNote\n\n\n\nmcols is expected to a BiocFrame object and will be coerced to a BiocFrame if a pandas DataFrame is provided.\n\n\n\n\nFrom UCSC or GTF file\nYou can also import genomes from UCSC or load a genome annotation from a GTF file. This requires installation of additional packages pandas and joblib to parse and extract various attributes from the gtf file.\n\n\n\n\n\n\nNote\n\n\n\nA future version of this package might implement or take advantage of existing genomic parser packages in python to support various file formats.\n\n\n\nimport genomicranges\n\n# gr = genomicranges.read_gtf(&lt;PATH TO GTF&gt;)\n\n# OR\n\n# gr = genomicranges.read_ucsc(genome=\"hg19\")\n# print(gr)\n\n\n\nPandas DataFrame\nIf your genomic coordinates are represented as a pandas DataFrame, convert this into GenomicRanges if it contains the necessary columns.\n\n\n\n\n\n\nNote\n\n\n\nThe DataFrame must contain columns seqnames, starts and ends to represent genomic coordinates. The rest of the columns are considered metadata and will be available in the mcols slot of the GenomicRanges object.\n\n\n\nfrom genomicranges import GenomicRanges\nimport pandas as pd\n\ndf = pd.DataFrame(\n    {\n        \"seqnames\": [\"chr1\", \"chr2\", \"chr1\", \"chr3\", \"chr2\"],\n        \"starts\": [101, 102, 103, 104, 109],\n        \"ends\": [112, 103, 128, 134, 111],\n        \"strand\": [\"*\", \"-\", \"*\", \"+\", \"-\"],\n        \"score\": range(0, 5),\n        \"GC\": [random() for _ in range(5)],\n    }\n)\n\ngr_from_df = GenomicRanges.from_pandas(df)\nprint(gr_from_df)\n\nGenomicRanges with 5 ranges and 5 metadata columns\n  seqnames    ranges          strand    score                  GC\n     &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;list&gt;              &lt;list&gt;\n0     chr1 101 - 112               * |      0  0.6827703082822782\n1     chr2 102 - 103               - |      1  0.4964462588449454\n2     chr1 103 - 128               * |      2 0.19317212230318426\n3     chr3 104 - 134               + |      3  0.8369325448115692\n4     chr2 109 - 111               - |      4  0.5747783952534509\n------\nseqinfo(3 sequences): chr1 chr2 chr3"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#sequence-information",
    "href": "chapters/representations/genomicranges.html#sequence-information",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Sequence information",
    "text": "Sequence information\nThe package also provides a SeqInfo class to update or modify sequence information stored in the object. Learn more about this in the GenomeInfoDb package.\n\nfrom genomicranges import SeqInfo\n\nseq = SeqInfo(\n    seqnames = [\"chr1\", \"chr2\", \"chr3\"],\n    seqlengths = [110, 112, 118],\n    is_circular = [True, True, False],\n    genome = \"hg19\",\n)\ngr_with_seq = gr.set_seqinfo(seq)\nprint(gr_with_seq)\n\nGenomicRanges with 5 ranges and 5 metadata columns\n    seqnames    ranges          strand     score                  GC\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;range&gt;              &lt;list&gt;\n[0]     chr1 101 - 112               * |       0 0.01585069826354124\n[1]     chr2 102 - 123               - |       1  0.5586989043688331\n[2]     chr3 103 - 128               * |       2  0.8682768502009266\n[3]     chr2 104 - 134               + |       3  0.8183350955623728\n[4]     chr3 105 - 110               - |       4   0.782721041898957\n------\nseqinfo(3 sequences): chr1 chr2 chr3"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#getterssetters",
    "href": "chapters/representations/genomicranges.html#getterssetters",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Getters/Setters",
    "text": "Getters/Setters\nGetters are available to access various attributes using either the property notation or functional style.\n\n# access sequence names\nprint(\"seqnames (as property): \", gr.seqnames)\nprint(\"seqnames (functional style): \", gr.get_seqnames())\n\n# access all start positions\nprint(\"start positions: \", gr.start)\n\n# access annotation information if available\ngr.seqinfo\n\n# compute and return the widths of each region\nprint(\"width of each region: \", gr.get_width()) \n# or gr.width\n\n# access mcols\nprint(gr.mcols)\n\nseqnames (as property):  ['chr1', 'chr2', 'chr3', 'chr2', 'chr3']\nseqnames (functional style):  ['chr1', 'chr2', 'chr3', 'chr2', 'chr3']\nstart positions:  [101 102 103 104 105]\nwidth of each region:  [11 21 25 30  5]\nBiocFrame with 5 rows and 2 columns\n      score                  GC\n    &lt;range&gt;              &lt;list&gt;\n[0]       0 0.01585069826354124\n[1]       1  0.5586989043688331\n[2]       2  0.8682768502009266\n[3]       3  0.8183350955623728\n[4]       4   0.782721041898957\n\n\n\nSetters\n\n\n\n\n\n\nImportant\n\n\n\nAll property-based setters are in_place operations, with further details discussed in functional paradigm section.\n\n\n\nmodified_mcols = gr.mcols.set_column(\"score\", range(1,6))\nmodified_gr = gr.set_mcols(modified_mcols)\nprint(modified_gr)\n\nGenomicRanges with 5 ranges and 5 metadata columns\n    seqnames    ranges          strand     score                  GC\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;range&gt;              &lt;list&gt;\n[0]     chr1 101 - 112               * |       1 0.01585069826354124\n[1]     chr2 102 - 123               - |       2  0.5586989043688331\n[2]     chr3 103 - 128               * |       3  0.8682768502009266\n[3]     chr2 104 - 134               + |       4  0.8183350955623728\n[4]     chr3 105 - 110               - |       5   0.782721041898957\n------\nseqinfo(3 sequences): chr1 chr2 chr3\n\n\nor use an in-place operation:\n\ngr.mcols.set_column(\"score\", range(1,6), in_place=True)\nprint(gr.mcols)\n\nBiocFrame with 5 rows and 2 columns\n      score                  GC\n    &lt;range&gt;              &lt;list&gt;\n[0]       1 0.01585069826354124\n[1]       2  0.5586989043688331\n[2]       3  0.8682768502009266\n[3]       4  0.8183350955623728\n[4]       5   0.782721041898957\n\n\n\n\nAccess ranges\nget_ranges() is a generic method to access only the genomic coordinates:\n\n# or gr.get_ranges()\n\nprint(gr.ranges)\n\nIRanges object with 5 ranges and 0 metadata columns\n               start              end            width\n    &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt;\n[0]              101              112               11\n[1]              102              123               21\n[2]              103              128               25\n[3]              104              134               30\n[4]              105              110                5"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#subset-operations",
    "href": "chapters/representations/genomicranges.html#subset-operations",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Subset operations",
    "text": "Subset operations\nYou can subset a GenomicRange object using the subset ([]) operator. This operation accepts different slice input types, such as a boolean vector, a slice object, a list of indices, or names (if available) to subset.\n\n# get the first 3 regions\ngr[:3]\n\n# get 1, 3 and 2nd rows\n# note: the order is retained in the result\nprint(gr[[1,3,2]])\n\nGenomicRanges with 3 ranges and 3 metadata columns\n    seqnames    ranges          strand    score                 GC\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;list&gt;             &lt;list&gt;\n[0]     chr2 102 - 123               - |      2 0.5586989043688331\n[1]     chr2 104 - 134               + |      4 0.8183350955623728\n[2]     chr3 103 - 128               * |      3 0.8682768502009266\n------\nseqinfo(3 sequences): chr1 chr2 chr3"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#iterate-over-ranges",
    "href": "chapters/representations/genomicranges.html#iterate-over-ranges",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Iterate over ranges",
    "text": "Iterate over ranges\nYou can iterate over the regions of a GenomicRanges object. name is None if the object does not contain any names. To iterate over the first two ranges:\n\nfor name, row in gr[:2]:\n    print(name, row)\n\nNone GenomicRanges with 1 range and 1 metadata column\n    seqnames    ranges          strand    score                  GC\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;list&gt;              &lt;list&gt;\n[0]     chr1 101 - 112               * |      1 0.01585069826354124\n------\nseqinfo(3 sequences): chr1 chr2 chr3\nNone GenomicRanges with 1 range and 1 metadata column\n    seqnames    ranges          strand    score                 GC\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;list&gt;             &lt;list&gt;\n[0]     chr2 102 - 123               - |      2 0.5586989043688331\n------\nseqinfo(3 sequences): chr1 chr2 chr3"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#intra-range-transformations",
    "href": "chapters/representations/genomicranges.html#intra-range-transformations",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Intra-range transformations",
    "text": "Intra-range transformations\nFor detailed description of these methods, refer to either the Bioconductor’s or BiocPy’s documentation.\n\nflank: Flank the intervals based on start or end or both.\nshift: Shifts all the ranges specified by the shift argument.\nresize: Resizes the ranges to the specified width where either the start, end, or center is used as an anchor.\nnarrow: Narrows the ranges.\npromoters: Promoters generates promoter ranges for each range relative to the TSS. The promoter range is expanded around the TSS according to the upstream and downstream parameters.\nrestrict: Restricts the ranges to the interval(s) specified by the start and end arguments.\ntrim: Trims out-of-bound ranges located on non-circular sequences whose length is not NA.\n\n\ngr = GenomicRanges(\n    seqnames=[\n        \"chr1\",\n        \"chr2\",\n        \"chr3\",\n        \"chr2\",\n        \"chr3\",\n    ],\n    ranges=IRanges([x for x in range(101, 106)], [11, 21, 25, 30, 5]),\n    strand=[\"*\", \"-\", \"*\", \"+\", \"-\"],\n    mcols=BiocFrame(\n        {\n            \"score\": range(0, 5),\n            \"GC\": [random() for _ in range(5)],\n        }\n    ),\n)\n\n# flank\nflanked_gr = gr.flank(width=10, start=False, both=True)\n\n# shift\nshifted_gr = gr.shift(shift=10)\n\n# resize\nresized_gr = gr.resize(width=10, fix=\"end\", ignore_strand=True)\n\n# narrow\nnarrow_gr = gr.narrow(end=1, width=1)\n\n# promoters\nprom_gr = gr.promoters()\n\n# restrict\nrestrict_gr = gr.restrict(start=114, end=140, keep_all_ranges=True)\n\n# trim\ntrimmed_gr = gr.trim()\n\nprint(\"GenomicRanges after the trim operation:\")\nprint(trimmed_gr)\n\nGenomicRanges after the trim operation:\nGenomicRanges with 5 ranges and 5 metadata columns\n    seqnames    ranges          strand     score                  GC\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;range&gt;              &lt;list&gt;\n[0]     chr1 101 - 112               * |       0  0.8022772249778705\n[1]     chr2 102 - 123               - |       1 0.48161289390561357\n[2]     chr3 103 - 128               * |       2 0.17010835547543401\n[3]     chr2 104 - 134               + |       3 0.27558255394400044\n[4]     chr3 105 - 110               - |       4 0.09819277128956072\n------\nseqinfo(3 sequences): chr1 chr2 chr3\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/iranges/IRanges.py:290: UserWarning: Setting property 'width'is an in-place operation, use 'set_width' instead\n  warn("
  },
  {
    "objectID": "chapters/representations/genomicranges.html#inter-range-methods",
    "href": "chapters/representations/genomicranges.html#inter-range-methods",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Inter-range methods",
    "text": "Inter-range methods\n\nrange: Returns a new GenomicRanges object containing range bounds for each distinct (seqname, strand) pair.\nreduce: returns a new GenomicRanges object containing reduced bounds for each distinct (seqname, strand) pair.\ngaps: Finds gaps in the GenomicRanges object for each distinct (seqname, strand) pair.\ndisjoin: Finds disjoint intervals across all locations for each distinct (seqname, strand) pair.\n\n\ngr = GenomicRanges(\n    seqnames=[\n        \"chr1\",\n        \"chr2\",\n        \"chr3\",\n        \"chr2\",\n        \"chr3\",\n    ],\n    ranges=IRanges([x for x in range(101, 106)], [11, 21, 25, 30, 5]),\n    strand=[\"*\", \"-\", \"*\", \"+\", \"-\"],\n    mcols=BiocFrame(\n        {\n            \"score\": range(0, 5),\n            \"GC\": [random() for _ in range(5)],\n        }\n    ),\n)\n\n# range\nrange_gr = gr.range()\n\n# reduce\nreduced_gr = gr.reduce(min_gap_width=3, with_reverse_map=True)\n\n# gaps\ngapped_gr = gr.gaps(start=103)  # OR\ngapped_gr = gr.gaps(end={\"chr1\": 120, \"chr2\": 120, \"chr3\": 120})\n\n# disjoin\ndisjoin_gr = gr.disjoin()\n\nprint(\"GenomicRanges with the disjoint ranges:\")\nprint(disjoin_gr)\n\nGenomicRanges with the disjoint ranges:\nGenomicRanges with 5 ranges and 5 metadata columns\n    seqnames    ranges          strand\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;\n[0]     chr1 101 - 112               *\n[1]     chr2 104 - 134               +\n[2]     chr2 102 - 123               -\n[3]     chr3 105 - 110               -\n[4]     chr3 103 - 128               *\n------\nseqinfo(3 sequences): chr1 chr2 chr3"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#set-operations-on-genomic-ranges",
    "href": "chapters/representations/genomicranges.html#set-operations-on-genomic-ranges",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Set operations on genomic ranges",
    "text": "Set operations on genomic ranges\n\nunion: Compute the union of intervals across objects.\nintersect: Compute the intersection or finds overlapping intervals.\nsetdiff: Compute set difference.\n\n\n\nShow the code\ng_src = GenomicRanges(\n    seqnames = [\"chr1\", \"chr2\", \"chr1\", \"chr3\", \"chr2\"],\n    ranges = IRanges(start =[101, 102, 103, 104, 109], width=[112, 103, 128, 134, 111]),\n    strand = [\"*\", \"-\", \"*\", \"+\", \"-\"]\n)\n\ng_tgt = GenomicRanges(\n    seqnames = [\"chr1\",\"chr2\",\"chr2\",\"chr2\",\"chr1\",\"chr1\",\"chr3\",\"chr3\",\"chr3\",\"chr3\"],\n    ranges = IRanges(start =range(101, 111), width=range(121, 131)),\n    strand = [\"*\", \"-\", \"-\", \"*\", \"*\", \"+\", \"+\", \"+\", \"-\", \"-\"]\n)\n\n\n\n# intersection\nint_gr = g_src.intersect(g_tgt)\n\n# set diff\ndiff_gr = g_src.setdiff(g_tgt)\n\n# union\nunion_gr = g_src.union(g_tgt)\n\nprint(\"GenomicRanges after the union operation:\")\nprint(union_gr)\n\nGenomicRanges after the union operation:\nGenomicRanges with 6 ranges and 6 metadata columns\n    seqnames    ranges          strand\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;\n[0]     chr1 106 - 232               +\n[1]     chr1 101 - 231               *\n[2]     chr2 102 - 226               -\n[3]     chr2 104 - 228               *\n[4]     chr3 104 - 238               +\n[5]     chr3 109 - 240               -\n------\nseqinfo(3 sequences): chr1 chr2 chr3"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#compute-over-bins",
    "href": "chapters/representations/genomicranges.html#compute-over-bins",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Compute over bins",
    "text": "Compute over bins\n\nSummary stats for column\nUse Pandas to compute summary statistics for a column:\n\npd.Series(gr.mcols.get_column(\"score\")).describe()\n\ncount    5.000000\nmean     2.000000\nstd      1.581139\nmin      0.000000\n25%      1.000000\n50%      2.000000\n75%      3.000000\nmax      4.000000\ndtype: float64\n\n\nWith a bit more magic, render a histogram using matplotlib:\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n_ = plt.hist(gr.mcols.get_column(\"score\"), bins=\"auto\")\nplt.title(\"'score' histogram with 'auto' bins\")\nplt.show()\n\n\n\n\nNot the prettiest plot but it works.\n\n\nBinned average\nCompute binned average for a set of query bins:\n\nfrom iranges import IRanges\nbins_gr = GenomicRanges(seqnames=[\"chr1\"], ranges=IRanges([101], [109]))\n\nsubject = GenomicRanges(\n    seqnames= [\"chr1\",\"chr2\",\"chr2\",\"chr2\",\"chr1\",\"chr1\",\"chr3\",\"chr3\",\"chr3\",\"chr3\"],\n    ranges=IRanges(range(101, 111), range(121, 131)),\n    strand= [\"*\", \"-\", \"-\", \"*\", \"*\", \"+\", \"+\", \"+\", \"-\", \"-\"],\n    mcols=BiocFrame({\n        \"score\": range(0, 10),\n    })\n)\n\n# Compute binned average\nbinned_avg_gr = subject.binned_average(bins=bins_gr, scorename=\"score\", outname=\"binned_score\")\nprint(binned_avg_gr)\n\nGenomicRanges with 1 range and 1 metadata column\n    seqnames    ranges          strand   binned_score\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;         &lt;list&gt;\n[0]     chr1 101 - 210               * |            2\n------\nseqinfo(1 sequences): chr1\n\n\n\n\n\n\n\n\nTip\n\n\n\nNow you might wonder how can I generate these bins?"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#generate-tiles-or-bins",
    "href": "chapters/representations/genomicranges.html#generate-tiles-or-bins",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Generate tiles or bins",
    "text": "Generate tiles or bins\n\ntile: Splits each genomic region by n (number of regions) or by width (maximum width of each tile).\nsliding_windows: Generates sliding windows within each range, by width and step.\n\n\ngr = GenomicRanges(\n    seqnames=[\n        \"chr1\",\n        \"chr2\",\n        \"chr3\",\n        \"chr2\",\n        \"chr3\",\n    ],\n    ranges=IRanges([x for x in range(101, 106)], [11, 21, 25, 30, 5]),\n    strand=[\"*\", \"-\", \"*\", \"+\", \"-\"],\n    mcols=BiocFrame(\n        {\n            \"score\": range(0, 5),\n            \"GC\": [random() for _ in range(5)],\n        }\n    ),\n)\n\n# tiles\ntiles = gr.tile(n=2)\n\n# slidingwindows\ntiles = gr.sliding_windows(width=10)\nprint(tiles)\n\nGenomicRanges with 52 ranges and 52 metadata columns\n     seqnames    ranges          strand\n        &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;\n [0]     chr1 101 - 110               *\n [1]     chr1 102 - 111               *\n [2]     chr2 102 - 111               -\n          ...       ...             ...\n[49]     chr2 123 - 132               +\n[50]     chr2 124 - 133               +\n[51]     chr3 105 - 109               -\n------\nseqinfo(3 sequences): chr1 chr2 chr3\n\n\n\nGenerate tiles from genome\ntile_genome returns a set of genomic regions that form a partitioning of the specified genome.\n\nseqlengths = {\"chr1\": 100, \"chr2\": 75, \"chr3\": 200}\n\ntiles = GenomicRanges.tile_genome(seqlengths=seqlengths, n=10)\nprint(tiles)\n\nGenomicRanges with 30 ranges and 30 metadata columns\n     seqnames    ranges          strand\n        &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;\n [0]     chr1    1 - 10               *\n [1]     chr1   11 - 20               *\n [2]     chr1   21 - 30               *\n          ...       ...             ...\n[27]     chr3 141 - 160               *\n[28]     chr3 161 - 180               *\n[29]     chr3 181 - 200               *\n------\nseqinfo(3 sequences): chr1 chr2 chr3"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#coverage",
    "href": "chapters/representations/genomicranges.html#coverage",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Coverage",
    "text": "Coverage\nComputes number of ranges that overlap for each position.\n\nimport rich \n\nres_vector = gr.coverage()\nrich.print(res_vector)\n\n{\n    'chr1': array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 1.,\n       1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]),\n    'chr2': array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1.,\n       1., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2.,\n       2., 2., 2., 2., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]),\n    'chr3': array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       1., 1., 2., 2., 2., 2., 2., 2., 1., 1., 1., 1., 1., 1., 1., 1., 1.,\n       1., 1., 1., 1., 1., 1., 1., 1., 1.])\n}\n\n\n\nLets see what the coverage looks like, now with seaborn:\n\nimport seaborn as sns\nvector = res_vector[\"chr1\"]\nsns.lineplot(data=pd.DataFrame({\n    \"position\": [i for i in range(len(vector))], \n    \"coverage\":vector\n}), x =\"position\", y=\"coverage\")\n\n&lt;Axes: xlabel='position', ylabel='coverage'&gt;\n\n\n\n\n\nI guess that looks ok. :) but someone can make this visualization better."
  },
  {
    "objectID": "chapters/representations/genomicranges.html#overlap-based-methods",
    "href": "chapters/representations/genomicranges.html#overlap-based-methods",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Overlap based methods",
    "text": "Overlap based methods\n\nfind_overlaps: Find overlaps between two GenomicRanges objects.\ncount_overlaps: Count overlaps between two GenomicRanges objects.\nsubset_by_overlaps: Subset a GenomicRanges object if it overlaps with the ranges in the query.\n\n\nsubject = GenomicRanges(\n    seqnames= [\"chr1\",\"chr2\",\"chr2\",\"chr2\",\"chr1\",\"chr1\",\"chr3\",\"chr3\",\"chr3\",\"chr3\"],\n    ranges=IRanges(range(101, 111), range(121, 131)),\n    strand= [\"*\", \"-\", \"-\", \"*\", \"*\", \"+\", \"+\", \"+\", \"-\", \"-\"],\n    mcols=BiocFrame({\n        \"score\": range(0, 10),\n    })\n)\n\ndf_query = pd.DataFrame(\n    {\"seqnames\": [\"chr2\",], \"starts\": [4], \"ends\": [6], \"strand\": [\"+\"]}\n)\n\nquery = GenomicRanges.from_pandas(df_query)\n\n# find Overlaps\nres = subject.find_overlaps(query, query_type=\"within\")\n\n# count Overlaps\nres = subject.count_overlaps(query)\n\n# subset by Overlaps\nres = subject.subset_by_overlaps(query)\n\nprint(res)\n\nGenomicRanges with 0 ranges and 0 metadata columns\nseqinfo(3 sequences): chr1 chr2 chr3"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#search-operations",
    "href": "chapters/representations/genomicranges.html#search-operations",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Search operations",
    "text": "Search operations\n\nnearest: Performs nearest neighbor search along any direction (both upstream and downstream).\nfollow: Performs nearest neighbor search only along downstream.\nprecede: Performs nearest neighbor search only along upstream.\n\n\nfind_regions = GenomicRanges(\n    seqnames= [\"chr1\", \"chr2\", \"chr3\"],\n    ranges=IRanges([200, 105, 1190],[203, 106, 1200]),\n)\n\nquery_hits = gr.nearest(find_regions)\n\nquery_hits = gr.precede(find_regions)\n\nquery_hits = gr.follow(find_regions)\n\nprint(query_hits)\n\n[[0], [2]]\n\n\n\n\n\n\n\n\nNote\n\n\n\nSimilar to IRanges operations, these methods typically return a list of indices from subject for each interval in query."
  },
  {
    "objectID": "chapters/representations/genomicranges.html#comparison-rank-and-order-operations",
    "href": "chapters/representations/genomicranges.html#comparison-rank-and-order-operations",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Comparison, rank and order operations",
    "text": "Comparison, rank and order operations\n\nmatch: Element-wise comparison to find exact match intervals.\norder: Get the order of indices for sorting.\nsort: Sort the GenomicRanges object.\nrank: For each interval identifies its position is a sorted order.\n\n\n# match\nquery_hits = gr.match(gr[2:5])\nprint(\"matches: \", query_hits)\n\n# order\norder = gr.order()\nprint(\"order:\", order)\n\n# sort\nsorted_gr = gr.sort()\nprint(\"sorted:\", sorted_gr)\n\n# rank\nrank = gr.rank()\nprint(\"rank:\", rank)\n\nmatches:  [[2], [3], [4]]\norder: [0 1 3 4 2]\nsorted: GenomicRanges with 5 ranges and 5 metadata columns\n    seqnames    ranges          strand    score                  GC\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;list&gt;              &lt;list&gt;\n[0]     chr1 101 - 112               * |      0  0.6638510057656181\n[1]     chr2 102 - 123               - |      1 0.41011469719249505\n[2]     chr2 104 - 134               + |      3  0.9830370779818972\n[3]     chr3 105 - 110               - |      4  0.3430893213778725\n[4]     chr3 103 - 128               * |      2  0.7761430162157152\n------\nseqinfo(3 sequences): chr1 chr2 chr3\nrank: [0, 1, 4, 2, 3]"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#combine-genomicranges-objects-by-rows",
    "href": "chapters/representations/genomicranges.html#combine-genomicranges-objects-by-rows",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Combine GenomicRanges objects by rows",
    "text": "Combine GenomicRanges objects by rows\nUse the combine generic from biocutils to concatenate multiple GenomicRanges objects.\n\nfrom biocutils.combine import combine\na = GenomicRanges(\n    seqnames=[\"chr1\", \"chr2\", \"chr1\", \"chr3\"],\n    ranges=IRanges([1, 3, 2, 4], [10, 30, 50, 60]),\n    strand=[\"-\", \"+\", \"*\", \"+\"],\n    mcols=BiocFrame({\"score\": [1, 2, 3, 4]}),\n)\n\nb = GenomicRanges(\n    seqnames=[\"chr2\", \"chr4\", \"chr5\"],\n    ranges=IRanges([3, 6, 4], [30, 50, 60]),\n    strand=[\"-\", \"+\", \"*\"],\n    mcols=BiocFrame({\"score\": [2, 3, 4]}),\n)\n\ncombined = combine(a,b)\nprint(combined)\n\nGenomicRanges with 7 ranges and 7 metadata columns\n    seqnames    ranges          strand    score\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;list&gt;\n[0]     chr1    1 - 11               - |      1\n[1]     chr2    3 - 33               + |      2\n[2]     chr1    2 - 52               * |      3\n[3]     chr3    4 - 64               + |      4\n[4]     chr1    3 - 33               - |      2\n[5]     chr2    6 - 56               + |      3\n[6]     chr3    4 - 64               * |      4\n------\nseqinfo(5 sequences): chr1 chr2 chr3 chr4 chr5"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#misc-operations",
    "href": "chapters/representations/genomicranges.html#misc-operations",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Misc operations",
    "text": "Misc operations\n\ninvert_strand: flip the strand for each interval\nsample: randomly choose k intervals\n\n\n# invert strand\ninv_gr = gr.invert_strand()\n\n# sample\nsamp_gr = gr.sample(k=4)"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#genomicrangeslist-class",
    "href": "chapters/representations/genomicranges.html#genomicrangeslist-class",
    "title": "GenomicRanges: Genomic analysis",
    "section": "GenomicRangesList class",
    "text": "GenomicRangesList class\nJust as it sounds, a GenomicRangesList is a named-list like object.\nIf you are wondering why you need this class, a GenomicRanges object lets us specify multiple genomic elements, usually where the genes start and end. Genes are themselves made of many sub regions, e.g. exons. GenomicRangesList allows us to represent this nested structure.\nCurrently, this class is limited in functionality, purely a read-only class with basic accessors.\nNote: This is a work in progress and the functionality is limited.\n\nfrom genomicranges import GenomicRangesList\na = GenomicRanges(\n    seqnames=[\"chr1\", \"chr2\", \"chr1\", \"chr3\"],\n    ranges=IRanges([1, 3, 2, 4], [10, 30, 50, 60]),\n    strand=[\"-\", \"+\", \"*\", \"+\"],\n    mcols=BiocFrame({\"score\": [1, 2, 3, 4]}),\n)\n\nb = GenomicRanges(\n    seqnames=[\"chr2\", \"chr4\", \"chr5\"],\n    ranges=IRanges([3, 6, 4], [30, 50, 60]),\n    strand=[\"-\", \"+\", \"*\"],\n    mcols=BiocFrame({\"score\": [2, 3, 4]}),\n)\n\ngrl = GenomicRangesList(ranges=[a,b], names=[\"gene1\", \"gene2\"])\nprint(grl)\n\nGenomicRangesList with 2 ranges and 2 metadata columns\n \nName: gene1 \nGenomicRanges with 4 ranges and 4 metadata columns\n    seqnames    ranges          strand    score\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;list&gt;\n[0]     chr1    1 - 11               - |      1\n[1]     chr2    3 - 33               + |      2\n[2]     chr1    2 - 52               * |      3\n[3]     chr3    4 - 64               + |      4\n------\nseqinfo(3 sequences): chr1 chr2 chr3\n \nName: gene2 \nGenomicRanges with 3 ranges and 3 metadata columns\n    seqnames    ranges          strand    score\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;list&gt;\n[0]     chr2    3 - 33               - |      2\n[1]     chr4    6 - 56               + |      3\n[2]     chr5    4 - 64               * |      4\n------\nseqinfo(3 sequences): chr2 chr4 chr5\n \n\n\n\n\nProperties\n\ngrl.start\ngrl.width\n\n{'gene1': array([10, 30, 50, 60], dtype=int32),\n 'gene2': array([30, 50, 60], dtype=int32)}\n\n\n\n\nCombine GenomicRangeslist object\nSimilar to the combine function from GenomicRanges,\n\ngrla = GenomicRangesList(ranges=[a], names=[\"a\"])\ngrlb = GenomicRangesList(ranges=[b, a], names=[\"b\", \"c\"])\n\n# or use the combine generic\nfrom biocutils.combine import combine\ncgrl = combine(grla, grlb)\n\nThe functionality in GenomicRangesLlist is limited to read-only and a few methods. Updates are expected to be made as more features become available."
  },
  {
    "objectID": "chapters/representations/genomicranges.html#empty-ranges",
    "href": "chapters/representations/genomicranges.html#empty-ranges",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Empty ranges",
    "text": "Empty ranges\nBoth of these classes can also contain no range information, and they tend to be useful when integrated into more extensive data structures but do not contain any data themselves.\nTo create an empty GenomicRanges object:\n\nempty_gr = GenomicRanges.empty()\n\nprint(empty_gr)\n\nGenomicRanges with 0 ranges and 0 metadata columns\n\n\n\nSimilarly, an empty GenomicRangesList can be created:\n\nempty_grl = GenomicRangesList.empty(n=100)\n\nprint(empty_grl)\n\nGenomicRangesList with 100 ranges and 100 metadata columns\n--- empty genomic ranges list ---"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#futher-reading",
    "href": "chapters/representations/genomicranges.html#futher-reading",
    "title": "GenomicRanges: Genomic analysis",
    "section": "Futher reading",
    "text": "Futher reading\n\nCheck out the reference documentation for more details.\nBioconductor’s GenomicRanges package."
  },
  {
    "objectID": "chapters/experiments/index.html",
    "href": "chapters/experiments/index.html",
    "title": "Represent experimental data",
    "section": "",
    "text": "BiocPy provides (currently) three classes to represented experimental data. This includes\n\nSummarizedExperiment (GitHub, Docs, BioC): Container class to represent genomic experiments, following Bioconductor’s SummarizedExperiment.\nSingleCellExperiment (GitHub, Docs, BioC): Container class to represent single-cell experiments; follows Bioconductor’s SingleCellExperiment.\nMultiAssayExperiment (GitHub, Docs, BioC): Container class to represent multiple experiments and assays performed over a set of samples. follows Bioconductor’s MAE R/Bioc Package."
  },
  {
    "objectID": "chapters/experiments/summarized_expt.html#installation",
    "href": "chapters/experiments/summarized_expt.html#installation",
    "title": "Summarized experiment",
    "section": "Installation",
    "text": "Installation\nTo get started, install the package from PyPI\npip install summarizedexperiment"
  },
  {
    "objectID": "chapters/experiments/summarized_expt.html#construction",
    "href": "chapters/experiments/summarized_expt.html#construction",
    "title": "Summarized experiment",
    "section": "Construction",
    "text": "Construction\nA SummarizedExperiment contains three key attributes,\n\nassays: A dictionary of matrices with assay names as keys, e.g. counts, logcounts etc.\nrow_data: Feature information e.g. genes, transcripts, exons, etc.\ncolumn_data: Sample information about the columns of the matrices.\n\nIn addition, these classes can optionally accept row_names and column_names. Since row_data and column_data may also contain names, the following rules are used in the implementation:\n\nOn construction, if row_names or column_names are not provided, these are automatically inferred from row_data and column_data objects.\nOn extraction of these objects, the row_names in row_data and column_data are replaced by the equivalents from the SE level.\nOn setters for these attributes, especially with the functional style (set_row_data and set_column_data methods), additional options are available to replace the names in the SE object.\n\n\n\n\n\n\n\nNote\n\n\n\nThis avoids unexpected mdifications in names, when either row_data or column_data objects are modified.\n\n\nTo construct a SummarizedExperiment, we’ll first generate a matrix of read counts, representing the read counts from a series of RNA-seq experiments. Following that, we’ll create a BiocFrame object to denote feature information and a table for column annotations. This table may include the names for the columns and any other values we wish to represent.\n\n\nShow the code\nfrom random import random\nimport pandas as pd\nimport numpy as np\nfrom biocframe import BiocFrame\n\nnrows = 200\nncols = 6\ncounts = np.random.rand(nrows, ncols)\nrow_data = BiocFrame(\n    {\n        \"seqnames\": [\n            \"chr1\",\n            \"chr2\",\n            \"chr2\",\n            \"chr2\",\n            \"chr1\",\n            \"chr1\",\n            \"chr3\",\n            \"chr3\",\n            \"chr3\",\n            \"chr3\",\n        ]\n        * 20,\n        \"starts\": range(100, 300),\n        \"ends\": range(110, 310),\n        \"strand\": [\"-\", \"+\", \"+\", \"*\", \"*\", \"+\", \"+\", \"+\", \"-\", \"-\"] * 20,\n        \"score\": range(0, 200),\n        \"GC\": [random() for _ in range(10)] * 20,\n    }\n)\n\ncol_data = pd.DataFrame(\n    {\n        \"treatment\": [\"ChIP\", \"Input\"] * 3,\n    }\n)\n\n\n\n\n\n\n\n\nNote\n\n\n\nrow_data and column_data are expected to be BiocFrame objects and will be coerced to a BiocFrame if a pandas DataFrame is provided.\n\n\nNow, we can construct a SummarizedExperiment from this information.\n\nfrom summarizedexperiment import SummarizedExperiment\n\nse = SummarizedExperiment(\n    assays={\"counts\": counts}, row_data=row_data, column_data=col_data\n)\n\nprint(se)\n\nclass: SummarizedExperiment\ndimensions: (200, 6)\nassays(1): ['counts']\nrow_data columns(6): ['seqnames', 'starts', 'ends', 'strand', 'score', 'GC']\nrow_names(0):  \ncolumn_data columns(1): ['treatment']\ncolumn_names(6): ['0', '1', '2', '3', '4', '5']\nmetadata(0): \n\n\n\nSimilarly, we can use the same information to construct a RangeSummarizedExperiment. We convert feature information into a GenomicRanges object and provide this as row_ranges:\n\nfrom genomicranges import GenomicRanges\nfrom summarizedexperiment import RangedSummarizedExperiment\n\ngr = GenomicRanges.from_pandas(row_data.to_pandas())\n\nrse = RangedSummarizedExperiment(\n    assays={\"counts\": counts}, row_data=row_data, row_ranges=gr, column_data=col_data\n)\nprint(rse)\n\nclass: RangedSummarizedExperiment\ndimensions: (200, 6)\nassays(1): ['counts']\nrow_data columns(6): ['seqnames', 'starts', 'ends', 'strand', 'score', 'GC']\nrow_names(0):  \ncolumn_data columns(1): ['treatment']\ncolumn_names(6): ['0', '1', '2', '3', '4', '5']\nmetadata(0):"
  },
  {
    "objectID": "chapters/experiments/summarized_expt.html#interop-with-anndata",
    "href": "chapters/experiments/summarized_expt.html#interop-with-anndata",
    "title": "Summarized experiment",
    "section": "Interop with anndata",
    "text": "Interop with anndata\nConverting a SummarizedExperiment to an AnnData representation is straightforward:\n\nadata = se.to_anndata()\nprint(adata)\n\nAnnData object with n_obs × n_vars = 6 × 200\n    obs: 'treatment'\n    var: 'seqnames', 'starts', 'ends', 'strand', 'score', 'GC'\n    layers: 'counts'\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/anndata/_core/anndata.py:183: ImplicitModificationWarning: Transforming to str index.\n  warnings.warn(\"Transforming to str index.\", ImplicitModificationWarning)\n\n\nTo convert an AnnData object to a BiocPy representation, utilize the from_anndata method in the SingleCellExperiment class. This minimizes the loss of information when converting between these two representations."
  },
  {
    "objectID": "chapters/experiments/summarized_expt.html#getterssetters",
    "href": "chapters/experiments/summarized_expt.html#getterssetters",
    "title": "Summarized experiment",
    "section": "Getters/Setters",
    "text": "Getters/Setters\nGetters are available to access various attributes using either the property notation or functional style.\n\n# access assay names\nprint(\"assay names (as property): \", se.assay_names)\nprint(\"assay names (functional style): \", se.get_assay_names())\n\n# access row data\nprint(se.row_data)\n\nassay names (as property):  ['counts']\nassay names (functional style):  ['counts']\nBiocFrame with 200 rows and 6 columns\n      seqnames  starts    ends strand   score                  GC\n        &lt;list&gt; &lt;range&gt; &lt;range&gt; &lt;list&gt; &lt;range&gt;              &lt;list&gt;\n  [0]     chr1     100     110      -       0   0.805045919022751\n  [1]     chr2     101     111      +       1   0.906667041291116\n  [2]     chr2     102     112      +       2  0.7340622989734025\n           ...     ...     ...    ...     ...                 ...\n[197]     chr3     297     307      +     197 0.39923472795479875\n[198]     chr3     298     308      -     198  0.7746093476017841\n[199]     chr3     299     309      -     199  0.1794915528660992\n\n\n\nAccess an assay\nOne can access an assay by index or name:\n\nse.assay(0) # same as se.assay(\"counts\")\n\narray([[0.26305447, 0.92399488, 0.64960236, 0.6489291 , 0.17325433,\n        0.90589701],\n       [0.50050008, 0.07763849, 0.59658758, 0.51918172, 0.06114396,\n        0.8924757 ],\n       [0.83694455, 0.42221886, 0.83436103, 0.91240514, 0.09806843,\n        0.0782599 ],\n       ...,\n       [0.74591971, 0.41652343, 0.4965012 , 0.31053038, 0.98434314,\n        0.82697205],\n       [0.73040088, 0.34269522, 0.71704094, 0.46740027, 0.684284  ,\n        0.12514363],\n       [0.3995428 , 0.1185062 , 0.98190858, 0.03216854, 0.85255268,\n        0.23504266]])\n\n\n\n\nSetters\n\n\n\n\n\n\nImportant\n\n\n\nAll property-based setters are in_place operations, with further details discussed in functional paradigm section.\n\n\n\nmodified_column_data = se.column_data.set_column(\"score\", range(10,16))\nmodified_se = se.set_column_data(modified_column_data)\nprint(modified_se)\n\nclass: SummarizedExperiment\ndimensions: (200, 6)\nassays(1): ['counts']\nrow_data columns(6): ['seqnames', 'starts', 'ends', 'strand', 'score', 'GC']\nrow_names(0):  \ncolumn_data columns(2): ['treatment', 'score']\ncolumn_names(6): ['0', '1', '2', '3', '4', '5']\nmetadata(0): \n\n\n\nNow, lets check the column_data on the original object.\n\nprint(se.column_data)\n\nBiocFrame with 6 rows and 1 column\n  treatment\n     &lt;list&gt;\n0      ChIP\n1     Input\n2      ChIP\n3     Input\n4      ChIP\n5     Input"
  },
  {
    "objectID": "chapters/experiments/summarized_expt.html#subset-experiments",
    "href": "chapters/experiments/summarized_expt.html#subset-experiments",
    "title": "Summarized experiment",
    "section": "Subset experiments",
    "text": "Subset experiments\nYou can subset experimental data by using the subset ([]) operator. This operation accepts different slice input types, such as a boolean vector, a slice object, a list of indices, or names (if available) to subset.\nIn our previous example, we didn’t include row or column names. Let’s create another SummarizedExperiment object that includes names.\n\n\nShow the code\nrow_data = BiocFrame({\n    \"seqnames\": [\"chr_5\", \"chr_3\", \"chr_2\"],\n    \"start\": [100, 200, 300],\n    \"end\": [110, 210, 310],\n})\n\ncol_data = BiocFrame({\n    \"sample\": [\"SAM_1\", \"SAM_3\", \"SAM_3\"],\n    \"disease\": [\"True\", \"True\", \"True\"],\n    },\n    row_names=[\"cell_1\", \"cell_2\", \"cell_3\"],\n)\n\nse_with_names = SummarizedExperiment(\n    assays={\n        \"counts\": np.random.poisson(lam=5, size=(3, 3)),\n        \"lognorm\": np.random.lognormal(size=(3, 3)),\n    },\n    row_data=row_data,\n    column_data=col_data,\n    row_names=[\"HER2\", \"BRCA1\", \"TPFK\"],\n    column_names=[\"cell_1\", \"cell_2\", \"cell_3\"],\n)\n\nprint(se_with_names)\n\n\nclass: SummarizedExperiment\ndimensions: (3, 3)\nassays(2): ['counts', 'lognorm']\nrow_data columns(3): ['seqnames', 'start', 'end']\nrow_names(3): ['HER2', 'BRCA1', 'TPFK']\ncolumn_data columns(2): ['sample', 'disease']\ncolumn_names(3): ['cell_1', 'cell_2', 'cell_3']\nmetadata(0): \n\n\n\n\nSubset by index position\nA straightforward slice operation:\n\nsubset_se = se_with_names[0:10, 0:3]\nprint(subset_se)\n\nclass: SummarizedExperiment\ndimensions: (3, 3)\nassays(2): ['counts', 'lognorm']\nrow_data columns(3): ['seqnames', 'start', 'end']\nrow_names(3): ['HER2', 'BRCA1', 'TPFK']\ncolumn_data columns(2): ['sample', 'disease']\ncolumn_names(3): ['cell_1', 'cell_2', 'cell_3']\nmetadata(0): \n\n\n\n\n\nSubset by row names or column names\nEither one or both of the slices can contain names. These names are mapped to row_names and column_names of the SummarizedExperiment object.\n\nsubset_se = se_with_names[:2, [\"cell_1\", \"cell_3\"]]\nprint(subset_se)\n\nclass: SummarizedExperiment\ndimensions: (2, 2)\nassays(2): ['counts', 'lognorm']\nrow_data columns(3): ['seqnames', 'start', 'end']\nrow_names(2): ['HER2', 'BRCA1']\ncolumn_data columns(2): ['sample', 'disease']\ncolumn_names(2): ['cell_1', 'cell_3']\nmetadata(0): \n\n\n\nAn Exception is raised if a names does not exist.\n\n\nSubset by boolean vector\nSimilarly, you can also slice by a boolean array. Note that the boolean vectors should contain the same number of features for the row slice and the same number of samples for the column slice.\n\nsubset_se_with_bools = se_with_names[[True, True, False], [True, False, True]]\n\n\n\nSubset by empty list\nThis is a feature not a bug :)\n\nsubset = se_with_names[:2, []]\nprint(subset)\n\nclass: SummarizedExperiment\ndimensions: (2, 0)\nassays(2): ['counts', 'lognorm']\nrow_data columns(3): ['seqnames', 'start', 'end']\nrow_names(2): ['HER2', 'BRCA1']\ncolumn_data columns(2): ['sample', 'disease']\ncolumn_names(0): []\nmetadata(0):"
  },
  {
    "objectID": "chapters/experiments/summarized_expt.html#range-based-operations",
    "href": "chapters/experiments/summarized_expt.html#range-based-operations",
    "title": "Summarized experiment",
    "section": "Range-based operations",
    "text": "Range-based operations\nAdditionally, since RangeSummarizedExperiment contain row_ranges, this allows us to perform a number of range based operations that are possible on a GenomicRanges object.\nFor example, to compute overlaps with a query range:\n\nfrom iranges import IRanges\nquery = GenomicRanges(seqnames=[\"chr2\"], ranges=IRanges([4], [6]), strand=[\"+\"])\n\nresult = rse.subset_by_overlaps(query)\nprint(result)\n\nclass: RangedSummarizedExperiment\ndimensions: (0, 6)\nassays(1): ['counts']\nrow_data columns(6): ['seqnames', 'starts', 'ends', 'strand', 'score', 'GC']\nrow_names(0):  \ncolumn_data columns(1): ['treatment']\ncolumn_names(6): ['0', '1', '2', '3', '4', '5']\nmetadata(0): \n\n\n\nAdditionally, RSE supports many other interval based operations. Checkout the documentation for more details."
  },
  {
    "objectID": "chapters/experiments/summarized_expt.html#combining-experiments",
    "href": "chapters/experiments/summarized_expt.html#combining-experiments",
    "title": "Summarized experiment",
    "section": "Combining experiments",
    "text": "Combining experiments\nSummarizedExperiment implements methods for the various combine generics from BiocUtils.\nThese methods enable the merging or combining of multiple SummarizedExperiment objects, allowing users to aggregate data from different experiments or conditions. To demonstrate, let’s create multiple SummarizedExperiment objects.\n\n\nShow the code\nrowData1 = pd.DataFrame(\n    {\n        \"seqnames\": [\"chr_5\", \"chr_3\", \"chr_2\"],\n        \"start\": [10293804, 12098948, 20984392],\n        \"end\": [28937947, 3872839, 329837492]\n    },\n    index=[\"HER2\", \"BRCA1\", \"TPFK\"],\n)\ncolData1 = pd.DataFrame(\n    {\n        \"sample\": [\"SAM_1\", \"SAM_3\", \"SAM_3\"],\n        \"disease\": [\"True\", \"True\", \"True\"],\n    },\n    index=[\"cell_1\", \"cell_2\", \"cell_3\"],\n)\nse1 = SummarizedExperiment(\n    assays={\n        \"counts\": np.random.poisson(lam=5, size=(3, 3)),\n        \"lognorm\": np.random.lognormal(size=(3, 3))\n    },\n    row_data=rowData1,\n    column_data=colData1,\n    metadata={\"seq_type\": \"paired\"},\n)\n\nrowData2 = pd.DataFrame(\n    {\n        \"seqnames\": [\"chr_5\", \"chr_3\", \"chr_2\"],\n        \"start\": [10293804, 12098948, 20984392],\n        \"end\": [28937947, 3872839, 329837492]\n    },\n    index=[\"HER2\", \"BRCA1\", \"TPFK\"],\n)\ncolData2 = pd.DataFrame(\n    {\n        \"sample\": [\"SAM_4\", \"SAM_5\", \"SAM_6\"],\n        \"disease\": [\"True\", \"False\", \"True\"],\n    },\n    index=[\"cell_4\", \"cell_5\", \"cell_6\"],\n)\nse2 = SummarizedExperiment(\n    assays={\n        \"counts\": np.random.poisson(lam=5, size=(3, 3)),\n        \"lognorm\": np.random.lognormal(size=(3, 3))\n    },\n    row_data=rowData2,\n    column_data=colData2,\n    metadata={\"seq_platform\": \"Illumina NovaSeq 6000\"},\n)\n\nrowData3 = pd.DataFrame(\n    {\n        \"seqnames\": [\"chr_7\", \"chr_1\", \"chr_Y\"],\n        \"start\": [1084390, 1874937, 243879798],\n        \"end\": [243895239, 358908298, 390820395]\n    },\n    index=[\"MYC\", \"BRCA2\", \"TPFK\"],\n)\ncolData3 = pd.DataFrame(\n    {\n        \"sample\": [\"SAM_7\", \"SAM_8\", \"SAM_9\"],\n        \"disease\": [\"True\", \"False\", \"False\"],\n        \"doublet_score\": [.15, .62, .18]\n    },\n    index=[\"cell_7\", \"cell_8\", \"cell_9\"],\n)\nse3 = SummarizedExperiment(\n    assays={\n        \"counts\": np.random.poisson(lam=5, size=(3, 3)),\n        \"lognorm\": np.random.lognormal(size=(3, 3)),\n        \"beta\": np.random.beta(a=1, b=1, size=(3, 3))\n    },\n    row_data=rowData3,\n    column_data=colData3,\n    metadata={\"seq_platform\": \"Illumina NovaSeq 6000\"},\n)\n\nprint(se1)\nprint(se2)\nprint(se3)\n\n\nclass: SummarizedExperiment\ndimensions: (3, 3)\nassays(2): ['counts', 'lognorm']\nrow_data columns(3): ['seqnames', 'start', 'end']\nrow_names(3): ['HER2', 'BRCA1', 'TPFK']\ncolumn_data columns(2): ['sample', 'disease']\ncolumn_names(3): ['cell_1', 'cell_2', 'cell_3']\nmetadata(1): seq_type\n\nclass: SummarizedExperiment\ndimensions: (3, 3)\nassays(2): ['counts', 'lognorm']\nrow_data columns(3): ['seqnames', 'start', 'end']\nrow_names(3): ['HER2', 'BRCA1', 'TPFK']\ncolumn_data columns(2): ['sample', 'disease']\ncolumn_names(3): ['cell_4', 'cell_5', 'cell_6']\nmetadata(1): seq_platform\n\nclass: SummarizedExperiment\ndimensions: (3, 3)\nassays(3): ['counts', 'lognorm', 'beta']\nrow_data columns(3): ['seqnames', 'start', 'end']\nrow_names(3): ['MYC', 'BRCA2', 'TPFK']\ncolumn_data columns(3): ['sample', 'disease', 'doublet_score']\ncolumn_names(3): ['cell_7', 'cell_8', 'cell_9']\nmetadata(1): seq_platform\n\n\n\nThe combine_rows or combine_columns operations, expect all experiments to contain the same assay names. To combine experiments by row:\n\nfrom biocutils import relaxed_combine_columns, combine_columns, combine_rows, relaxed_combine_rows\nse_combined = combine_rows(se2, se1)\nprint(se_combined)\n\nclass: SummarizedExperiment\ndimensions: (6, 3)\nassays(2): ['lognorm', 'counts']\nrow_data columns(3): ['seqnames', 'start', 'end']\nrow_names(6): ['HER2', 'BRCA1', 'TPFK', 'HER2', 'BRCA1', 'TPFK']\ncolumn_data columns(2): ['sample', 'disease']\ncolumn_names(3): ['cell_4', 'cell_5', 'cell_6']\nmetadata(1): seq_platform\n\n\n\nSimilarly to combine by column:\n\nse_combined = combine_columns(se2, se1)\nprint(se_combined)\n\nclass: SummarizedExperiment\ndimensions: (3, 6)\nassays(2): ['lognorm', 'counts']\nrow_data columns(3): ['seqnames', 'start', 'end']\nrow_names(3): ['HER2', 'BRCA1', 'TPFK']\ncolumn_data columns(2): ['sample', 'disease']\ncolumn_names(6): ['cell_4', 'cell_5', 'cell_6', 'cell_1', 'cell_2', 'cell_3']\nmetadata(1): seq_platform\n\n\n\nYou can use relaxed_combine_columns or relaxed_combined_rows when there’s mismatch in the number of features or samples. Missing rows or columns in any object are filled in with appropriate placeholder values before combining, e.g. missing assay’s are replaced with a masked numpy array.\n\n# se3 contains an additional assay not present in se1\nse_relaxed_combine = relaxed_combine_columns(se3, se1)\nprint(se_relaxed_combine)\n\nclass: SummarizedExperiment\ndimensions: (3, 6)\nassays(3): ['lognorm', 'counts', 'beta']\nrow_data columns(3): ['seqnames', 'start', 'end']\nrow_names(3): ['MYC', 'BRCA2', 'TPFK']\ncolumn_data columns(3): ['sample', 'disease', 'doublet_score']\ncolumn_names(6): ['cell_7', 'cell_8', 'cell_9', 'cell_1', 'cell_2', 'cell_3']\nmetadata(1): seq_platform"
  },
  {
    "objectID": "chapters/experiments/summarized_expt.html#empty-experiments",
    "href": "chapters/experiments/summarized_expt.html#empty-experiments",
    "title": "Summarized experiment",
    "section": "Empty experiments",
    "text": "Empty experiments\nBoth these classes can also contain no experimental data, and they tend to be useful when integrated into more extensive data structures but do not contain any data themselves.\nTo create an empty SummarizedExperiment:\n\nempty_se = SummarizedExperiment()\nprint(empty_se)\n\nclass: SummarizedExperiment\ndimensions: (0, 0)\nassays(0): []\nrow_data columns(0): []\nrow_names(0):  \ncolumn_data columns(0): []\ncolumn_names(0):  \nmetadata(0): \n\n\n\nSimilarly an empty RangeSummarizedExperiment:\n\nempty_rse = RangedSummarizedExperiment()\nprint(empty_rse)\n\nclass: RangedSummarizedExperiment\ndimensions: (0, 0)\nassays(0): []\nrow_data columns(0): []\nrow_names(0):  \ncolumn_data columns(0): []\ncolumn_names(0):  \nmetadata(0):"
  },
  {
    "objectID": "chapters/experiments/summarized_expt.html#further-reading",
    "href": "chapters/experiments/summarized_expt.html#further-reading",
    "title": "Summarized experiment",
    "section": "Further reading",
    "text": "Further reading\n\nCheck out reference documentation for more details.\nR/Bioconductor’s SummarizedExperiment package."
  },
  {
    "objectID": "chapters/experiments/singlecell_expt.html#installation",
    "href": "chapters/experiments/singlecell_expt.html#installation",
    "title": "Single-cell experiment",
    "section": "Installation",
    "text": "Installation\nTo get started, install the package from PyPI\npip install singlecellexperiment"
  },
  {
    "objectID": "chapters/experiments/singlecell_expt.html#construction",
    "href": "chapters/experiments/singlecell_expt.html#construction",
    "title": "Single-cell experiment",
    "section": "Construction",
    "text": "Construction\nThe SingleCellExperiment extends RangeSummarizedExperiment and contains few additional attributes:\n\nreduced_dims: Slot for low-dimensionality embeddings for each cell.\nalternative_experiments: Manages multi-modal experiments performed on the same sample or set of cells.\nrow_pairs or column_pairs: Stores relationships between features or cells.\n\nIn contrast to R, matrices in Python are unnamed and do not contain row or column names. Hence, these matrices cannot be directly used as values in assays or alternative experiments. We strictly enforce type checks in these cases. To relax these restrictions for alternative experiments, set type_check_alternative_experiments to False.\nIf you are using the alternative_experiments slot, the number of cells must match the parent experiment. Otherwise, the expectation is that the cells do not share the same sample or annotations and cannot be set in alternative experiments!\nNote: Validation checks do not apply to row_pairs or col_pairs.\nBefore we construct a SingleCellExperiment object, lets generate information about rows, columns and a mock experimental data from single-cell rna-seq experiments:\n\n\nShow the code\nimport pandas as pd\nimport numpy as np\nfrom scipy import sparse as sp\nfrom biocframe import BiocFrame\nfrom genomicranges import GenomicRanges\nfrom random import random \n\nnrows = 200\nncols = 6\ncounts = sp.rand(nrows, ncols, density=0.2, format=\"csr\")\nrow_data = BiocFrame(\n    {\n        \"seqnames\": [\n            \"chr1\",\n            \"chr2\",\n            \"chr2\",\n            \"chr2\",\n            \"chr1\",\n            \"chr1\",\n            \"chr3\",\n            \"chr3\",\n            \"chr3\",\n            \"chr3\",\n        ]\n        * 20,\n        \"starts\": range(100, 300),\n        \"ends\": range(110, 310),\n        \"strand\": [\"-\", \"+\", \"+\", \"*\", \"*\", \"+\", \"+\", \"+\", \"-\", \"-\"] * 20,\n        \"score\": range(0, 200),\n        \"GC\": [random() for _ in range(10)] * 20,\n    }\n)\n\ncol_data = pd.DataFrame(\n    {\n        \"celltype\": [\"cluster1\", \"cluster2\"] * 3,\n    }\n)\n\ncounts\n\n\n&lt;200x6 sparse matrix of type '&lt;class 'numpy.float64'&gt;'\n    with 240 stored elements in Compressed Sparse Row format&gt;\n\n\nNow lets create the SingleCellExperiment instance:\n\nfrom singlecellexperiment import SingleCellExperiment\n\nsce = SingleCellExperiment(\n    assays={\"counts\": counts}, row_data=row_data, column_data=col_data,\n    reduced_dims = {\"random_embeds\": np.random.rand(ncols, 4)}\n)\n\nprint(sce)\n\nclass: SingleCellExperiment\ndimensions: (200, 6)\nassays(1): ['counts']\nrow_data columns(6): ['seqnames', 'starts', 'ends', 'strand', 'score', 'GC']\nrow_names(0):  \ncolumn_data columns(1): ['celltype']\ncolumn_names(6): ['0', '1', '2', '3', '4', '5']\nmain_experiment_name:  \nreduced_dims(1): ['random_embeds']\nalternative_experiments(0): []\nrow_pairs(0): []\ncolumn_pairs(0): []\nmetadata(0): \n\n\n\n\nInterop with anndata\nWe provide convenient methods for loading an AnnData or h5ad file into SingleCellExperiment objects.\nFor example, lets create an AnnData object,\n\nimport anndata as ad\nfrom scipy import sparse as sp\n\ncounts = sp.csr_matrix(np.random.poisson(1, size=(100, 2000)), dtype=np.float32)\nadata = ad.AnnData(counts)\nadata\n\nAnnData object with n_obs × n_vars = 100 × 2000\n\n\nConverting AnnData as SingleCellExperiment is straightforward:\n\nsce_adata = SingleCellExperiment.from_anndata(adata) \n\nand vice-verse. All assays from SCE are represented in the layers slot of the AnnData object:\n\nadata2 = sce_adata.to_anndata()\nprint(adata2)\n\n(AnnData object with n_obs × n_vars = 100 × 2000\n    obs: 0, 1\n    var: 0, 1\n    layers: 'X', None)\n\n\nSimilarly, one can load a h5ad file:\n\nfrom singlecellexperiment import read_h5ad\nsce_h5 = read_h5ad(\"../../assets/data/adata.h5ad\")\nprint(sce_h5)\n\nclass: SingleCellExperiment\ndimensions: (20, 30)\nassays(3): ['array', 'sparse', 'X']\nrow_data columns(5): ['var_cat', 'cat_ordered', 'int64', 'float64', 'uint8']\nrow_names(20): ['gene0', 'gene1', 'gene2', ..., 'gene17', 'gene18', 'gene19']\ncolumn_data columns(5): ['obs_cat', 'cat_ordered', 'int64', 'float64', 'uint8']\ncolumn_names(30): ['cell0', 'cell1', 'cell2', ..., 'cell27', 'cell28', 'cell29']\nmain_experiment_name:  \nreduced_dims(0): []\nalternative_experiments(0): []\nrow_pairs(0): []\ncolumn_pairs(0): []\nmetadata(2): O_recarray nested\n\n\n\n\n\nfrom tenx formats\nIn addition, we also provide convenient methods to load a 10X H5 file. We currently only support version 3 of the 10X H5 format.\n\nfrom singlecellexperiment import read_tenx_h5\nsce_h5 = read_tenx_h5(\"../../assets/data/tenx.sub.h5\")\nprint(sce_h5)\n\nclass: SingleCellExperiment\ndimensions: (1000, 3005)\nassays(1): ['counts']\nrow_data columns(2): ['id', 'name']\nrow_names(0):  \ncolumn_data columns(0): []\ncolumn_names(0):  \nmain_experiment_name:  \nreduced_dims(0): []\nalternative_experiments(0): []\nrow_pairs(0): []\ncolumn_pairs(0): []\nmetadata(0): \n\n\n\n\n\n\n\n\n\nNote\n\n\n\nMethods are also available to read a 10x matrix market directory using the read_tenx_mtx function."
  },
  {
    "objectID": "chapters/experiments/singlecell_expt.html#getterssetters",
    "href": "chapters/experiments/singlecell_expt.html#getterssetters",
    "title": "Single-cell experiment",
    "section": "Getters/Setters",
    "text": "Getters/Setters\nGetters are available to access various attributes using either the property notation or functional style.\nSince SingleCellExperiment extends RangedSummarizedExperiment, all getters and setters from the base class are accessible here; more details here.\n\n# access assay names\nprint(\"reduced dim names (as property): \", sce.reduced_dim_names)\nprint(\"reduced dim names (functional style): \", sce.get_reduced_dim_names())\n\n# access row data\nprint(sce.row_data)\n\nreduced dim names (as property):  ['random_embeds']\nreduced dim names (functional style):  ['random_embeds']\nBiocFrame with 200 rows and 6 columns\n      seqnames  starts    ends strand   score                   GC\n        &lt;list&gt; &lt;range&gt; &lt;range&gt; &lt;list&gt; &lt;range&gt;               &lt;list&gt;\n  [0]     chr1     100     110      -       0   0.4803557596231137\n  [1]     chr2     101     111      +       1 0.053072468479367974\n  [2]     chr2     102     112      +       2   0.5974262093336514\n           ...     ...     ...    ...     ...                  ...\n[197]     chr3     297     307      +     197   0.1714865999403169\n[198]     chr3     298     308      -     198   0.7085067304129551\n[199]     chr3     299     309      -     199   0.9506610052947431\n\n\n\nAccess a reduced dimension\nOne can access an reduced dimension by index or name:\n\nsce.reduced_dim(0) # same as se.reduced_dim(\"random_embeds\")\n\narray([[0.82249382, 0.1581809 , 0.64207603, 0.51303756],\n       [0.61183549, 0.96439367, 0.37372966, 0.00801112],\n       [0.06836007, 0.92586574, 0.9994667 , 0.80714631],\n       [0.48667472, 0.63318741, 0.76069894, 0.20654633],\n       [0.46830125, 0.48082703, 0.7951699 , 0.24119777],\n       [0.33414236, 0.78956086, 0.69771023, 0.8129552 ]])"
  },
  {
    "objectID": "chapters/experiments/singlecell_expt.html#subset-experiments",
    "href": "chapters/experiments/singlecell_expt.html#subset-experiments",
    "title": "Single-cell experiment",
    "section": "Subset experiments",
    "text": "Subset experiments\nYou can subset experimental data by using the subset ([]) operator. This operation accepts different slice input types, such as a boolean vector, a slice object, a list of indices, or names (if available) to subset.\nIn our previous example, we didn’t include row or column names. Let’s create another SingleCellExperiment object that includes names.\n\nsubset_sce = sce[0:10, 0:3]\nprint(subset_sce)\n\nclass: SingleCellExperiment\ndimensions: (10, 3)\nassays(1): ['counts']\nrow_data columns(6): ['seqnames', 'starts', 'ends', 'strand', 'score', 'GC']\nrow_names(0):  \ncolumn_data columns(1): ['celltype']\ncolumn_names(3): ['0', '1', '2']\nmain_experiment_name:  \nreduced_dims(1): ['random_embeds']\nalternative_experiments(0): []\nrow_pairs(0): []\ncolumn_pairs(0): []\nmetadata(0):"
  },
  {
    "objectID": "chapters/experiments/singlecell_expt.html#export-as-mudata",
    "href": "chapters/experiments/singlecell_expt.html#export-as-mudata",
    "title": "Single-cell experiment",
    "section": "Export as MuData",
    "text": "Export as MuData\nThe package also provides methods to convert a SingleCellExperiment object into a MuData representation:\n\nmdata = sce.to_mudata()\nmdata\n\nAttributeError: 'int' object has no attribute 'startswith'\n\n\nAttributeError: 'int' object has no attribute 'startswith'"
  },
  {
    "objectID": "chapters/experiments/singlecell_expt.html#further-reading",
    "href": "chapters/experiments/singlecell_expt.html#further-reading",
    "title": "Single-cell experiment",
    "section": "Further reading",
    "text": "Further reading\n\nCheck out reference documentation for more details.\nR/Bioconductor’s SingleCellExperiment package."
  },
  {
    "objectID": "chapters/experiments/extending_se.html#define-the-new-class",
    "href": "chapters/experiments/extending_se.html#define-the-new-class",
    "title": "Extending summarized experiments",
    "section": "Define the new class",
    "text": "Define the new class\nAs a simple example, let’s create a new class called BioSampleSE that stores biosample information on which the experiment was conducted. This may contain anonymized information about the patient(s) or sample(s). First, we extend the SummarizedExperiment class:\n\nfrom summarizedexperiment import SummarizedExperiment\n\nclass BioSampleSE(SummarizedExperiment):\n    pass"
  },
  {
    "objectID": "chapters/experiments/extending_se.html#add-a-new-slot-or-attribute",
    "href": "chapters/experiments/extending_se.html#add-a-new-slot-or-attribute",
    "title": "Extending summarized experiments",
    "section": "Add a new slot or attribute",
    "text": "Add a new slot or attribute\nTo add a new slot to this class, we accept a new parameter bio_sample_information when the class is initialized through the init method. We also provide type hints to set expectations on the accepted types for these arguments. Type hints are helpful for users and are automatically annotated in the documentation. More information on type hints can be found in our developer guide.\nWe forward the default parameters to the base SummarizedExperiment class (using the super method) and store the new attribute.\n\nfrom summarizedexperiment import SummarizedExperiment\nimport biocframe\nfrom typing import Dict, Any, List, Optional\n\nclass BioSampleSE(SummarizedExperiment):\n    \n    def __init__(\n        self,\n        assays: Dict[str, Any] = None,\n        row_data: Optional[biocframe.BiocFrame] = None,\n        column_data: Optional[biocframe.BiocFrame] = None,\n        row_names: Optional[List[str]] = None,\n        column_names: Optional[List[str]] = None,\n        metadata: Optional[dict] = None,\n        bio_sample_information: Optional[biocframe.BiocFrame] = None, # NEW SLOT\n        validate: bool = True,\n    ) -&gt; None:\n        super().__init__(\n            assays,\n            row_data=row_data,\n            column_data=column_data,\n            row_names=row_names,\n            column_names=column_names,\n            metadata=metadata,\n            validate=validate,\n        )\n\n        self._bio_sample_information = bio_sample_information\n\nThe new slot can be validated using a dedicated validator:\n\ndef _validate_bio_sample_information(bio_sample_info):\n    if not isinstance(bio_sample_info, biocframe.BiocFrame):\n        raise Exception(\"Biosample information must be a BiocFrame object.\")\n\n    # any other validations. for example, if you have expectations on the columns \n    # of this frame or the number of rows. \n\nOur class now validates the new slot:\n\nclass BioSampleSE(SummarizedExperiment):\n    \n    def __init__(\n        self,\n        assays: Dict[str, Any] = None,\n        row_data: Optional[biocframe.BiocFrame] = None,\n        column_data: Optional[biocframe.BiocFrame] = None,\n        row_names: Optional[List[str]] = None,\n        column_names: Optional[List[str]] = None,\n        metadata: Optional[dict] = None,\n        bio_sample_information: Optional[biocframe.BiocFrame] = None, # NEW SLOT\n        validate: bool = True,\n    ) -&gt; None:\n        super().__init__(\n            assays,\n            row_data=row_data,\n            column_data=column_data,\n            row_names=row_names,\n            column_names=column_names,\n            metadata=metadata,\n            validate=validate,\n        )\n\n        self._bio_sample_information = bio_sample_information\n\n        if validate:\n            _validate_bio_sample_information(self._bio_sample_information)"
  },
  {
    "objectID": "chapters/experiments/extending_se.html#define-getterssetters",
    "href": "chapters/experiments/extending_se.html#define-getterssetters",
    "title": "Extending summarized experiments",
    "section": "Define getters/setters",
    "text": "Define getters/setters\nWe need accessors and setters so users can interact with this new property. We provide these accessors in both functional and property-based approaches. More details can be found in our class design document.\ndef get_bio_sample_information(self) -&gt; Optional[biocframe.BiocFrame]:\n    \"\"\"Get biosample information.\n\n    Returns:\n        biosample information or None if not availabl.\n    \"\"\"\n    return self._bio_sample_information\n\ndef set_bio_sample_information(\n    self, bio_sample_information: Optional[biocframe.BiocFrame], in_place: bool = False\n) -&gt; \"BioSampleSE\":\n    \"\"\"Set new biosample information.\n\n    Args:\n        bio_sample_information:\n            A new `BiocFrame` object containing biosample information.\n\n        in_place:\n            Whether to modify the ``BioSampleSE`` in place.\n\n    Returns:\n        A modified ``BioSampleSE`` object, either as a copy of the original\n        or as a reference to the (in-place-modified) original.\n    \"\"\"\n    _validate_bio_sample_information(bio_sample_info)\n\n    output = self._define_output(in_place) # MAKES A SHALLOW COPY\n    output._bio_sample_information = bio_sample_info\n    return output\nAdditionally, let’s provide property-based accessors to the new attribute:\n@property\ndef bio_sample_information(self) -&gt; biocframe.BiocFrame:\n    \"\"\"Alias for :py:meth:`~get_bio_sample_info`.\"\"\"\n    return self.get_bio_sample_info()\n\n@bio_sample_information.setter\ndef bio_sample_information(self, bio_sample_info: biocframe.BiocFrame) -&gt; None:\n    \"\"\"Alias for :py:meth:`~set_bio_sample_info`.\"\"\"\n    warn(\n        \"Setting property 'bio_sample_information' is an in-place operation, use 'set_bio_sample_info' instead\",\n        UserWarning,\n    )\n    return self.set_bio_sample_information(row_ranges=row_ranges, in_place=True)\nThis allows users to easily access the new property using the dot notation on an instance, for example, obj.bio_sample_info provides access to the attribute."
  },
  {
    "objectID": "chapters/experiments/extending_se.html#define-shallow-and-deep-copy-methods",
    "href": "chapters/experiments/extending_se.html#define-shallow-and-deep-copy-methods",
    "title": "Extending summarized experiments",
    "section": "Define shallow and deep copy methods",
    "text": "Define shallow and deep copy methods\nTo avoid mutating objects in-place, methods for making shallow and deep copies of the class attributes are implemented.\ndef __deepcopy__(self, memo=None, _nil=[]):\n    \"\"\"\n    Returns:\n        A deep copy of the current ``BioSampleSE``.\n    \"\"\"\n    from copy import deepcopy\n\n    _assays_copy = deepcopy(self._assays)\n    _rows_copy = deepcopy(self._rows)\n    _cols_copy = deepcopy(self._cols)\n    _row_names_copy = deepcopy(self._row_names)\n    _col_names_copy = deepcopy(self._column_names)\n    _bio_sample_information_copy = deepcopy(self._bio_sample_information)\n    _metadata_copy = deepcopy(self.metadata)\n\n    current_class_const = type(self)\n    return current_class_const(\n        assays=_assays_copy,\n        row_data=_rows_copy,\n        column_data=_cols_copy,\n        row_names=_row_names_copy,\n        column_names=_col_names_copy,\n        bio_sample_information=_bio_sample_information_copy,\n        metadata=_metadata_copy,\n    )\n\ndef __copy__(self):\n    \"\"\"\n    Returns:\n        A shallow copy of the current ``BioSampleSE``.\n    \"\"\"\n    current_class_const = type(self)\n    return current_class_const(\n        assays=self._assays,\n        row_data=self._rows,\n        column_data=self._cols,\n        row_names=self._row_names,\n        column_names=self._column_names,\n        bio_sample_information=self._bio_sample_information,\n        metadata=self._metadata,\n    )\n\ndef copy(self):\n    \"\"\"Alias for :py:meth:`~__copy__`.\"\"\"\n    return self.__copy__()"
  },
  {
    "objectID": "chapters/experiments/extending_se.html#subset-operation",
    "href": "chapters/experiments/extending_se.html#subset-operation",
    "title": "Extending summarized experiments",
    "section": "Subset operation",
    "text": "Subset operation\nWhen the experiment is subsetted using the [] operator, we may also have to subset the new slots added to the extended class. Developers only need to extend the get_slice function from the base class that accepts row and column subsets. The _generic_slice function returns a slicer object containing normalized row and column indices, and properties from the base class.\nfrom typing import Sequence\n\ndef get_slice(\n    self,\n    rows: Optional[Union[str, int, bool, Sequence]],\n    columns: Optional[Union[str, int, bool, Sequence]],\n) -&gt; \"BioSampleSE\":\n    \"\"\"Alias for :py:attr:`~__getitem__`, for back-compatibility.\"\"\"\n\n    slicer = self._generic_slice(rows=rows, columns=columns)\n\n    # An illustrative example\n    new_bio_sample_info = None\n    if slicer.row_indices != slice(None):\n        new_bio_sample_info = self.bio_sample_info[slicer.row_indices]\n\n    current_class_const = type(self)\n    return current_class_const(\n        assays=slicer.assays,\n        row_data=slicer.rows,\n        column_data=slicer.columns,\n        row_names=slicer.row_names,\n        column_names=slicer.column_names,\n        bio_sample_info=self.bio_sample_info.\n        metadata=self._metadata,\n    )"
  },
  {
    "objectID": "chapters/experiments/extending_se.html#putting-it-all-together",
    "href": "chapters/experiments/extending_se.html#putting-it-all-together",
    "title": "Extending summarized experiments",
    "section": "Putting it all together",
    "text": "Putting it all together\n\n\nShow the full class\ndef _validate_bio_sample_information(bio_sample_info):\n    if not isinstance(bio_sample_info, biocframe.BiocFrame):\n        raise Exception(\"Biosample information must be a BiocFrame object.\")\n\nclass BioSampleSE(SummarizedExperiment):\n    \n    def __init__(\n        self,\n        assays: Dict[str, Any] = None,\n        row_data: Optional[biocframe.BiocFrame] = None,\n        column_data: Optional[biocframe.BiocFrame] = None,\n        row_names: Optional[List[str]] = None,\n        column_names: Optional[List[str]] = None,\n        metadata: Optional[dict] = None,\n        bio_sample_information: Optional[biocframe.BiocFrame] = None, # NEW SLOT\n        validate: bool = True,\n    ) -&gt; None:\n        super().__init__(\n            assays,\n            row_data=row_data,\n            column_data=column_data,\n            row_names=row_names,\n            column_names=column_names,\n            metadata=metadata,\n            validate=validate,\n        )\n\n        self._bio_sample_information = bio_sample_information\n\n        if validate:\n            _validate_bio_sample_information(self._bio_sample_information)\n\n    def __deepcopy__(self, memo=None, _nil=[]):\n        \"\"\"\n        Returns:\n            A deep copy of the current ``BioSampleSE``.\n        \"\"\"\n        from copy import deepcopy\n\n        _assays_copy = deepcopy(self._assays)\n        _rows_copy = deepcopy(self._rows)\n        _cols_copy = deepcopy(self._cols)\n        _row_names_copy = deepcopy(self._row_names)\n        _col_names_copy = deepcopy(self._column_names)\n        _bio_sample_information_copy = deepcopy(self._bio_sample_information)\n        _metadata_copy = deepcopy(self.metadata)\n\n        current_class_const = type(self)\n        return current_class_const(\n            assays=_assays_copy,\n            row_data=_rows_copy,\n            column_data=_cols_copy,\n            row_names=_row_names_copy,\n            column_names=_col_names_copy,\n            bio_sample_information=_bio_sample_information_copy,\n            metadata=_metadata_copy,\n        )\n\n    def __copy__(self):\n        \"\"\"\n        Returns:\n            A shallow copy of the current ``BioSampleSE``.\n        \"\"\"\n        current_class_const = type(self)\n        return current_class_const(\n            assays=self._assays,\n            row_data=self._rows,\n            column_data=self._cols,\n            row_names=self._row_names,\n            column_names=self._column_names,\n            bio_sample_information=self._bio_sample_information,\n            metadata=self._metadata,\n        )\n\n    def copy(self):\n        \"\"\"Alias for :py:meth:`~__copy__`.\"\"\"\n        return self.__copy__()\n\n\n    def get_bio_sample_information(self) -&gt; Optional[biocframe.BiocFrame]:\n        \"\"\"Get biosample information.\n\n        Returns:\n            biosample information or None if not availabl.\n        \"\"\"\n        return self._bio_sample_information\n\n    def set_bio_sample_information(\n        self, bio_sample_information: Optional[biocframe.BiocFrame], in_place: bool = False\n    ) -&gt; \"BioSampleSE\":\n        \"\"\"Set new biosample information.\n\n        Args:\n            bio_sample_information:\n                A new `BiocFrame` object containing biosample information.\n\n            in_place:\n                Whether to modify the ``BioSampleSE`` in place.\n\n        Returns:\n            A modified ``BioSampleSE`` object, either as a copy of the original\n            or as a reference to the (in-place-modified) original.\n        \"\"\"\n        _validate_bio_sample_information(bio_sample_info)\n\n        output = self._define_output(in_place) # MAKES A SHALLOW COPY\n        output._bio_sample_information = bio_sample_info\n        return output\n\n\n    @property\n    def bio_sample_information(self) -&gt; biocframe.BiocFrame:\n        \"\"\"Alias for :py:meth:`~get_bio_sample_info`.\"\"\"\n        return self.get_bio_sample_info()\n\n    @bio_sample_information.setter\n    def bio_sample_information(self, bio_sample_info: biocframe.BiocFrame) -&gt; None:\n        \"\"\"Alias for :py:meth:`~set_bio_sample_info`.\"\"\"\n        warn(\n            \"Setting property 'bio_sample_information' is an in-place operation, use 'set_bio_sample_info' instead\",\n            UserWarning,\n        )\n        return self.set_bio_sample_information(row_ranges=row_ranges, in_place=True)\n\n\nThat’s the minimum required to extend a SummarizedExperiment and adapt it to new use cases. Please follow the developer guide, which provides information on class design, package setup, and documentation to ensure consistency in how BiocPy-related packages are developed."
  },
  {
    "objectID": "chapters/experiments/multiassay_expt.html#installation",
    "href": "chapters/experiments/multiassay_expt.html#installation",
    "title": "Multiple experiments",
    "section": "Installation",
    "text": "Installation\nTo get started, install the package from PyPI\npip install multiassayexperiment"
  },
  {
    "objectID": "chapters/experiments/multiassay_expt.html#construction",
    "href": "chapters/experiments/multiassay_expt.html#construction",
    "title": "Multiple experiments",
    "section": "Construction",
    "text": "Construction\nAn MAE contains three main entities,\n\nPrimary information (column_data): Bio-specimen/sample information. The column_data may provide information about patients, cell lines, or other biological units. Each row in this table represents an independent biological unit. It must contain an index that maps to the ‘primary’ in sample_map.\nExperiments (experiments): Genomic data from each experiment. either a SingleCellExperiment, SummarizedExperiment, RangedSummarizedExperiment or any class that extends a SummarizedExperiment.\nSample Map (sample_map): Map biological units from column_data to the list of experiments. Must contain columns,\n\nassay provides the names of the different experiments performed on the biological units. All experiment names from experiments must be present in this column.\nprimary contains the sample name. All names in this column must match with row labels from col_data.\ncolname is the mapping of samples/cells within each experiment back to its biosample information in col_data.\n\nEach sample in column_data may map to one or more columns per assay.\n\nLet’s start by first creating few experiments:\n\n\nShow the code\nfrom random import random\n\nimport numpy as np\nfrom biocframe import BiocFrame\nfrom genomicranges import GenomicRanges\nfrom iranges import IRanges\n\nnrows = 200\nncols = 6\ncounts = np.random.rand(nrows, ncols)\ngr = GenomicRanges(\n    seqnames=[\n            \"chr1\",\n            \"chr2\",\n            \"chr2\",\n            \"chr2\",\n            \"chr1\",\n            \"chr1\",\n            \"chr3\",\n            \"chr3\",\n            \"chr3\",\n            \"chr3\",\n        ] * 20,\n    ranges=IRanges(range(100, 300), range(110, 310)),\n    strand = [\"-\", \"+\", \"+\", \"*\", \"*\", \"+\", \"+\", \"+\", \"-\", \"-\"] * 20,\n    mcols=BiocFrame({\n        \"score\": range(0, 200),\n        \"GC\": [random() for _ in range(10)] * 20,\n    })\n)\n\ncol_data_sce = BiocFrame({\"treatment\": [\"ChIP\", \"Input\"] * 3},\n    row_names=[f\"sce_{i}\" for i in range(6)],\n)\n\ncol_data_se = BiocFrame({\"treatment\": [\"ChIP\", \"Input\"] * 3},\n    row_names=[f\"se_{i}\" for i in range(6)],\n)\n\n\nMore importantly, we need to provide sample_map information:\n\nsample_map = BiocFrame({\n    \"assay\": [\"sce\", \"se\"] * 6,\n    \"primary\": [\"sample1\", \"sample2\"] * 6,\n    \"colname\": [\"sce_0\", \"se_0\", \"sce_1\", \"se_1\", \"sce_2\", \"se_2\", \"sce_3\", \"se_3\", \"sce_4\", \"se_4\", \"sce_5\", \"se_5\"]\n})\n\nsample_data = BiocFrame({\"samples\": [\"sample1\", \"sample2\"]}, row_names= [\"sample1\", \"sample2\"])\n\nprint(sample_map)\n\nBiocFrame with 12 rows and 3 columns\n      assay primary colname\n     &lt;list&gt;  &lt;list&gt;  &lt;list&gt;\n [0]    sce sample1   sce_0\n [1]     se sample2    se_0\n [2]    sce sample1   sce_1\n        ...     ...     ...\n [9]     se sample2    se_4\n[10]    sce sample1   sce_5\n[11]     se sample2    se_5\n\n\nFinally, we can create an MultiAssayExperiment object:\n\nfrom multiassayexperiment import MultiAssayExperiment\nfrom singlecellexperiment import SingleCellExperiment\nfrom summarizedexperiment import SummarizedExperiment\n\ntsce = SingleCellExperiment(\n    assays={\"counts\": counts}, row_data=gr.to_pandas(), column_data=col_data_sce\n)\n\ntse2 = SummarizedExperiment(\n    assays={\"counts\": counts.copy()},\n    row_data=gr.to_pandas().copy(),\n    column_data=col_data_se.copy(),\n)\n\nmae = MultiAssayExperiment(\n    experiments={\"sce\": tsce, \"se\": tse2},\n    column_data=sample_data,\n    sample_map=sample_map,\n    metadata={\"could be\": \"anything\"},\n)\n\nprint(mae)\n\nclass: MultiAssayExperiment containing 2 experiments\n[0] sce: SingleCellExperiment with 200 rows and 6 columns \n[1] se: SummarizedExperiment with 200 rows and 6 columns \ncolumn_data columns(1): ['samples']\nsample_map columns(3): ['assay', 'primary', 'colname']\nmetadata(1): could be\n\n\n\n\nNo sample mapping?\nIf both column_data and sample_map are None, the constructor naively creates sample mapping, with each experiment considered to be a independent sample. We add a sample to column_data in this pattern - unknown_sample_{experiment_name}.\nAll cells from the each experiment are considered to be from the same sample and is reflected in sample_map. This is not a recommended approach, but if you don’t have sample mapping, then it doesn’t matter.\n\nmae = MultiAssayExperiment(\n    experiments={\"sce\": tsce, \"se\": tse2},\n    metadata={\"could be\": \"anything\"},\n)\n\nprint(mae)\n\nclass: MultiAssayExperiment containing 2 experiments\n[0] sce: SingleCellExperiment with 200 rows and 6 columns \n[1] se: SummarizedExperiment with 200 rows and 6 columns \ncolumn_data columns(1): ['samples']\nsample_map columns(3): ['assay', 'primary', 'colname']\nmetadata(1): could be\n\n\n\n\n\nInterop with anndata or mudata\nWe provide convenient methods to easily convert a MuData object into an MultiAssayExperiment.\nLet’s create a mudata object:\n\n\nShow the code\nimport numpy as np\nfrom anndata import AnnData\n\nnp.random.seed(1)\n\nn, d, k = 1000, 100, 10\n\nz = np.random.normal(loc=np.arange(k), scale=np.arange(k) * 2, size=(n, k))\nw = np.random.normal(size=(d, k))\ny = np.dot(z, w.T)\n\nadata = AnnData(y)\nadata.obs_names = [f\"obs_{i+1}\" for i in range(n)]\nadata.var_names = [f\"var_{j+1}\" for j in range(d)]\n\nd2 = 50\nw2 = np.random.normal(size=(d2, k))\ny2 = np.dot(z, w2.T)\n\nadata2 = AnnData(y2)\nadata2.obs_names = [f\"obs_{i+1}\" for i in range(n)]\nadata2.var_names = [f\"var2_{j+1}\" for j in range(d2)]\n\nfrom mudata import MuData\nmdata = MuData({\"rna\": adata, \"spatial\": adata2})\n\nprint(mdata)\n\n\nMuData object with n_obs × n_vars = 1000 × 150\n  2 modalities\n    rna:    1000 x 100\n    spatial:    1000 x 50\n\n\nLets convert this object to an MAE:\n\nfrom multiassayexperiment import MultiAssayExperiment\n\nmae_obj = MultiAssayExperiment.from_mudata(input=mdata)\nprint(mae_obj)\n\nclass: MultiAssayExperiment containing 2 experiments\n[0] rna: SingleCellExperiment with 100 rows and 1000 columns \n[1] spatial: SingleCellExperiment with 50 rows and 1000 columns \ncolumn_data columns(1): ['samples']\nsample_map columns(3): ['assay', 'primary', 'colname']\nmetadata(0):"
  },
  {
    "objectID": "chapters/experiments/multiassay_expt.html#getterssetters",
    "href": "chapters/experiments/multiassay_expt.html#getterssetters",
    "title": "Multiple experiments",
    "section": "Getters/Setters",
    "text": "Getters/Setters\nGetters are available to access various attributes using either the property notation or functional style.\n\n# access assays\nprint(\"experiment names (as property): \", mae.experiment_names)\nprint(\"experiment names (functional style): \", mae.get_experiment_names())\n\n# access sample data\nprint(mae.column_data)\n\nexperiment names (as property):  ['sce', 'se']\nexperiment names (functional style):  ['sce', 'se']\nBiocFrame with 2 rows and 1 column\n                              samples\n                               &lt;list&gt;\nunknown_sample_sce unknown_sample_sce\n unknown_sample_se  unknown_sample_se\n\n\nCheck out the class documentation for the full list of accessors and setters.\n\nRow or column name accessors\nA helper method is available to easily access row or column names across all experiments. This method returns a dictionary with experiment names as keys and the corresponding values, which can be either the row or column names depending on the function:\n\nfrom rich import print as pprint\npprint(\"row names:\", mae.get_row_names())\npprint(\"column names:\", mae.get_column_names())\n\nrow names:\n{\n    'sce': Names(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17',\n'18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '36', \n'37', '38', '39', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '50', '51', '52', '53', '54', '55', \n'56', '57', '58', '59', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '70', '71', '72', '73', '74', \n'75', '76', '77', '78', '79', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '90', '91', '92', '93', \n'94', '95', '96', '97', '98', '99', '100', '101', '102', '103', '104', '105', '106', '107', '108', '109', '110', \n'111', '112', '113', '114', '115', '116', '117', '118', '119', '120', '121', '122', '123', '124', '125', '126', \n'127', '128', '129', '130', '131', '132', '133', '134', '135', '136', '137', '138', '139', '140', '141', '142', \n'143', '144', '145', '146', '147', '148', '149', '150', '151', '152', '153', '154', '155', '156', '157', '158', \n'159', '160', '161', '162', '163', '164', '165', '166', '167', '168', '169', '170', '171', '172', '173', '174', \n'175', '176', '177', '178', '179', '180', '181', '182', '183', '184', '185', '186', '187', '188', '189', '190', \n'191', '192', '193', '194', '195', '196', '197', '198', '199']),\n    'se': Names(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', \n'18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '36', \n'37', '38', '39', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '50', '51', '52', '53', '54', '55', \n'56', '57', '58', '59', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '70', '71', '72', '73', '74', \n'75', '76', '77', '78', '79', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '90', '91', '92', '93', \n'94', '95', '96', '97', '98', '99', '100', '101', '102', '103', '104', '105', '106', '107', '108', '109', '110', \n'111', '112', '113', '114', '115', '116', '117', '118', '119', '120', '121', '122', '123', '124', '125', '126', \n'127', '128', '129', '130', '131', '132', '133', '134', '135', '136', '137', '138', '139', '140', '141', '142', \n'143', '144', '145', '146', '147', '148', '149', '150', '151', '152', '153', '154', '155', '156', '157', '158', \n'159', '160', '161', '162', '163', '164', '165', '166', '167', '168', '169', '170', '171', '172', '173', '174', \n'175', '176', '177', '178', '179', '180', '181', '182', '183', '184', '185', '186', '187', '188', '189', '190', \n'191', '192', '193', '194', '195', '196', '197', '198', '199'])\n}\n\n\n\ncolumn names:\n{\n    'sce': Names(['sce_0', 'sce_1', 'sce_2', 'sce_3', 'sce_4', 'sce_5']),\n    'se': Names(['se_0', 'se_1', 'se_2', 'se_3', 'se_4', 'se_5'])\n}\n\n\n\n\n\nAccess an experiment\nOne can access an experiment by name:\n\nprint(mae.experiment(\"se\"))\n\nclass: SummarizedExperiment\ndimensions: (200, 6)\nassays(1): ['counts']\nrow_data columns(7): ['starts', 'widths', 'ends', 'seqnames', 'strand', 'score', 'GC']\nrow_names(200): ['0', '1', '2', ..., '197', '198', '199']\ncolumn_data columns(1): ['treatment']\ncolumn_names(6): ['se_0', 'se_1', 'se_2', 'se_3', 'se_4', 'se_5']\nmetadata(0): \n\n\n\nAdditionally you may access an experiment with the sample information included in the column data of the experiment. Note, this makes a copy of the experiment:\n\nexpt_with_sample_info = mae.experiment(\"se\", with_sample_data=True)\nprint(expt_with_sample_info)\n\nclass: SummarizedExperiment\ndimensions: (200, 6)\nassays(1): ['counts']\nrow_data columns(7): ['starts', 'widths', 'ends', 'seqnames', 'strand', 'score', 'GC']\nrow_names(200): ['0', '1', '2', ..., '197', '198', '199']\ncolumn_data columns(5): ['assay', 'primary', 'colname', 'treatment', 'samples']\ncolumn_names(6): ['se_0', 'se_1', 'se_2', 'se_3', 'se_4', 'se_5']\nmetadata(0): \n\n\n\n\n\n\n\n\n\nNote\n\n\n\nFor consistency with the R MAE’s interface, we also provide get_with_col_data method, that performs the same operation.\n\n\n\n\nSetters\n\n\n\n\n\n\nImportant\n\n\n\nAll property-based setters are in_place operations, with further details discussed in functional paradigm section.\n\n\n\nmodified_column_data = mae.column_data.set_column(\"score\", range(len(mae.column_data)))\nmodified_mae = mae.set_column_data(modified_column_data)\nprint(modified_mae)\n\nclass: MultiAssayExperiment containing 2 experiments\n[0] sce: SingleCellExperiment with 200 rows and 6 columns \n[1] se: SummarizedExperiment with 200 rows and 6 columns \ncolumn_data columns(2): ['samples', 'score']\nsample_map columns(3): ['assay', 'primary', 'colname']\nmetadata(1): could be\n\n\n\nNow, lets check the column_data on the original object.\n\nprint(mae.column_data)\n\nBiocFrame with 2 rows and 1 column\n                              samples\n                               &lt;list&gt;\nunknown_sample_sce unknown_sample_sce\n unknown_sample_se  unknown_sample_se"
  },
  {
    "objectID": "chapters/experiments/multiassay_expt.html#subsetting",
    "href": "chapters/experiments/multiassay_expt.html#subsetting",
    "title": "Multiple experiments",
    "section": "Subsetting",
    "text": "Subsetting\nYou can subset MultiAssayExperiment by using the subset ([]) operator. This operation accepts different slice input types, such as a boolean vector, a slice object, a list of indices, or names (if available) to subset.\nMultiAssayExperiment allows subsetting by three dimensions: rows, columns, and experiments. sample_map is automatically filtered during this operation.\n\nSubset by indices\n\nsubset_mae = mae[1:5, 0:4]\nprint(subset_mae)\n\nclass: MultiAssayExperiment containing 2 experiments\n[0] sce: SingleCellExperiment with 4 rows and 6 columns \n[1] se: SummarizedExperiment with 4 rows and 6 columns \ncolumn_data columns(1): ['samples']\nsample_map columns(3): ['assay', 'primary', 'colname']\nmetadata(1): could be\n\n\n\n\n\nSubset by experiments dimension\nThe following creates a subset based on the experiments dimension:\n\nsubset_mae = mae[1:5, 0:1, [\"se\"]]\nprint(subset_mae)\n\nclass: MultiAssayExperiment containing 1 experiments\n[0] se: SummarizedExperiment with 4 rows and 0 columns \ncolumn_data columns(1): ['samples']\nsample_map columns(3): ['assay', 'primary', 'colname']\nmetadata(1): could be\n\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/multiassayexperiment/MultiAssayExperiment.py:63: UserWarning: 'primary' from `sample_map` & `column_data` mismatch.\n  warn(\"'primary' from `sample_map` & `column_data` mismatch.\", UserWarning)\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/multiassayexperiment/MultiAssayExperiment.py:74: UserWarning: 'experiments' contains names not represented in 'sample_map' or vice-versa.\n  warn(\n\n\n\n\n\n\n\n\nNote\n\n\n\nIf you’re wondering about why the experiment “se” has 0 columns, it’s important to note that our MAE implementation does not remove columns from an experiment solely because none of the columns map to the samples of interest. This approach aims to prevent unexpected outcomes in complex subset operations."
  },
  {
    "objectID": "chapters/experiments/multiassay_expt.html#helper-functions",
    "href": "chapters/experiments/multiassay_expt.html#helper-functions",
    "title": "Multiple experiments",
    "section": "Helper functions",
    "text": "Helper functions\nThe MultiAssayExperiment class also provides a few methods for sample management.\n\nComplete cases\nThe complete_cases function is designed to identify samples that contain data across all experiments. It produces a boolean vector with the same length as the number of samples in column_data. Each element in the vector is True if the sample is present in all experiments, or False otherwise.\n\nprint(mae.complete_cases())\n\n[False, False]\n\n\nYou can use this boolean vector to select samples with complete data across all assays or experiments.\n\nsubset_mae = mae[:, mae.complete_cases(),]\nprint(subset_mae)\n\nclass: MultiAssayExperiment containing 2 experiments\n[0] sce: SingleCellExperiment with 200 rows and 0 columns \n[1] se: SummarizedExperiment with 200 rows and 0 columns \ncolumn_data columns(1): ['samples']\nsample_map columns(3): ['assay', 'primary', 'colname']\nmetadata(1): could be\n\n\n\n\n\nReplicates\nThis method identifies ‘samples’ with replicates within each experiment. The result is a dictionary where experiment names serve as keys, and the corresponding values indicate whether the sample is replicated within each experiment.\n\nfrom rich import print as pprint # mainly for pretty printing\npprint(mae.replicated())\n\n{\n    'sce': {\n        'unknown_sample_sce': [True, True, True, True, True, True],\n        'unknown_sample_se': [False, False, False, False, False, False]\n    },\n    'se': {\n        'unknown_sample_sce': [False, False, False, False, False, False],\n        'unknown_sample_se': [True, True, True, True, True, True]\n    }\n}\n\n\n\n\n\nIntersect rows\nThe intersect_rows finds common row_names across all experiments and returns a MultiAssayExperiment with those rows.\n\ncommon_rows_mae = mae.intersect_rows()\nprint(common_rows_mae)\n\nclass: MultiAssayExperiment containing 2 experiments\n[0] sce: SingleCellExperiment with 200 rows and 6 columns \n[1] se: SummarizedExperiment with 200 rows and 6 columns \ncolumn_data columns(1): ['samples']\nsample_map columns(3): ['assay', 'primary', 'colname']\nmetadata(1): could be"
  },
  {
    "objectID": "chapters/experiments/multiassay_expt.html#further-reading",
    "href": "chapters/experiments/multiassay_expt.html#further-reading",
    "title": "Multiple experiments",
    "section": "Further reading",
    "text": "Further reading\n\nCheck out reference documentation for more details.\nR/Bioconductor’s MultiAssayExperiment package."
  },
  {
    "objectID": "chapters/extras/iranges.html#sec-iranges",
    "href": "chapters/extras/iranges.html#sec-iranges",
    "title": "IRanges: Interval arithmetic",
    "section": "Installation",
    "text": "Installation\nTo get started, install the package from PyPI\npip install iranges\n\n\n\n\n\n\nNote\n\n\n\nThe descriptions for some of these methods come from the Bioconductor documentation."
  },
  {
    "objectID": "chapters/extras/iranges.html#construction",
    "href": "chapters/extras/iranges.html#construction",
    "title": "IRanges: Interval arithmetic",
    "section": "Construction",
    "text": "Construction\nAn IRanges holds a start position and a width, and is most typically used to represent coordinates along some genomic sequence. The interpretation of the start position depends on the application; for sequences, the start is usually a 1-based position, but other use cases may allow zero or even negative values (e.g. circular genomes).\n\nfrom iranges import IRanges\n\nstarts = [-2, 6, 9, -4, 1, 0, -6, 10]\nwidths = [5, 0, 6, 1, 4, 3, 2, 3]\nir = IRanges(starts, widths)\n\nprint(ir)\n\nIRanges object with 8 ranges and 0 metadata columns\n               start              end            width\n    &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt;\n[0]               -2                3                5\n[1]                6                6                0\n[2]                9               15                6\n[3]               -4               -3                1\n[4]                1                5                4\n[5]                0                3                3\n[6]               -6               -4                2\n[7]               10               13                3"
  },
  {
    "objectID": "chapters/extras/iranges.html#accessing-properties",
    "href": "chapters/extras/iranges.html#accessing-properties",
    "title": "IRanges: Interval arithmetic",
    "section": "Accessing properties",
    "text": "Accessing properties\nProperties can be accessed directly from the object:\n\nprint(\"Number of intervals:\", len(ir))\n\nprint(\"start positions:\", ir.get_start())\nprint(\"width of each interval:\", ir.get_width())\nprint(\"end positions:\", ir.get_end())\n\nNumber of intervals: 8\nstart positions: [-2  6  9 -4  1  0 -6 10]\nwidth of each interval: [5 0 6 1 4 3 2 3]\nend positions: [ 3  6 15 -3  5  3 -4 13]\n\n\n\n\n\n\n\n\nTip\n\n\n\nJust like BiocFrame, these classes offer both functional-style and property-based getters and setters.\n\n\n\nprint(\"start positions:\", ir.start)\nprint(\"width of each interval:\", ir.width)\nprint(\"end positions:\", ir.end)\n\nstart positions: [-2  6  9 -4  1  0 -6 10]\nwidth of each interval: [5 0 6 1 4 3 2 3]\nend positions: [ 3  6 15 -3  5  3 -4 13]"
  },
  {
    "objectID": "chapters/extras/iranges.html#reduced-ranges-normality",
    "href": "chapters/extras/iranges.html#reduced-ranges-normality",
    "title": "IRanges: Interval arithmetic",
    "section": "Reduced ranges (Normality)",
    "text": "Reduced ranges (Normality)\nreduce method reduces the intervals to an IRanges where the intervals are:\n\nnot empty\nnot overlapping\nordered from left to right\nnot even adjacent (i.e. there must be a non empty gap between 2 consecutive ranges).\n\n\nreduced = ir.reduce()\nprint(reduced)\n\nIRanges object with 4 ranges and 0 metadata columns\n               start              end            width\n    &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt;\n[0]               -6               -3                3\n[1]               -2                5                7\n[2]                6                6                0\n[3]                9               15                6"
  },
  {
    "objectID": "chapters/extras/iranges.html#overlap-operations",
    "href": "chapters/extras/iranges.html#overlap-operations",
    "title": "IRanges: Interval arithmetic",
    "section": "Overlap operations",
    "text": "Overlap operations\nIRanges uses nested containment lists under the hood to perform fast overlap and search-based operations.\n\nsubject = IRanges([2, 2, 10], [1, 2, 3])\nquery = IRanges([1, 4, 9], [5, 4, 2])\n\noverlap = subject.find_overlaps(query)\nprint(overlap)\n\n[[1, 0], [], [2]]\n\n\n\nFinding neighboring ranges\nThe nearest, precede or follow methods finds the nearest overlapping range along the specified direction.\n\nquery = IRanges([1, 3, 9], [2, 5, 2])\nsubject = IRanges([3, 5, 12], [1, 2, 1])\n\nnearest = subject.nearest(query, select=\"all\")\nprint(nearest)\n\n[[0], [0, 1], [2]]\n\n\n\n\n\n\n\n\nNote\n\n\n\nThese methods typically return a list of indices from subject for each interval in query.\n\n\n\n\ncoverage\nThe coverage method counts the number of overlaps for each position.\n\ncov = subject.coverage()\nprint(cov)\n\n[0 0 1 0 1 1 0 0 0 0 0 1]"
  },
  {
    "objectID": "chapters/extras/iranges.html#transforming-ranges",
    "href": "chapters/extras/iranges.html#transforming-ranges",
    "title": "IRanges: Interval arithmetic",
    "section": "Transforming ranges",
    "text": "Transforming ranges\nshift adjusts the start positions by their shift.\n\nshifted = ir.shift(shift=10)\nprint(shifted)\n\nIRanges object with 8 ranges and 0 metadata columns\n               start              end            width\n    &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt;\n[0]                8               13                5\n[1]               16               16                0\n[2]               19               25                6\n[3]                6                7                1\n[4]               11               15                4\n[5]               10               13                3\n[6]                4                6                2\n[7]               20               23                3\n\n\nOther range transformation methods include narrow, resize, flank, reflect and restrict. For example narrow supports the adjustment of start, end and width values, which should be relative to each range.\n\nnarrowed = ir.narrow(start=4, width=2)\nprint(narrowed)\n\nIRanges object with 8 ranges and 0 metadata columns\n               start              end            width\n    &lt;ndarray[int64]&gt; &lt;ndarray[int64]&gt; &lt;ndarray[int64]&gt;\n[0]                1                3                2\n[1]                9               11                2\n[2]               12               14                2\n[3]               -1                1                2\n[4]                4                6                2\n[5]                3                5                2\n[6]               -3               -1                2\n[7]               13               15                2\n\n\n\nDisjoin intervals\nWell as the name says, computes disjoint intervals.\n\ndisjoint = ir.disjoin()\nprint(disjoint)\n\nIRanges object with 9 ranges and 0 metadata columns\n               start              end            width\n    &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt;\n[0]               -6               -4                2\n[1]               -4               -3                1\n[2]               -2                0                2\n[3]                0                1                1\n[4]                1                3                2\n[5]                3                5                2\n[6]                9               10                1\n[7]               10               13                3\n[8]               13               15                2\n\n\n\n\nreflect and flank\nreflect reverses each range within a set of common reference bounds.\n\nstarts = [2, 5, 1]\nwidths = [2, 3, 3]\nx = IRanges(starts, widths)\nbounds = IRanges([0, 5, 3], [11, 2, 7])\n\nres = x.reflect(bounds=bounds)\nprint(res)\n\nIRanges object with 3 ranges and 0 metadata columns\n               start              end            width\n    &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt;\n[0]                7                9                2\n[1]                4                7                3\n[2]                9               12                3\n\n\nflank returns ranges of a specified width that flank, to the left (default) or right, each input range. One use case of this is forming promoter regions for a set of genes.\n\nstarts = [2, 5, 1]\nwidths = [2, 3, 3]\nx = IRanges(starts, widths)\n\nres = x.flank(2, start=False)\nprint(res)\n\nIRanges object with 3 ranges and 0 metadata columns\n               start                end              width\n    &lt;ndarray[int32]&gt; &lt;ndarray[float64]&gt; &lt;ndarray[float64]&gt;\n[0]                4                6.0                2.0\n[1]                8               10.0                2.0\n[2]                4                6.0                2.0"
  },
  {
    "objectID": "chapters/extras/iranges.html#set-operations",
    "href": "chapters/extras/iranges.html#set-operations",
    "title": "IRanges: Interval arithmetic",
    "section": "Set operations",
    "text": "Set operations\nIRanges supports most interval set operations. For example, to compute gaps:\n\ngaps = ir.gaps()\nprint(gaps)\n\nIRanges object with 2 ranges and 0 metadata columns\n               start              end            width\n    &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt;\n[0]               -3               -2                1\n[1]                5                9                4\n\n\nOr Perform interval set operations, e..g union, intersection, disjoin:\n\nx = IRanges([1, 5, -2, 0, 14], [10, 5, 6, 12, 4])\ny = IRanges([14, 0, -5, 6, 18], [7, 3, 8, 3, 3])\n\nintersection = x.intersect(y)\nprint(intersection)\n\nIRanges object with 3 ranges and 0 metadata columns\n               start              end            width\n    &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt;\n[0]               -2                3                5\n[1]                6                9                3\n[2]               14               18                4"
  },
  {
    "objectID": "chapters/extras/iranges.html#further-reading",
    "href": "chapters/extras/iranges.html#further-reading",
    "title": "IRanges: Interval arithmetic",
    "section": "Further reading",
    "text": "Further reading\n\nIRanges reference\nBioc/IRanges"
  },
  {
    "objectID": "chapters/summary.html",
    "href": "chapters/summary.html",
    "title": "Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever."
  },
  {
    "objectID": "chapters/sessioninfo.html#sec-sessioninfo",
    "href": "chapters/sessioninfo.html#sec-sessioninfo",
    "title": "Reproduce me!",
    "section": "Pre-requisites",
    "text": "Pre-requisites\n\nimport sys\nimport subprocess\n\nfrom rich import print"
  },
  {
    "objectID": "chapters/sessioninfo.html#python",
    "href": "chapters/sessioninfo.html#python",
    "title": "Reproduce me!",
    "section": "Python",
    "text": "Python\nLets make sure we have all packages we need for this section\n\nsys.version_info\n\nsys.version_info(major=3, minor=9, micro=18, releaselevel='final', serial=0)"
  },
  {
    "objectID": "chapters/sessioninfo.html#packages",
    "href": "chapters/sessioninfo.html#packages",
    "title": "Reproduce me!",
    "section": "Packages",
    "text": "Packages\n\nimport math\n\nimport biocframe\nimport biocutils\nimport genomicranges\nimport summarizedexperiment\nimport singlecellexperiment\nimport multiassayexperiment\nimport rds2py\nimport session_info\n\n\nsession_info.show()\n\n\nClick to view session information\n-----\nbiocframe                   0.5.7\nbiocutils                   0.1.4\ngenomicranges               0.4.8\nmultiassayexperiment        0.4.2\nrds2py                      0.3.1\nrich                        NA\nsession_info                1.0.0\nsinglecellexperiment        0.4.2\nsummarizedexperiment        0.4.1\n-----\n\n\nClick to view modules imported as dependencies\nPIL                         10.2.0\nanyio                       NA\narrow                       1.3.0\nasttokens                   NA\nattr                        23.2.0\nattrs                       23.2.0\nbabel                       2.14.0\ncertifi                     2023.11.17\ncffi                        1.16.0\ncharset_normalizer          3.3.2\ncomm                        0.2.1\ncycler                      0.12.1\ncython_runtime              NA\ndateutil                    2.8.2\ndebugpy                     1.8.0\ndecorator                   5.1.1\ndefusedxml                  0.7.1\nexceptiongroup              1.2.0\nexecuting                   2.0.1\nfastjsonschema              NA\nfqdn                        NA\nidna                        3.6\nimportlib_metadata          NA\nimportlib_resources         NA\nipykernel                   6.29.0\niranges                     0.2.2\nisoduration                 NA\njedi                        0.19.1\njinja2                      3.1.3\njson5                       NA\njsonpointer                 2.4\njsonschema                  4.21.0\njsonschema_specifications   NA\njupyter_events              0.9.0\njupyter_server              2.12.5\njupyterlab_server           2.25.2\nkiwisolver                  1.4.5\nmarkupsafe                  2.1.3\nmatplotlib                  3.8.2\nmatplotlib_inline           0.1.6\nmpl_toolkits                NA\nnbformat                    5.9.2\nnumpy                       1.26.3\noverrides                   NA\npackaging                   23.2\npandas                      2.1.4\nparso                       0.8.3\npexpect                     4.9.0\nplatformdirs                4.1.0\nprometheus_client           NA\nprompt_toolkit              3.0.43\npsutil                      5.9.7\nptyprocess                  0.7.0\npure_eval                   0.2.2\npydev_ipython               NA\npydevconsole                NA\npydevd                      2.9.5\npydevd_file_utils           NA\npydevd_plugins              NA\npydevd_tracing              NA\npygments                    2.17.2\npyparsing                   3.1.1\npythonjsonlogger            NA\npytz                        2023.3.post1\nreferencing                 NA\nrequests                    2.31.0\nrfc3339_validator           0.1.4\nrfc3986_validator           0.1.1\nrpds                        NA\nscipy                       1.11.4\nsend2trash                  NA\nsix                         1.16.0\nsniffio                     1.3.0\nstack_data                  0.6.3\ntornado                     6.4\ntraitlets                   5.14.1\ntyping_extensions           NA\nuri_template                NA\nurllib3                     2.1.0\nwcwidth                     0.2.13\nwebcolors                   1.13\nwebsocket                   1.7.0\nyaml                        6.0.1\nzipp                        NA\nzmq                         25.1.2\nzoneinfo                    NA\n\n \n-----\nIPython             8.18.1\njupyter_client      8.6.0\njupyter_core        5.7.1\njupyterlab          4.0.10\nnotebook            7.0.6\n-----\nPython 3.9.18 (main, Aug 28 2023, 08:38:32) [GCC 11.4.0]\nLinux-6.2.0-1018-azure-x86_64-with-glibc2.35\n-----\nSession information updated at 2024-01-16 19:34"
  }
]