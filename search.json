[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BiocPy: Enabling Bioconductor workflows in Python",
    "section": "",
    "text": "Welcome\nBioconductor is an open-source software project that provides tools for the analysis and comprehension of genomic data. One of the main advantages of Bioconductor is the availability of standard data representations and large number of analysis tools for genomic experiments. These tools allow researchers to efficiently store, manipulate, and analyze their data, leading to a deeper understanding of the underlying biological processes.\nInspired by Bioconductor, BiocPy aims to facilitate bioconductor workflows in Python. To achieve this goal, we developed several core data structures that align closely to the bioconductor implementations. These structures efficiently manage genomic intervals and genome annotations through GenomicRanges and/or IRanges, provide container classes to represent single (SummarizedExperiment, SingleCellExperiment) or multi-omic experimental data and metadata (MultiAssayExperiment). In addition, BiocPy provides infrastructure packages to support delayed operations (DelayedArray), Bioconductor-like dataframes (BiocFrame), and incorporate numerous generics and utilities in BiocUtils. While there are prior initiatives aiming to port bioconductor representations into Python, BiocPy distinguishes itself as the first to develop seamless, well-integrated data structures and representations.\nBiocPy additionally provides bindings to libscran and various other single-cell analysis methods incorporated into the scranpy package to support analysis of multi-modal single-cell datasets. It also features integration with the singler algorithm to annotate cell types by matching cells to known references based on their expression profiles.\nFor convenient access to experimental data stored in RDS files, the rds2py package provides bindings to the rds2cpp library. This allows direct reading of RDS files in Python, eliminating the need for additional data conversion tools or intermediate formats. This package functionality streamlines the transition between Python and R for seamless analysis.\nAll packages within the BiocPy ecosystem are published to Python’s Package Index (PyPI)."
  },
  {
    "objectID": "index.html#selected-packages",
    "href": "index.html#selected-packages",
    "title": "BiocPy: Enabling Bioconductor workflows in Python",
    "section": "Selected packages",
    "text": "Selected packages\nFor complete list of all packages, visit the GitHub:BiocPy repository.\n\ncore representations:\n\nBiocUtils (GitHub, Docs): Common utilities for use across packages, mostly to mimic convenient aspects of base R.\nBiocFrame (GitHub, Docs): Bioconductor-like dataframes in Python.\nIRanges (GitHub, Docs): Python implementation of the IRanges package to support interval arithmetic.\nGenomicRanges (GitHub, Docs, BioC): Container class to represent genomic locations and support genomic analysis. Similar to Bioconductor’s GenomicRanges.\nSummarizedExperiment (GitHub, Docs, BioC): Container class to represent genomic experiments, following Bioconductor’s SummarizedExperiment.\nSingleCellExperiment (GitHub, Docs, BioC): Container class to represent single-cell experiments; follows Bioconductor’s SingleCellExperiment.\nMultiAssayExperiment (GitHub, Docs, BioC): Container class to represent multiple experiments and assays performed over a set of samples. follows Bioconductor’s MAE R/Bioc Package.\n\n\n\nAnalysis packages\n\nscranpy(GitHub, Docs): Python bindings to the single-cell analysis methods from libscran and related C++ libraries.\nsingler(GitHub, Docs): Python bindings to the singleR algorithm to annotate cell types from known references.\n\n\n\nInteroperability with R\n\nrds2py (GitHub, Docs): Read RDS files directly in Python. Supports Bioconductor’s SummarizedExperiment and SingleCellExperiment in addition to matrices, dataframes and vectors.\n\n\n\nUtility packages\n\nmopsy (GitHub, Docs): Helper functions to perform row or column operations over numpy and scipy matrices. Provides an interface similar to base R matrix methods/MatrixStats methods.\npyBiocFileCache (GitHub, Docs, BioC): File system based cache for resources & metadata.\n\n\n\n\nNotes\nThis is a reproducible Quarto book with reusable snippets. To learn more about Quarto books visit https://quarto.org/docs/books."
  },
  {
    "objectID": "chapters/philosophy.html#class-design",
    "href": "chapters/philosophy.html#class-design",
    "title": "Programming philosophy",
    "section": "Class design",
    "text": "Class design\nOur objective is to provide a consistent user experience in Python for each Bioconductor class. In most cases, this is achieved by directly re-implementing the class and its associated methods in Python. Occasionally, the Bioconductor implementation contains historical baggage (e.g., the storage of rowData in a RangedSummarizedExperiment, MultiAssayExperiment harmonization); developers should use their own discretion to decide whether that really needs to be replicated in Python."
  },
  {
    "objectID": "chapters/philosophy.html#naming",
    "href": "chapters/philosophy.html#naming",
    "title": "Programming philosophy",
    "section": "Naming",
    "text": "Naming\nWe highly recommend adhering to Google’s Python style guide for consistency. In summary, classes should use PascalCase and follow Bioconductor’s class names. Methods should use snake_case and take the form of &lt;verb&gt;[_&lt;details&gt;], such as get_start(), set_names() and so on. Method arguments should also use snake_case format.\nUsability has been another crucial objective, to facilitate an easy transition for users between R and Python classes. For instance, when computing flanking regions in R:\nflank(gr, width=2, start=FALSE, both=TRUE)\nIn the GenomicRanges Python packages, we maintain consistency by expecting the same method name. The only difference lies in the shift from a functional to an object-oriented programming paradigm:\ngr.flank(width=2, start=False, both=True)\n\nFunctional discipline\nThe existence of mutable types in Python introduces the potential danger of modifying complex objects. If a mutable object has a user-visible reference and is also a member of a larger Bioconductor object, a user-specified modification to that object may violate the constraints of the parent object.\nTo address these issues, we enforce a functional programming discipline in all class methods. By default, all methods should avoid side effects that mutate the object. This simplifies reasoning around the effects of methods and/or mutations in large complex objects.\nThe most notable application of this philosophy is in setter methods. Instead of mutating the object directly, they should return a new copy of the object with the desired modification. The “depth” of the copy depends on the nature of the field being set; the aim should be to avoid any modification of the contents in self. Implementations may offer an in_place= option to apply the modification to the original object, but this default to False.\nTo avoid performance issues, getter methods may return mutable objects without copying, assuming that their return values are read-only and will not be directly mutated (Setter methods that operate via a copy are allowed). In some cases, the return value of a getter method may be directly mutated, e.g., because a copy was already created in the getter; this should be clearly stated in the documentation but should not be treated as the default.\n\nProperty based getters and setters\nDirect access to class members (via properties or @property decorator) should generally be avoided, as it is too easy to perform modifications via one-liners with the class.property notation on the left-hand-side of an assignment.\nThe default assumption is that property-based setters will mutate the object in-place."
  },
  {
    "objectID": "chapters/philosophy.html#type-hints",
    "href": "chapters/philosophy.html#type-hints",
    "title": "Programming philosophy",
    "section": "Type hints",
    "text": "Type hints\nAs the term suggests, type hints are “hints” used to enhance the developer experience; they should not dictate how we write our code.\nFor this reason, we prefer simple types in these hints, usually corresponding to base Python types with minimal nesting. For example, if a function is expected to operate on any arbitrary list, the basic list type hint should suffice.\ndef find_element(arr: list, query: int)\n    pass\nIf the function expects a list of strings,\nfrom typing import List\n\ndef find_element(arr: List[str], query: str):\n    pass\nIf the function accepts multiple types as inputs,\nfrom typing import Union\n\ndef find_element(arr: List[str], query: Union[int, str, slice]):\n    pass\nAdditionally, we provide recommendations on setting up the package, different testing environments, documentation, and publishing workflows. These details can be found in the developer guide."
  },
  {
    "objectID": "chapters/representations/index.html",
    "href": "chapters/representations/index.html",
    "title": "The basics",
    "section": "",
    "text": "This chapter introduces the core representations and classes available through BiocPy.\nAll packages in the BiocPy ecosystem are published to Python’s Package Index - PyPI.\nbiocpy is a wrapper package that install all core packages in the ecosystem.\npip install biocpy\nOR install packages as needed. e.g.\npip install summarizedexperiment # &lt;package-name&gt;\n\nUpdate packages\npip install -U biocpy # or &lt;package-name&gt;"
  },
  {
    "objectID": "chapters/representations/biocframe.html#installation",
    "href": "chapters/representations/biocframe.html#installation",
    "title": "1  BiocFrame - Bioconductor-like data frames",
    "section": "1.1 Installation",
    "text": "1.1 Installation\nTo get started, install the package from PyPI\npip install biocframe"
  },
  {
    "objectID": "chapters/representations/biocframe.html#construction",
    "href": "chapters/representations/biocframe.html#construction",
    "title": "1  BiocFrame - Bioconductor-like data frames",
    "section": "1.2 Construction",
    "text": "1.2 Construction\nTo create a BiocFrame object, simply provide the data as a dictionary.\n\nfrom biocframe import BiocFrame\n\nobj = {\n    \"ensembl\": [\"ENS00001\", \"ENS00002\", \"ENS00003\"],\n    \"symbol\": [\"MAP1A\", \"BIN1\", \"ESR1\"],\n}\nbframe = BiocFrame(obj)\nprint(bframe)\n\nBiocFrame with 3 rows and 2 columns\n     ensembl symbol\n      &lt;list&gt; &lt;list&gt;\n[0] ENS00001  MAP1A\n[1] ENS00002   BIN1\n[2] ENS00003   ESR1\n\n\n\n\n\n\n\n\nTip\n\n\n\nYou can specify complex objects as columns, as long as they have some “length” equal to the number of rows. For example, we can embed a BiocFrame within another BiocFrame:\n\n\n\nobj = {\n    \"ensembl\": [\"ENS00001\", \"ENS00002\", \"ENS00002\"],\n    \"symbol\": [\"MAP1A\", \"BIN1\", \"ESR1\"],\n    \"ranges\": BiocFrame({\n        \"chr\": [\"chr1\", \"chr2\", \"chr3\"],\n        \"start\": [1000, 1100, 5000],\n        \"end\": [1100, 4000, 5500]\n    }),\n}\n\nbframe2 = BiocFrame(obj, row_names=[\"row1\", \"row2\", \"row3\"])\nprint(bframe2)\n\nBiocFrame with 3 rows and 3 columns\n      ensembl symbol         ranges\n       &lt;list&gt; &lt;list&gt;    &lt;BiocFrame&gt;\nrow1 ENS00001  MAP1A chr1:1000:1100\nrow2 ENS00002   BIN1 chr2:1100:4000\nrow3 ENS00002   ESR1 chr3:5000:5500"
  },
  {
    "objectID": "chapters/representations/biocframe.html#extracting-data",
    "href": "chapters/representations/biocframe.html#extracting-data",
    "title": "1  BiocFrame - Bioconductor-like data frames",
    "section": "1.3 Extracting data",
    "text": "1.3 Extracting data\nProperties can be directly accessed from the object:\n\nprint(\"shape:\", bframe.shape)\nprint(\"column names (functional style):\", bframe.get_column_names())\nprint(\"column names (as property):\", bframe.column_names) # same as above\n\nshape: (3, 2)\ncolumn names (functional style): ['ensembl', 'symbol']\ncolumn names (as property): ['ensembl', 'symbol']\n\n\nWe can fetch individual columns:\n\nprint(\"functional style:\", bframe.get_column(\"ensembl\"))\nprint(\"w/ accessor\", bframe[\"ensembl\"])\n\nfunctional style: ['ENS00001', 'ENS00002', 'ENS00003']\nw/ accessor ['ENS00001', 'ENS00002', 'ENS00003']\n\n\nAnd we can get individual rows as a dictionary:\n\nbframe.get_row(2)\n\n{'ensembl': 'ENS00003', 'symbol': 'ESR1'}\n\n\n\n\n\n\n\n\nTo retrieve a subset of the data in the BiocFrame, we use the subset ([]) operator. This operator accepts different subsetting arguments, such as a boolean vector, a slice object, a sequence of indices, or row/column names.\n\n\n\n\nsliced_with_bools = bframe[1:2, [True, False, False]]\nprint(\"Subset using booleans: \\n\", sliced_with_bools)\n\nsliced_with_names = bframe[[0,2], [\"symbol\", \"ensembl\"]]\nprint(\"\\nSubset using column names: \\n\", sliced_with_names)\n\n# Short-hand to get a single column:\nprint(\"\\nShort-hand to get a single column: \\n\", bframe[\"ensembl\"])\n\nSubset using booleans: \n BiocFrame with 1 row and 1 column\n     ensembl\n      &lt;list&gt;\n[0] ENS00002\n\nSubset using column names: \n BiocFrame with 2 rows and 2 columns\n    symbol  ensembl\n    &lt;list&gt;   &lt;list&gt;\n[0]  MAP1A ENS00001\n[1]   ESR1 ENS00003\n\nShort-hand to get a single column: \n ['ENS00001', 'ENS00002', 'ENS00003']"
  },
  {
    "objectID": "chapters/representations/biocframe.html#setting-data",
    "href": "chapters/representations/biocframe.html#setting-data",
    "title": "1  BiocFrame - Bioconductor-like data frames",
    "section": "1.4 Setting data",
    "text": "1.4 Setting data\n\n1.4.1 Preferred approach\nTo set BiocFrame properties, we encourage a functional style of programming that avoids mutating the object. This avoids inadvertent modification of BiocFrame instances within larger data structures.\n\nmodified = bframe.set_column_names([\"column1\", \"column2\"])\nprint(modified)\n\nBiocFrame with 3 rows and 2 columns\n     column1 column2\n      &lt;list&gt;  &lt;list&gt;\n[0] ENS00001   MAP1A\n[1] ENS00002    BIN1\n[2] ENS00003    ESR1\n\n\nNow lets check the column names of the original object,\n\n# Original is unchanged:\nprint(bframe.get_column_names())\n\n['ensembl', 'symbol']\n\n\nTo add new columns, or replace existing columns:\n\nmodified = bframe.set_column(\"symbol\", [\"A\", \"B\", \"C\"])\nprint(modified)\n\nmodified = bframe.set_column(\"new_col_name\", range(2, 5))\nprint(modified)\n\nBiocFrame with 3 rows and 2 columns\n     ensembl symbol\n      &lt;list&gt; &lt;list&gt;\n[0] ENS00001      A\n[1] ENS00002      B\n[2] ENS00003      C\nBiocFrame with 3 rows and 3 columns\n     ensembl symbol new_col_name\n      &lt;list&gt; &lt;list&gt;      &lt;range&gt;\n[0] ENS00001  MAP1A            2\n[1] ENS00002   BIN1            3\n[2] ENS00003   ESR1            4\n\n\nChange the row or column names:\n\nmodified = bframe.\\\n    set_column_names([\"FOO\", \"BAR\"]).\\\n    set_row_names(['alpha', 'bravo', 'charlie'])\nprint(modified)\n\nBiocFrame with 3 rows and 2 columns\n             FOO    BAR\n          &lt;list&gt; &lt;list&gt;\n  alpha ENS00001  MAP1A\n  bravo ENS00002   BIN1\ncharlie ENS00003   ESR1\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe functional style allows you to chain multiple operations.\n\n\nWe also support Bioconductor’s metadata concepts, either along the columns or for the entire object:\n\nmodified = bframe.\\\n    set_metadata({ \"author\": \"Jayaram Kancherla\" }).\\\n    set_column_data(BiocFrame({\"column_source\": [\"Ensembl\", \"HGNC\" ]}))\nprint(modified)\n\nBiocFrame with 3 rows and 2 columns\n     ensembl symbol\n      &lt;list&gt; &lt;list&gt;\n[0] ENS00001  MAP1A\n[1] ENS00002   BIN1\n[2] ENS00003   ESR1\n------\ncolumn_data(1): column_source\nmetadata(1): author\n\n\n\n\n1.4.2 The other way\nProperties can also be set by direct assignment for in-place modification. We prefer not to do it this way as it can silently mutate BiocFrame instances inside other data structures. Nonetheless:\n\ntestframe = BiocFrame({ \"A\": [1,2,3], \"B\": [4,5,6] })\ntestframe.column_names = [\"column1\", \"column2\" ]\nprint(testframe)\n\nBiocFrame with 3 rows and 2 columns\n    column1 column2\n     &lt;list&gt;  &lt;list&gt;\n[0]       1       4\n[1]       2       5\n[2]       3       6\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/biocframe/BiocFrame.py:466: UserWarning: Setting property 'column_names' is an in-place operation, use 'set_column_names' instead\n  warn(\n\n\n\n\n\n\n\n\nImportant\n\n\n\nWarnings are raised when properties are directly mutated. These assignments are the same as calling the corresponding set_*() methods with in_place = True. It is best to do this only if the BiocFrame object is not being used anywhere else; otherwise, it is safer to just create a (shallow) copy via the default in_place = False.\n\n\nSimilarly, we could set or replace columns directly:\n\ntestframe[\"column2\"] = [\"A\", \"B\", \"C\"]\ntestframe[1:3, [\"column1\",\"column2\"]] = BiocFrame({\"x\":[4, 5], \"y\":[\"E\", \"F\"]})\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/biocframe/BiocFrame.py:819: UserWarning: This method performs an in-place operation, use 'set_column' instead\n  warn(\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/biocframe/BiocFrame.py:813: UserWarning: This method performs an in-place operation, use 'set_slice' instead\n  warn("
  },
  {
    "objectID": "chapters/representations/biocframe.html#combining-objects",
    "href": "chapters/representations/biocframe.html#combining-objects",
    "title": "1  BiocFrame - Bioconductor-like data frames",
    "section": "1.5 Combining objects",
    "text": "1.5 Combining objects\nBiocFrame implements methods for the various combine generics from BiocUtils. For example, to combine by row:\n\nimport biocutils\n\nbframe1 = BiocFrame({\n    \"odd\": [1, 3, 5, 7, 9],\n    \"even\": [0, 2, 4, 6, 8],\n})\n\nbframe2 = BiocFrame({\n    \"odd\": [11, 33, 55, 77, 99],\n    \"even\": [0, 22, 44, 66, 88],\n})\n\ncombined = biocutils.combine_rows(bframe1, bframe2)\nprint(combined)\n\nBiocFrame with 10 rows and 2 columns\n       odd   even\n    &lt;list&gt; &lt;list&gt;\n[0]      1      0\n[1]      3      2\n[2]      5      4\n[3]      7      6\n[4]      9      8\n[5]     11      0\n[6]     33     22\n[7]     55     44\n[8]     77     66\n[9]     99     88\n\n\nSimilarly, to combine by column:\n\nbframe3 = BiocFrame({\n    \"foo\": [\"A\", \"B\", \"C\", \"D\", \"E\"],\n    \"bar\": [True, False, True, False, True]\n})\n\ncombined = biocutils.combine_columns(bframe1, bframe3)\nprint(combined)\n\nBiocFrame with 5 rows and 4 columns\n       odd   even    foo    bar\n    &lt;list&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt;\n[0]      1      0      A   True\n[1]      3      2      B  False\n[2]      5      4      C   True\n[3]      7      6      D  False\n[4]      9      8      E   True\n\n\n\n\n\n\n\n\nNote\n\n\n\nBy default, both methods above assume that the number and identity of columns (for combine_rows()) or rows (for combine_columns()) are the same across objects.\n\n\nIf this is not the case, e.g., with different columns across objects, we can use relaxed_combine_rows() instead:\n\nfrom biocframe import relaxed_combine_rows\n\nmodified2 = bframe2.set_column(\"foo\", [\"A\", \"B\", \"C\", \"D\", \"E\"])\n\ncombined = biocutils.relaxed_combine_rows(bframe1, modified2)\nprint(combined)\n\nBiocFrame with 10 rows and 3 columns\n       odd   even    foo\n    &lt;list&gt; &lt;list&gt; &lt;list&gt;\n[0]      1      0   None\n[1]      3      2   None\n[2]      5      4   None\n[3]      7      6   None\n[4]      9      8   None\n[5]     11      0      A\n[6]     33     22      B\n[7]     55     44      C\n[8]     77     66      D\n[9]     99     88      E\n\n\nSimilarly, if the rows are different, we can use BiocFrame’s merge function:\n\nfrom biocframe import merge\n\nmodified1 = bframe1.set_row_names([\"A\", \"B\", \"C\", \"D\", \"E\"])\nmodified3 = bframe3.set_row_names([\"C\", \"D\", \"E\", \"F\", \"G\"])\n\ncombined = merge([modified1, modified3], by=None, join=\"outer\")\nprint(combined)\n\nBiocFrame with 7 rows and 4 columns\n     odd   even    foo    bar\n  &lt;list&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt;\nA      1      0   None   None\nB      3      2   None   None\nC      5      4      A   True\nD      7      6      B  False\nE      9      8      C   True\nF   None   None      D  False\nG   None   None      E   True"
  },
  {
    "objectID": "chapters/representations/biocframe.html#interop-with-pandas",
    "href": "chapters/representations/biocframe.html#interop-with-pandas",
    "title": "1  BiocFrame - Bioconductor-like data frames",
    "section": "1.6 Interop with pandas",
    "text": "1.6 Interop with pandas\nBiocFrame is intended for accurate representation of Bioconductor objects for interoperability with R. Most users will probably prefer to work with pandas DataFrame objects for their actual analyses. This conversion is easily achieved:\n\nfrom biocframe import BiocFrame\nbframe = BiocFrame(\n    {\n        \"foo\": [\"A\", \"B\", \"C\", \"D\", \"E\"],\n        \"bar\": [True, False, True, False, True]\n    }\n)\n\npd = bframe.to_pandas()\nprint(pd)\n\n  foo    bar\n0   A   True\n1   B  False\n2   C   True\n3   D  False\n4   E   True\n\n\nConversion back to a BiocFrame is similarly easy:\n\nout = BiocFrame.from_pandas(pd)\nprint(out)\n\nBiocFrame with 5 rows and 2 columns\n     foo    bar\n  &lt;list&gt; &lt;list&gt;\n0      A   True\n1      B  False\n2      C   True\n3      D  False\n4      E   True"
  },
  {
    "objectID": "chapters/representations/biocframe.html#empty-frames",
    "href": "chapters/representations/biocframe.html#empty-frames",
    "title": "1  BiocFrame - Bioconductor-like data frames",
    "section": "1.7 Empty Frames",
    "text": "1.7 Empty Frames\nWe can create empty BiocFrame objects that only specify the number of rows. This proves beneficial in situations where BiocFrame objects are integrated into more extensive data structures but do not possess any data themselves.\n\nempty = BiocFrame(number_of_rows=100)\nprint(empty)\n\nBiocFrame with 100 rows and 0 columns\n\n\n\nMost operations described in this document can be performed on an empty BiocFrame object.\n\nprint(\"Column names:\", empty.column_names)\n\nsubset_empty = empty[1:10,:]\nprint(\"\\nSubsetting an empty BiocFrame: \\n\", subset_empty)\n\nColumn names: []\n\nSubsetting an empty BiocFrame: \n BiocFrame with 9 rows and 0 columns\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nSimilarly one can create an empty BiocFrame with only row names."
  },
  {
    "objectID": "chapters/representations/biocframe.html#further-reading",
    "href": "chapters/representations/biocframe.html#further-reading",
    "title": "1  BiocFrame - Bioconductor-like data frames",
    "section": "1.8 Further reading",
    "text": "1.8 Further reading\nCheck out the reference documentation for more details.\nAlso see check out Bioconductor’s S4Vectors package, which implements the DFrame class on which BiocFrame was based."
  },
  {
    "objectID": "chapters/representations/iranges.html#installation",
    "href": "chapters/representations/iranges.html#installation",
    "title": "2  IRanges: Interval arithmetic",
    "section": "2.1 Installation",
    "text": "2.1 Installation\nTo get started, install the package from PyPI\npip install iranges\n\n\n\n\n\n\nNote\n\n\n\nThe descriptions for some of these methods come from the Bioconductor documentation."
  },
  {
    "objectID": "chapters/representations/iranges.html#construction",
    "href": "chapters/representations/iranges.html#construction",
    "title": "2  IRanges: Interval arithmetic",
    "section": "2.2 Construction",
    "text": "2.2 Construction\nAn IRanges holds a start position and a width, and is most typically used to represent coordinates along some genomic sequence. The interpretation of the start position depends on the application; for sequences, the start is usually a 1-based position, but other use cases may allow zero or even negative values (e.g. circular genomes).\n\nfrom iranges import IRanges\n\nstarts = [-2, 6, 9, -4, 1, 0, -6, 10]\nwidths = [5, 0, 6, 1, 4, 3, 2, 3]\nir = IRanges(starts, widths)\n\nprint(ir)\n\nIRanges object with 8 ranges and 0 metadata columns\n               start              end            width\n    &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt;\n[0]               -2                3                5\n[1]                6                6                0\n[2]                9               15                6\n[3]               -4               -3                1\n[4]                1                5                4\n[5]                0                3                3\n[6]               -6               -4                2\n[7]               10               13                3"
  },
  {
    "objectID": "chapters/representations/iranges.html#accessing-properties",
    "href": "chapters/representations/iranges.html#accessing-properties",
    "title": "2  IRanges: Interval arithmetic",
    "section": "2.3 Accessing properties",
    "text": "2.3 Accessing properties\nProperties can be accessed directly from the object:\n\nprint(\"Number of intervals:\", len(ir))\n\nprint(\"start positions:\", ir.get_start())\nprint(\"width of each interval:\", ir.get_width())\nprint(\"end positions:\", ir.get_end())\n\nNumber of intervals: 8\nstart positions: [-2  6  9 -4  1  0 -6 10]\nwidth of each interval: [5 0 6 1 4 3 2 3]\nend positions: [ 3  6 15 -3  5  3 -4 13]\n\n\n\n\n\n\n\n\nTip\n\n\n\nJust like BiocFrame, these classes offer both functional-style and property-based getters and setters.\n\n\n\nprint(\"start positions:\", ir.start)\nprint(\"width of each interval:\", ir.width)\nprint(\"end positions:\", ir.end)\n\nstart positions: [-2  6  9 -4  1  0 -6 10]\nwidth of each interval: [5 0 6 1 4 3 2 3]\nend positions: [ 3  6 15 -3  5  3 -4 13]"
  },
  {
    "objectID": "chapters/representations/iranges.html#reduced-ranges-normality",
    "href": "chapters/representations/iranges.html#reduced-ranges-normality",
    "title": "2  IRanges: Interval arithmetic",
    "section": "2.4 Reduced ranges (Normality)",
    "text": "2.4 Reduced ranges (Normality)\nreduce method reduces the intervals to an IRanges where the intervals are:\n\nnot empty\nnot overlapping\nordered from left to right\nnot even adjacent (i.e. there must be a non empty gap between 2 consecutive ranges).\n\n\nreduced = ir.reduce()\nprint(reduced)\n\nIRanges object with 4 ranges and 0 metadata columns\n               start              end            width\n    &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt;\n[0]               -6               -3                3\n[1]               -2                5                7\n[2]                6                6                0\n[3]                9               15                6"
  },
  {
    "objectID": "chapters/representations/iranges.html#overlap-operations",
    "href": "chapters/representations/iranges.html#overlap-operations",
    "title": "2  IRanges: Interval arithmetic",
    "section": "2.5 Overlap operations",
    "text": "2.5 Overlap operations\nIRanges uses nested containment lists under the hood to perform fast overlap and search-based operations.\n\nsubject = IRanges([2, 2, 10], [1, 2, 3])\nquery = IRanges([1, 4, 9], [5, 4, 2])\n\noverlap = subject.find_overlaps(query)\nprint(overlap)\n\n[[1, 0], [], [2]]\n\n\n\n2.5.1 Finding neighboring ranges\nThe nearest, precede or follow methods finds the nearest overlapping range along the specified direction.\n\nquery = IRanges([1, 3, 9], [2, 5, 2])\nsubject = IRanges([3, 5, 12], [1, 2, 1])\n\nnearest = subject.nearest(query, select=\"all\")\nprint(nearest)\n\n[[0], [0, 1], [2]]\n\n\n\n\n\n\n\n\nNote\n\n\n\nThese methods typically return a list of indices from subject for each interval in query.\n\n\n\n\n2.5.2 coverage\nThe coverage method counts the number of overlaps for each position.\n\ncov = subject.coverage()\nprint(cov)\n\n[0 0 1 0 1 1 0 0 0 0 0 1]"
  },
  {
    "objectID": "chapters/representations/iranges.html#transforming-ranges",
    "href": "chapters/representations/iranges.html#transforming-ranges",
    "title": "2  IRanges: Interval arithmetic",
    "section": "2.6 Transforming ranges",
    "text": "2.6 Transforming ranges\nshift adjusts the start positions by their shift.\n\nshifted = ir.shift(shift=10)\nprint(shifted)\n\nIRanges object with 8 ranges and 0 metadata columns\n               start              end            width\n    &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt;\n[0]                8               13                5\n[1]               16               16                0\n[2]               19               25                6\n[3]                6                7                1\n[4]               11               15                4\n[5]               10               13                3\n[6]                4                6                2\n[7]               20               23                3\n\n\nOther range transformation methods include narrow, resize, flank, reflect and restrict. For example narrow supports the adjustment of start, end and width values, which should be relative to each range.\n\nnarrowed = ir.narrow(start=4, width=2)\nprint(narrowed)\n\nIRanges object with 8 ranges and 0 metadata columns\n               start              end            width\n    &lt;ndarray[int64]&gt; &lt;ndarray[int64]&gt; &lt;ndarray[int64]&gt;\n[0]                1                3                2\n[1]                9               11                2\n[2]               12               14                2\n[3]               -1                1                2\n[4]                4                6                2\n[5]                3                5                2\n[6]               -3               -1                2\n[7]               13               15                2\n\n\n\n2.6.1 Disjoin intervals\nWell as the name says, computes disjoint intervals.\n\ndisjoint = ir.disjoin()\nprint(disjoint)\n\nIRanges object with 9 ranges and 0 metadata columns\n               start              end            width\n    &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt;\n[0]               -6               -4                2\n[1]               -4               -3                1\n[2]               -2                0                2\n[3]                0                1                1\n[4]                1                3                2\n[5]                3                5                2\n[6]                9               10                1\n[7]               10               13                3\n[8]               13               15                2\n\n\n\n\n2.6.2 reflect and flank\nreflect reverses each range within a set of common reference bounds.\n\nstarts = [2, 5, 1]\nwidths = [2, 3, 3]\nx = IRanges(starts, widths)\nbounds = IRanges([0, 5, 3], [11, 2, 7])\n\nres = x.reflect(bounds=bounds)\nprint(res)\n\nIRanges object with 3 ranges and 0 metadata columns\n               start              end            width\n    &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt;\n[0]                7                9                2\n[1]                4                7                3\n[2]                9               12                3\n\n\nflank returns ranges of a specified width that flank, to the left (default) or right, each input range. One use case of this is forming promoter regions for a set of genes.\n\nstarts = [2, 5, 1]\nwidths = [2, 3, 3]\nx = IRanges(starts, widths)\n\nres = x.flank(2, start=False)\nprint(res)\n\nIRanges object with 3 ranges and 0 metadata columns\n               start                end              width\n    &lt;ndarray[int32]&gt; &lt;ndarray[float64]&gt; &lt;ndarray[float64]&gt;\n[0]                4                6.0                2.0\n[1]                8               10.0                2.0\n[2]                4                6.0                2.0"
  },
  {
    "objectID": "chapters/representations/iranges.html#set-operations",
    "href": "chapters/representations/iranges.html#set-operations",
    "title": "2  IRanges: Interval arithmetic",
    "section": "2.7 Set operations",
    "text": "2.7 Set operations\nIRanges supports most interval set operations. For example, to compute gaps:\n\ngaps = ir.gaps()\nprint(gaps)\n\nIRanges object with 2 ranges and 0 metadata columns\n               start              end            width\n    &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt;\n[0]               -3               -2                1\n[1]                5                9                4\n\n\nOr Perform interval set operations, e..g union, intersection, disjoin:\n\nx = IRanges([1, 5, -2, 0, 14], [10, 5, 6, 12, 4])\ny = IRanges([14, 0, -5, 6, 18], [7, 3, 8, 3, 3])\n\nintersection = x.intersect(y)\nprint(intersection)\n\nIRanges object with 3 ranges and 0 metadata columns\n               start              end            width\n    &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt;\n[0]               -2                3                5\n[1]                6                9                3\n[2]               14               18                4"
  },
  {
    "objectID": "chapters/representations/iranges.html#further-reading",
    "href": "chapters/representations/iranges.html#further-reading",
    "title": "2  IRanges: Interval arithmetic",
    "section": "2.8 Further reading",
    "text": "2.8 Further reading\n\nIRanges reference\nBioc/IRanges"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#construct-a-genomicranges-object",
    "href": "chapters/representations/genomicranges.html#construct-a-genomicranges-object",
    "title": "3  GenomicRanges: Genomic analysis",
    "section": "3.1 Construct a GenomicRanges object",
    "text": "3.1 Construct a GenomicRanges object\nTo construct a GenomicRanges object from interval ranges (Preferred way)\n\nfrom genomicranges import GenomicRanges\nfrom iranges import IRanges\nfrom biocframe import BiocFrame\nfrom random import random\n\ngr = GenomicRanges(\n    seqnames=[\n        \"chr1\",\n        \"chr2\",\n        \"chr3\",\n        \"chr2\",\n        \"chr3\",\n    ],\n    ranges=IRanges([x for x in range(101, 106)], [11, 21, 25, 30, 5]),\n    strand=[\"*\", \"-\", \"*\", \"+\", \"-\"],\n    mcols=BiocFrame(\n        {\n            \"score\": range(0, 5),\n            \"GC\": [random() for _ in range(5)],\n        }\n    ),\n)\n\nprint(gr)\n\nGenomicRanges with 5 ranges and 5 metadata columns\n    seqnames    ranges          strand     score                   GC\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;range&gt;               &lt;list&gt;\n[0]     chr1 101 - 112               * |       0 0.021511451932259007\n[1]     chr2 102 - 123               - |       1   0.8409285772112208\n[2]     chr3 103 - 128               * |       2  0.41454684085191285\n[3]     chr2 104 - 134               + |       3   0.6478889885943879\n[4]     chr3 105 - 110               - |       4   0.3580153647319536\n------\nseqinfo(3 sequences): chr1 chr2 chr3\n\n\n\n3.1.1 From UCSC or GTF file\nYou can also import genomes from UCSC or load a genome annotation from a GTF file:\n\nimport genomicranges\n\n# gr = genomicranges.read_gtf(&lt;PATH TO GTF&gt;)\n\n# OR\n\n# gr = genomicranges.read_ucsc(genome=\"hg19\")\n# print(gr)\n\n\n\n3.1.2 Pandas DataFrame\nIf your genomic coordinates are represented as a pandas DataFrame, convert this into GenomicRanges if it contains the necessary columns.\n\n\n\n\n\n\nNote\n\n\n\nThe DataFrame must contain columns seqnames, starts and ends to represent genomic coordinates. The rest of the columns are considered metadata and will be available in the mcols slot of the GenomicRanges object.\n\n\n\nfrom genomicranges import GenomicRanges\nimport pandas as pd\n\ndf = pd.DataFrame(\n    {\n        \"seqnames\": [\"chr1\", \"chr2\", \"chr1\", \"chr3\", \"chr2\"],\n        \"starts\": [101, 102, 103, 104, 109],\n        \"ends\": [112, 103, 128, 134, 111],\n        \"strand\": [\"*\", \"-\", \"*\", \"+\", \"-\"],\n        \"score\": range(0, 5),\n        \"GC\": [random() for _ in range(5)],\n    }\n)\n\ngr = GenomicRanges.from_pandas(df)\nprint(gr)\n\nGenomicRanges with 5 ranges and 5 metadata columns\n  seqnames    ranges          strand    score                  GC\n     &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;list&gt;              &lt;list&gt;\n0     chr1 101 - 112               * |      0   0.144592734530271\n1     chr2 102 - 103               - |      1  0.9305877960853849\n2     chr1 103 - 128               * |      2  0.9212374977990112\n3     chr3 104 - 134               + |      3  0.8769718696039641\n4     chr2 109 - 111               - |      4 0.24378056228940836\n------\nseqinfo(3 sequences): chr1 chr2 chr3\n\n\n\n\n3.1.3 Set sequence information\nThe package provides a SeqInfo class to update or modify sequence information stored in the object. earn more about this in the GenomeInfoDb package.\n\nfrom genomicranges import SeqInfo\n\nseq_obj = {\n    \"seqnames\": [\"chr1\", \"chr2\", \"chr3\",],\n    \"seqlengths\": range(100, 103),\n    \"is_circular\": [random() &lt; 0.5 for _ in range(3)],\n    \"genome\": \"hg19\",\n}\n\nseq = SeqInfo(seq_obj)\ngr.seq_info = seq\nprint(gr)\n\nGenomicRanges with 5 ranges and 5 metadata columns\n  seqnames    ranges          strand    score                  GC\n     &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;list&gt;              &lt;list&gt;\n0     chr1 101 - 112               * |      0   0.144592734530271\n1     chr2 102 - 103               - |      1  0.9305877960853849\n2     chr1 103 - 128               * |      2  0.9212374977990112\n3     chr3 104 - 134               + |      3  0.8769718696039641\n4     chr2 109 - 111               - |      4 0.24378056228940836\n------\nseqinfo(3 sequences): chr1 chr2 chr3"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#getterssetters",
    "href": "chapters/representations/genomicranges.html#getterssetters",
    "title": "3  GenomicRanges: Genomic analysis",
    "section": "3.2 Getters/Setters",
    "text": "3.2 Getters/Setters\nGetters are available to access various properties.\n\n# access sequence names\ngr.seqnames\n\n# access all start positions\ngr.start\n\n# access annotation information if available\ngr.seq_info\n\n# compute and return the widths of each region\ngr.width\n\n# access metadata columns, everything other than genomic locations\nprint(gr.mcols)\n\nBiocFrame with 5 rows and 2 columns\n   score                  GC\n  &lt;list&gt;              &lt;list&gt;\n0      0   0.144592734530271\n1      1  0.9305877960853849\n2      2  0.9212374977990112\n3      3  0.8769718696039641\n4      4 0.24378056228940836\n\n\n\n3.2.1 Setters\n\n\n\n\n\n\nImportant\n\n\n\nAll property-based setters are in_place operations. Methods are available to get and set properties on GenomicRanges.\n\n\n\ngr.mcols = gr.mcols.set_column(\"score\", range(1,6))\n\n# or use an in-place operation\ngr.mcols.set_column(\"score\", range(1,6), in_place=True)\n\nprint(gr.mcols)\n\nBiocFrame with 5 rows and 2 columns\n    score                  GC\n  &lt;range&gt;              &lt;list&gt;\n0       1   0.144592734530271\n1       2  0.9305877960853849\n2       3  0.9212374977990112\n3       4  0.8769718696039641\n4       5 0.24378056228940836\n\n\n\n\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/genomicranges/GenomicRanges.py:761: UserWarning: Setting property 'mcols' is an in-place operation, use 'set_mcols' instead\n  warn(\n\n\n\n\n3.2.2 Access ranges\nranges() is a generic method to access only the genomic coordinates:\n\n# or gr.get_ranges()\n\nprint(gr.ranges)\n\nIRanges object with 5 ranges and 0 metadata columns\n               start              end            width\n    &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt; &lt;ndarray[int32]&gt;\n[0]              101              112               11\n[1]              102              103                1\n[2]              103              128               25\n[3]              104              134               30\n[4]              109              111                2"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#subset-operations",
    "href": "chapters/representations/genomicranges.html#subset-operations",
    "title": "3  GenomicRanges: Genomic analysis",
    "section": "3.3 Subset operations",
    "text": "3.3 Subset operations\nYou can subset a GenomicRange object using the subset ([]) operator. This operation accepts different slice input types, such as a boolean vector, a `slice`` object, a list of indices, or row/column names to subset.\n\n# slice the first 3 rows\ngr[:3]\n\n# slice 1, 3 and 2nd rows\nprint(gr[[1,3,2]])\n\nGenomicRanges with 3 ranges and 3 metadata columns\n  seqnames    ranges          strand    score                 GC\n     &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;list&gt;             &lt;list&gt;\n1     chr2 102 - 103               - |      2 0.9305877960853849\n3     chr3 104 - 134               + |      4 0.8769718696039641\n2     chr1 103 - 128               * |      3 0.9212374977990112\n------\nseqinfo(3 sequences): chr1 chr2 chr3"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#iterate-over-intervals",
    "href": "chapters/representations/genomicranges.html#iterate-over-intervals",
    "title": "3  GenomicRanges: Genomic analysis",
    "section": "3.4 Iterate over intervals",
    "text": "3.4 Iterate over intervals\nYou can iterate over the intervals of a GenomicRanges object. rowname is None if the object does not contain any row names.\n\nfor rowname, row in gr[:2]:\n    print(rowname, row)\n\n0 GenomicRanges with 1 range and 1 metadata column\n  seqnames    ranges          strand    score                GC\n     &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;list&gt;            &lt;list&gt;\n0     chr1 101 - 112               * |      1 0.144592734530271\n------\nseqinfo(3 sequences): chr1 chr2 chr3\n1 GenomicRanges with 1 range and 1 metadata column\n  seqnames    ranges          strand    score                 GC\n     &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;list&gt;             &lt;list&gt;\n1     chr2 102 - 103               - |      2 0.9305877960853849\n------\nseqinfo(3 sequences): chr1 chr2 chr3"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#intra-range-transformations",
    "href": "chapters/representations/genomicranges.html#intra-range-transformations",
    "title": "3  GenomicRanges: Genomic analysis",
    "section": "3.5 Intra-range transformations",
    "text": "3.5 Intra-range transformations\nFor detailed description of these methods, refer to Bioconductor’s GenomicRanges documentation\n\nflank: Flank the intervals based on start or end or both.\nshift: Shifts all the ranges specified by the shift argument.\nresize: Resizes the ranges to the specified width where either the start, end, or center is used as an anchor.\nnarrow: Narrows the ranges.\npromoters: Promoters generates promoter ranges for each range relative to the TSS.The promoter range is expanded around the TSS according to the upstream and downstream parameters.\nrestrict: Restricts the ranges to the interval(s) specified by the start and end arguments.\ntrim: Trims out-of-bound ranges located on non-circular sequences whose length is not NA.\n\n\ngr = GenomicRanges(\n    seqnames=[\n        \"chr1\",\n        \"chr2\",\n        \"chr3\",\n        \"chr2\",\n        \"chr3\",\n    ],\n    ranges=IRanges([x for x in range(101, 106)], [11, 21, 25, 30, 5]),\n    strand=[\"*\", \"-\", \"*\", \"+\", \"-\"],\n    mcols=BiocFrame(\n        {\n            \"score\": range(0, 5),\n            \"GC\": [random() for _ in range(5)],\n        }\n    ),\n)\n\n# flank\nflanked_gr = gr.flank(width=10, start=False, both=True)\n\n# shift\nshifted_gr = gr.shift(shift=10)\n\n# resize\nresized_gr = gr.resize(width=10, fix=\"end\", ignore_strand=True)\n\n# narrow\nnarrow_gr = gr.narrow(end=1, width=1)\n\n# promoters\nprom_gr = gr.promoters()\n\n# restrict\nrestrict_gr = gr.restrict(start=114, end=140, keep_all_ranges=True)\n\n# trim\ntrimmed_gr = gr.trim()\n\n/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/iranges/IRanges.py:290: UserWarning: Setting property 'width'is an in-place operation, use 'set_width' instead\n  warn("
  },
  {
    "objectID": "chapters/representations/genomicranges.html#inter-range-methods",
    "href": "chapters/representations/genomicranges.html#inter-range-methods",
    "title": "3  GenomicRanges: Genomic analysis",
    "section": "3.6 Inter-range methods",
    "text": "3.6 Inter-range methods\n\nrange: Returns a new GenomicRanges object containing range bounds for each distinct (seqname, strand) pair.\nreduce: returns a new GenomicRanges object containing reduced bounds for each distinct (seqname, strand) pair.\ngaps: Finds gaps in the GenomicRanges object for each distinct (seqname, strand) pair.\ndisjoin: Finds disjoint intervals across all locations for each distinct (seqname, strand) pair.\n\n\ngr = GenomicRanges(\n    seqnames=[\n        \"chr1\",\n        \"chr2\",\n        \"chr3\",\n        \"chr2\",\n        \"chr3\",\n    ],\n    ranges=IRanges([x for x in range(101, 106)], [11, 21, 25, 30, 5]),\n    strand=[\"*\", \"-\", \"*\", \"+\", \"-\"],\n    mcols=BiocFrame(\n        {\n            \"score\": range(0, 5),\n            \"GC\": [random() for _ in range(5)],\n        }\n    ),\n)\n\n# range\nrange_gr = gr.range()\n\n# reduce\n# reduced_gr = gr.reduce(min_gap_width=3, with_reverse_map=True)\n\n# gaps\ngapped_gr = gr.gaps(start=103)  # OR\ngapped_gr = gr.gaps(end={\"chr1\": 120, \"chr2\": 120, \"chr3\": 120})\n\n# disjoin\ndisjoin_gr = gr.disjoin()\n\nprint(disjoin_gr)\n\nGenomicRanges with 5 ranges and 5 metadata columns\n    seqnames    ranges          strand\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;\n[0]     chr1 101 - 112               *\n[1]     chr2 104 - 134               +\n[2]     chr2 102 - 123               -\n[3]     chr3 105 - 110               -\n[4]     chr3 103 - 128               *\n------\nseqinfo(3 sequences): chr1 chr2 chr3"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#set-operations-on-genomic-ranges",
    "href": "chapters/representations/genomicranges.html#set-operations-on-genomic-ranges",
    "title": "3  GenomicRanges: Genomic analysis",
    "section": "3.7 Set operations on genomic ranges",
    "text": "3.7 Set operations on genomic ranges\n\nunion: Compute the union of intervals across object.\nintersect: Compute the intersection or finds overlapping intervals.\nsetdiff: Compute set difference.\n\n\ng_src = GenomicRanges(\n    seqnames = [\"chr1\", \"chr2\", \"chr1\", \"chr3\", \"chr2\"],\n    ranges = IRanges(start =[101, 102, 103, 104, 109], width=[112, 103, 128, 134, 111]),\n    strand = [\"*\", \"-\", \"*\", \"+\", \"-\"]\n)\n\ng_tgt = GenomicRanges(\n    seqnames = [\"chr1\",\"chr2\",\"chr2\",\"chr2\",\"chr1\",\"chr1\",\"chr3\",\"chr3\",\"chr3\",\"chr3\"],\n    ranges = IRanges(start =range(101, 111), width=range(121, 131)),\n    strand = [\"*\", \"-\", \"-\", \"*\", \"*\", \"+\", \"+\", \"+\", \"-\", \"-\"]\n)\n\n\n# intersection\nint_gr = g_src.intersect(g_tgt)\n\n# set diff\ndiff_gr = g_src.setdiff(g_tgt)\n\n# union\nunion_gr = g_src.union(g_tgt)\n\nprint(union_gr)\n\nGenomicRanges with 6 ranges and 6 metadata columns\n    seqnames    ranges          strand\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;\n[0]     chr1 106 - 232               +\n[1]     chr1 101 - 231               *\n[2]     chr2 102 - 226               -\n[3]     chr2 104 - 228               *\n[4]     chr3 104 - 238               +\n[5]     chr3 109 - 240               -\n------\nseqinfo(3 sequences): chr1 chr2 chr3"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#compute-over-bins",
    "href": "chapters/representations/genomicranges.html#compute-over-bins",
    "title": "3  GenomicRanges: Genomic analysis",
    "section": "3.8 Compute over bins",
    "text": "3.8 Compute over bins\n\n3.8.1 Summary stats for column\nUse Pandas for computing summary statistics for a column:\n\npd.Series(gr.mcols.get_column(\"score\")).describe()\n\ncount    5.000000\nmean     2.000000\nstd      1.581139\nmin      0.000000\n25%      1.000000\n50%      2.000000\n75%      3.000000\nmax      4.000000\ndtype: float64\n\n\n\n\n3.8.2 binned_average\nCompute binned average for different positions:\n\nbins = pd.DataFrame({\"seqnames\": [\"chr1\"], \"starts\": [101], \"ends\": [109],})\n\nbins_gr = GenomicRanges.from_pandas(bins)\n\nsubject = GenomicRanges(\n    seqnames= [\"chr1\",\"chr2\",\"chr2\",\"chr2\",\"chr1\",\"chr1\",\"chr3\",\"chr3\",\"chr3\",\"chr3\"],\n    ranges=IRanges(range(101, 111), range(121, 131)),\n    strand= [\"*\", \"-\", \"-\", \"*\", \"*\", \"+\", \"+\", \"+\", \"-\", \"-\"],\n    mcols=BiocFrame({\n        \"score\": range(0, 10),\n    })\n)\n\n# Compute binned average\nbinned_avg_gr = subject.binned_average(bins=bins_gr, scorename=\"score\", outname=\"binned_score\")\nprint(binned_avg_gr)\n\nGenomicRanges with 1 range and 1 metadata column\n  seqnames    ranges          strand   binned_score\n     &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;         &lt;list&gt;\n0     chr1 101 - 109               * |            2\n------\nseqinfo(1 sequences): chr1\n\n\n\n\n\n\n\n\nTip\n\n\n\nNow you might wonder how can I generate these bins?\n\n\n\n\n3.8.3 Generate tiles or bins from GenomicRanges\n\ntile: Splits each genomic region by n (number of regions) or by width (maximum width of each tile).\nsliding_windows: Generates sliding windows within each range, by width and step.\n\n\ngr = GenomicRanges(\n    seqnames=[\n        \"chr1\",\n        \"chr2\",\n        \"chr3\",\n        \"chr2\",\n        \"chr3\",\n    ],\n    ranges=IRanges([x for x in range(101, 106)], [11, 21, 25, 30, 5]),\n    strand=[\"*\", \"-\", \"*\", \"+\", \"-\"],\n    mcols=BiocFrame(\n        {\n            \"score\": range(0, 5),\n            \"GC\": [random() for _ in range(5)],\n        }\n    ),\n)\n\n# tiles\ntiles = gr.tile(n=2)\n\n# slidingwindows\ntiles = gr.sliding_windows(width=10)\nprint(tiles)\n\nGenomicRanges with 52 ranges and 52 metadata columns\n     seqnames    ranges          strand\n        &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;\n [0]     chr1 101 - 110               *\n [1]     chr1 102 - 111               *\n [2]     chr2 102 - 111               -\n          ...       ...             ...\n[49]     chr2 123 - 132               +\n[50]     chr2 124 - 133               +\n[51]     chr3 105 - 109               -\n------\nseqinfo(3 sequences): chr1 chr2 chr3\n\n\n\n\n3.8.4 Generate tiles from Genome\ntile_genome returns a set of genomic regions that form a partitioning of the specified genome.\n\nseqlengths = {\"chr1\": 100, \"chr2\": 75, \"chr3\": 200}\n\ntiles = GenomicRanges.tile_genome(seqlengths=seqlengths, n=10)\nprint(tiles)\n\nGenomicRanges with 30 ranges and 30 metadata columns\n     seqnames    ranges          strand\n        &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;\n [0]     chr1    1 - 10               *\n [1]     chr1   11 - 20               *\n [2]     chr1   21 - 30               *\n          ...       ...             ...\n[27]     chr3 141 - 160               *\n[28]     chr3 161 - 180               *\n[29]     chr3 181 - 200               *\n------\nseqinfo(3 sequences): chr1 chr2 chr3\n\n\n\n\n3.8.5 Coverage\nComputes number of ranges that overlap for each position in the range.\n\nimport rich \n\nres_vector = gr.coverage(shift=10, width=5)\nrich.print(res_vector)\n\n{'chr1': array([0., 0., 0., 0., 0.]), 'chr2': array([0., 0., 0., 0., 0.]), 'chr3': array([0., 0., 0., 0., 0.])}"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#overlap-based-methods",
    "href": "chapters/representations/genomicranges.html#overlap-based-methods",
    "title": "3  GenomicRanges: Genomic analysis",
    "section": "3.9 Overlap based methods",
    "text": "3.9 Overlap based methods\n\nfind_overlaps: Find overlaps between two GenomicRanges objects.\ncount_overlaps: Count overlaps between two GenomicRanges objects.\nsubset_by_overlaps: Subset a GenomicRanges object if it overlaps with the ranges in the query.\n\n\nsubject = GenomicRanges(\n    seqnames= [\"chr1\",\"chr2\",\"chr2\",\"chr2\",\"chr1\",\"chr1\",\"chr3\",\"chr3\",\"chr3\",\"chr3\"],\n    ranges=IRanges(range(101, 111), range(121, 131)),\n    strand= [\"*\", \"-\", \"-\", \"*\", \"*\", \"+\", \"+\", \"+\", \"-\", \"-\"],\n    mcols=BiocFrame({\n        \"score\": range(0, 10),\n    })\n)\n\ndf_query = pd.DataFrame(\n    {\"seqnames\": [\"chr2\",], \"starts\": [4], \"ends\": [6], \"strand\": [\"+\"]}\n)\n\nquery = GenomicRanges.from_pandas(df_query)\n\n# find Overlaps\nres = subject.find_overlaps(query, query_type=\"within\")\n\n# count Overlaps\nres = subject.count_overlaps(query)\n\n# subset by Overlaps\nres = subject.subset_by_overlaps(query)\n\nprint(res)\n\nGenomicRanges with 0 ranges and 0 metadata columns\nseqinfo(3 sequences): chr1 chr2 chr3"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#search-operations",
    "href": "chapters/representations/genomicranges.html#search-operations",
    "title": "3  GenomicRanges: Genomic analysis",
    "section": "3.10 Search operations",
    "text": "3.10 Search operations\n\nnearest: Performs nearest neighbor search along any direction (both upstream and downstream).\nfollow: Performs nearest neighbor search only along downstream.\nprecede: Performs nearest neighbor search only along upstream.\n\n\nfind_regions = GenomicRanges(\n    seqnames= [\"chr1\", \"chr2\", \"chr3\"],\n    ranges=IRanges([200, 105, 1190],[203, 106, 1200]),\n)\n\nquery_hits = gr.nearest(find_regions)\n\nquery_hits = gr.precede(find_regions)\n\nquery_hits = gr.follow(find_regions)\n\nprint(query_hits)\n\n[[0], [2]]\n\n\n\n\n\n\n\n\nNote\n\n\n\nSimilar to IRanges operations, these methods typically return a list of indices from subject for each interval in query."
  },
  {
    "objectID": "chapters/representations/genomicranges.html#comparison-rank-and-order-operations",
    "href": "chapters/representations/genomicranges.html#comparison-rank-and-order-operations",
    "title": "3  GenomicRanges: Genomic analysis",
    "section": "3.11 Comparison, rank and order operations",
    "text": "3.11 Comparison, rank and order operations\n\nmatch: Element-wise comparison to find exact match intervals.\norder: Get the order of indices for sorting.\nsort: Sort the GenomicRanges object.\nrank: For each interval identifies its position is a sorted order.\n\n\n# match\nquery_hits = gr.match(gr[2:5])\nprint(\"matches: \", query_hits)\n\n# order\norder = gr.order()\nprint(\"order:\", order)\n\n# sort\nsorted_gr = gr.sort()\nprint(\"sorted:\", sorted_gr)\n\n# rank\nrank = gr.rank()\nprint(\"rank:\", rank)\n\nmatches:  [[2], [3], [4]]\norder: [0 1 3 4 2]\nsorted: GenomicRanges with 5 ranges and 5 metadata columns\n    seqnames    ranges          strand    score                  GC\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;list&gt;              &lt;list&gt;\n[0]     chr1 101 - 112               * |      0  0.4228234808915702\n[1]     chr2 102 - 123               - |      1  0.5647045789357994\n[2]     chr2 104 - 134               + |      3   0.589308124964188\n[3]     chr3 105 - 110               - |      4 0.08058799565870578\n[4]     chr3 103 - 128               * |      2 0.38885717230505745\n------\nseqinfo(3 sequences): chr1 chr2 chr3\nrank: [0, 1, 4, 2, 3]"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#combine-genomicranges-objects-by-rows",
    "href": "chapters/representations/genomicranges.html#combine-genomicranges-objects-by-rows",
    "title": "3  GenomicRanges: Genomic analysis",
    "section": "3.12 Combine GenomicRanges objects by rows",
    "text": "3.12 Combine GenomicRanges objects by rows\nUse the combine generic from biocutils to concatenate multiple GenomicRanges objects.\n\nfrom biocutils.combine import combine\na = GenomicRanges(\n    seqnames=[\"chr1\", \"chr2\", \"chr1\", \"chr3\"],\n    ranges=IRanges([1, 3, 2, 4], [10, 30, 50, 60]),\n    strand=[\"-\", \"+\", \"*\", \"+\"],\n    mcols=BiocFrame({\"score\": [1, 2, 3, 4]}),\n)\n\nb = GenomicRanges(\n    seqnames=[\"chr2\", \"chr4\", \"chr5\"],\n    ranges=IRanges([3, 6, 4], [30, 50, 60]),\n    strand=[\"-\", \"+\", \"*\"],\n    mcols=BiocFrame({\"score\": [2, 3, 4]}),\n)\n\ncombined = combine(a,b)\nprint(combined)\n\nGenomicRanges with 7 ranges and 7 metadata columns\n    seqnames    ranges          strand    score\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;list&gt;\n[0]     chr1    1 - 11               - |      1\n[1]     chr2    3 - 33               + |      2\n[2]     chr1    2 - 52               * |      3\n[3]     chr3    4 - 64               + |      4\n[4]     chr1    3 - 33               - |      2\n[5]     chr2    6 - 56               + |      3\n[6]     chr3    4 - 64               * |      4\n------\nseqinfo(5 sequences): chr1 chr2 chr3 chr4 chr5"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#misc-operations",
    "href": "chapters/representations/genomicranges.html#misc-operations",
    "title": "3  GenomicRanges: Genomic analysis",
    "section": "3.13 Misc operations",
    "text": "3.13 Misc operations\n\ninvert_strand: flip the strand for each interval\nsample: randomly choose k intervals\n\n\n# invert strand\ninv_gr = gr.invert_strand()\n\n# sample\nsamp_gr = gr.sample(k=4)"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#construct-a-genomicrangeslist-object.",
    "href": "chapters/representations/genomicranges.html#construct-a-genomicrangeslist-object.",
    "title": "3  GenomicRanges: Genomic analysis",
    "section": "3.14 Construct a GenomicRangesList object.",
    "text": "3.14 Construct a GenomicRangesList object.\nJust as it sounds, a GenomicRangesList is a named-list like object.\nIf you are wondering why you need this class, a GenomicRanges object lets us specify multiple genomic elements, usually where the genes start and end. Genes are themselves made of many sub regions, e.g. exons. GenomicRangesList allows us to represent this nested structure.\nCurrently, this class is limited in functionality, purely a read-only class with basic accessors.\nNote: This is a work in progress and the functionality is limited.\n\nfrom genomicranges import GenomicRangesList\na = GenomicRanges(\n    seqnames=[\"chr1\", \"chr2\", \"chr1\", \"chr3\"],\n    ranges=IRanges([1, 3, 2, 4], [10, 30, 50, 60]),\n    strand=[\"-\", \"+\", \"*\", \"+\"],\n    mcols=BiocFrame({\"score\": [1, 2, 3, 4]}),\n)\n\nb = GenomicRanges(\n    seqnames=[\"chr2\", \"chr4\", \"chr5\"],\n    ranges=IRanges([3, 6, 4], [30, 50, 60]),\n    strand=[\"-\", \"+\", \"*\"],\n    mcols=BiocFrame({\"score\": [2, 3, 4]}),\n)\n\ngrl = GenomicRangesList(ranges=[a,b], names=[\"gene1\", \"gene2\"])\nprint(grl)\n\nGenomicRangesList with 2 ranges and 2 metadata columns\n \nName: gene1 \nGenomicRanges with 4 ranges and 4 metadata columns\n    seqnames    ranges          strand    score\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;list&gt;\n[0]     chr1    1 - 11               - |      1\n[1]     chr2    3 - 33               + |      2\n[2]     chr1    2 - 52               * |      3\n[3]     chr3    4 - 64               + |      4\n------\nseqinfo(3 sequences): chr1 chr2 chr3\n \nName: gene2 \nGenomicRanges with 3 ranges and 3 metadata columns\n    seqnames    ranges          strand    score\n       &lt;str&gt; &lt;IRanges&gt; &lt;ndarray[int8]&gt;   &lt;list&gt;\n[0]     chr2    3 - 33               - |      2\n[1]     chr4    6 - 56               + |      3\n[2]     chr5    4 - 64               * |      4\n------\nseqinfo(3 sequences): chr2 chr4 chr5"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#properties",
    "href": "chapters/representations/genomicranges.html#properties",
    "title": "3  GenomicRanges: Genomic analysis",
    "section": "3.15 Properties",
    "text": "3.15 Properties\n\ngrl.start\ngrl.width\n\n{'gene1': array([10, 30, 50, 60], dtype=int32),\n 'gene2': array([30, 50, 60], dtype=int32)}"
  },
  {
    "objectID": "chapters/representations/genomicranges.html#combine-genomicrangeslist-object",
    "href": "chapters/representations/genomicranges.html#combine-genomicrangeslist-object",
    "title": "3  GenomicRanges: Genomic analysis",
    "section": "3.16 Combine GenomicRangeslist object",
    "text": "3.16 Combine GenomicRangeslist object\nSimilar to the combine function from GenomicRanges,\n\ngrla = GenomicRangesList(ranges=[a], names=[\"a\"])\ngrlb = GenomicRangesList(ranges=[b, a], names=[\"b\", \"c\"])\n\n# or use the combine generic\nfrom biocutils.combine import combine\ncgrl = combine(grla, grlb)\n\nand that’s all for now! Check back later for more updates."
  },
  {
    "objectID": "chapters/summary.html",
    "href": "chapters/summary.html",
    "title": "4  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever."
  }
]